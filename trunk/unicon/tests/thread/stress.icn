global gsum, str, v, w

procedure main(argv)

   gsum:=0

   thrdL := []

   if *argv>0 then
      n:=integer(argv[1]) | stop ("arg must be integer")
    else
      n:=1

   x := 10^8
   d:= x / n

   t:=&now
 
   every 1 to 6 do put(thrdL, thread dowork(n, d, x))


   write("---------firing A... ")
   a := thread (A())

   write("---------waiting for  A... ")
   wait(a)
   write("---------A is Done... ")

   write("+++++++++++firing B... ")
   b := thread B()

   write("+++++++++++waiting 4 B... ")
   wait(b)
   write("************** firing C... ")
   c := thread C()

   write("*************waiting 4 C ... ")
   B()
   wait(c)

   write("Done all... ")

   dowork(n, d, x)

  every wait(!thrdL)

 # print the sum. (x-d*n) is just an error correction when using "odd" # of threads.
   write("sum=",gsum+(x-d*n))
   
   write("time:", &now-t, " seconds")

end

procedure dowork(n, d, x)
   thrd := []
   write(n , " thread(s) will sum ", x, " ones.")
   write("The work will be divided equally between them. Please wait... ")

   every i:=!n do put(thrd, thread suma(d, i))
   every wait(!thrd)
end

procedure suma(n, id)
   local sum:=0
   static region
   initial  region := mutex()

   every !n do sum+:=1

   critical region:  gsum +:= sum

   write("Thread ", id , " is done")

end

procedure A()
   /str := ""
   every i:=1 to 10000 do {
     if i%100=1 then { L:=[]; str:="A" }
     put(L, table())
     put(L, list(100))
     x := "jafar"
       str ||:= x
   } 
   
   w := x
   v := w

   return L

end

procedure B()
 /x:=[]
   /str := ""
   every i:=1 to 100000 do {
     if i%100=1 then{ L:=[]; str:="B" }
     put(L, T:=table())
     every j:=1 to 100 do T[j]:=j
     put(L, list(10000))
     x := "ray"
     str ||:= x
 }

w := x
v ||:= w 

end

procedure C()
   /str := ""

   every i:=1 to 10000 do {
     if i%100=1 then L:=[]
     if i%1000=999 then str := "C"
     x := "hiba"
     put(L, table())
     put(L, list(1000))
     str ||:= x
   } 
w := x
v ||:= w

end
