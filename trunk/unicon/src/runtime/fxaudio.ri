/*
 * File: fxaudio.ri - Unicon Audio + VoIP Interface
 *  Contents: PlayAudio, StopAudio, VAttrib.
 */

#ifdef Audio

"PlayAudio(s) - Play audio file."
function{0,1} PlayAudio(fname)

   declare {
      tended struct descrip filename;
      }

   if !cnv:C_string(fname) then
      runerr(103,fname)

    abstract {
      return file;
      }

   body {
      int status;
      FILE * f;
      struct b_file *fl;

      if ((f = (FILE*) StartAudioThread(fname)) == NULL) fail;
      status = 1;
      StrLen(filename) = strlen(fname);
      StrLoc(filename) = fname;
      Protect(fl = alcfile(f, status, &filename), runerr(0));
      return file(fl);
      }
end

"StopAudio - kill the audio thread."
function{1} StopAudio(f)

   if !is:file(f) then
      runerr(105, f)

   abstract {
      return integer;
      }

   body {
      /* we are passing the file name as struct */
      AudioPtr Ptr;
      Ptr = (AudioPtr)BlkD(f,File)->fd.fp;
      StopAudioThread(Ptr);
      return C_integer 1;
      }
end

#else					/* Audio */
MissingFunc1(PlayAudio)
MissingFunc1(StopAudio)
#endif					/* Audio */

#ifdef HAVE_VOICE

/*function{0,1} VAttrib(f,attrib)*/

"VAttrib(f,attrib) - set voice attribute. "
function{*} VAttrib(argv[argc])
   abstract {
      return integer ++ string ++ list;
      }
   body {
      int varg = 0;
      int i,res=0;
      tended struct descrip sbuf; 
     
      tended char * attrib='\0';
 
      if (!is:file(argv[0])) {
	 for(i = 0 ; i < argc ; i++ ){
	    if (!cnv:C_string(argv[i], attrib))
	       runerr(103,argv[i]);
	    res = AudioMixer(attrib);
	    }
	 if(res >= 0)
	    return C_integer res;
	 else
	    fail;
	 }
      else {
      PVSESSION Ptr;
      Ptr = (PVSESSION)BlkD(argv[0],File)->fd.fp;
      if (!cnv:tmp_string(argv[1], sbuf)) /* sbuf not allocated */
          runerr(109, argv[1]);

      attrib = StrLoc(sbuf);

      if (strstr(attrib, "+=") || strstr(attrib, "-=") ) {
	 SetVoiceAttrib(Ptr, attrib);
	 return C_integer 1;
	 }
      else {
	 if (strchr(attrib,'=')){
	    /* forming the attrib list  */
	    int i , k;
	    char *s;
	    struct descrip Str;
	    tended struct descrip L;
	    tended struct b_list *hp;

	    /* create empty list  */
	    if ((hp=alclist(0, MinListSlots)) == NULL) fail;
	    L.dword=D_List;
	    L.vword.bptr=(union block *) hp;

	    /* forming the list */
	    k = GetVListSize(Ptr);
	    if (strstr(attrib,"name") && (!strstr(attrib,"address"))){
	       for(i=0; i<= k; ++i){
		  s = FetchName(Ptr,i);
		  if (s != NULL) {
		     MakeStr(s,strlen(s),&Str);
		     c_put(&L, &Str);
		     }
		  }
	       }
	    else {
	       if (strstr(attrib,"address") && (!strstr(attrib,"name"))) {
		  for(i=0; i<= k; ++i){
		     s = FetchAddress(Ptr,i);
		     if (s != NULL) {
			MakeStr(s,strlen(s),&Str);
			c_put(&L, &Str);
			}
		     }
		  }
	       else	
		  for(i=0; i<= k; ++i) {
		     s = FetchListener(Ptr,i);
		     if (s != NULL) {
			MakeStr(s,strlen(s),&Str);
			c_put(&L, &Str);
			}
		     }/* end for */
	       }
	    return L;
	    }
	 else {
	    /* forming the attrib string   */
	    char tmpstr[MaxCvtLen],*str;
	    int i, k = GetVListSize(Ptr), len=0;
	    tmpstr[0] = '\0';
	    for (i=0; i<= k; ++i) {
	       str = FetchListener(Ptr, i);
	       if (str != NULL) {
		  strcat(tmpstr, str);
		  strcat(tmpstr, ",");
		  }
	       }
	    len = strlen(tmpstr)-1;
	    tmpstr[len] = '\0';
	    return C_string tmpstr;
	    }
	 return C_integer 1;
	 }
      return C_integer 1;
      }
      }
end

#else					/* HAVE_VOICE */

MissingFunc2(VAttrib)

#endif					/* HAVE_VOICE */
