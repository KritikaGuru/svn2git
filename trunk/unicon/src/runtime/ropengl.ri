/*
 *  File: ropengl.ri
 *     3D facilities OpenGL support routines
 */
int bltex(wbp w, int width, int height, int ch, char *s, word len);
int determinematerial(char *, C_integer, C_integer, C_integer, C_integer);
wtp lookup_texture_byname(wbp w, char *name, int len, int type, int curtex);
int texture(int width, int height, GLubyte *tex, int texmode);
int texture_24img(wbp w, struct imgdata im);
int textureimg(wbp w, int width, int height,
		struct palentry *e, unsigned char *s, word len);
int init_3dcontext(wcp wc);

FILE *wopengl(char *name, struct b_list *lp, dptr attr, int n, int *err_index)
{
   FILE *f;
   wbp  w;
   wsp  ws;
   wcp  wc;
   int  query;
   int major, minor;

   /* create an opengl window */
#ifdef XWindows
   int  L[] = {GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 16, None};

  /* create an opengl window */
   wdp wd = alc_display(NULL);
   if (!glXQueryExtension(wd->display, &query, &query)) {
      printf("X server has no OpenGL GLX extension\n");
      return NULL;
      }
   wd->vis = glXChooseVisual(wd->display, wd->screen, L);
   if (wd->vis == NULL) {
      printf("glXChooseVisual: visual failed\n");
      return NULL;
      }
#endif					/* XWindows */
   f = wopen(name, lp, attr, n, err_index, 1);

   if (!f) return NULL;
   w = (wbp) f;
   ws = w->window;
   wc = w->context;

   if (init_3dcontext(wc) == Failed) return NULL;

   /* create an empty list for list of function calls */
   if ((ws->funclist.vword.bptr = (union block *)alclist(0, 40000)) == NULL)
      return NULL;
   ws->funclist.dword = D_List;

   /* initialize opengl state*/
   init_opengl(w);

   return f;
}

void init_opengl(wbp  w)
{
   GLfloat ambient_model[] = {0.2, 0.2, 0.2, 1.0};
   wsp ws;
   wcp wc;

   ws= w->window;
   wc= w->context;

   /* set up the appropriate opengl states */
   glViewport(0, 0, (GLsizei)ws->width, (GLsizei)ws->height);
   glClearColor(RED(wc->bg)/(GLfloat)255, GREEN(wc->bg)/(GLfloat)255,
		BLUE(wc->bg)/(GLfloat)255, 0.0);

   glShadeModel(GL_SMOOTH); /* JAG */
   /*glPolygonMode(GL_FRONT, GL_FILL);*/
   glGenTextures(16, wc->texName);
   glEnable(GL_DEPTH_TEST);
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_GEN_S);
   glEnable(GL_TEXTURE_GEN_T);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glEnable(GL_NORMALIZE);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	     0.125 * ws->height / ws->width, 0.25, 50000.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}

int init_3dcontext(wcp wc)
{
  /* set defaults for attributes */
   wc->eyeupx = wc->eyeupz = 0.0;
   wc->eyeupy = 1.0;
   wc->dim = 3;
   wc->slices = 15;
   wc->rings = 10;
   wc->selectionenabled = 0;
   wc->selectionrendermode=0;
   wc->selectionnamelistsize=256;
   wc->selectionnamecount=0;
   wc->selectionnamelist = malloc(wc->selectionnamelistsize*sizeof(char*));
   if (wc->selectionnamelist == NULL) return Failed;
   wc->app_use_selection3D = 0;

   wc->eyeposx = wc->eyeposy =  wc->eyeposz = wc->eyedirx = wc->eyediry = 0.0;
   wc->eyedirz = -100.0;
   wc->autogen = 1;
   wc->normmode = 1;
   wc->normals = NULL;
   wc->texmode = wc->numtexcoords = 0;
   wc->texName = malloc(16 * sizeof(GLuint));
   if (wc->texName == NULL) return Failed;
   wc->nalced = 16;
   wc->maxstex=16;

   wc->stex = (struct _savetexture *) malloc(16*sizeof(struct _savetexture));
   if (wc->stex == NULL) return Failed;

   wc->texcoords = malloc(256 * sizeof (double));
   if (wc->texcoords == NULL) return Failed;
   wc->ntexcoordsalced = 256;
   wc->ntextures = 0;
   wc->curtexture = -1;
   wc->buffermode = IMMEDIATE3D;
   wc->meshmode = GL_POLYGON;
   return Succeeded;
}


/*
* release_3d_resources - free all resources used for 3D graphics
*/
int release_3d_resources(wbp w)
{
   int i;
   wcp wc = w->context;
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */

   for (i=0; i<wc->ntextures; i++) {
      free(wc->stex[i].tex);
      wc->stex[i].w=0;
   }
   free(wc->stex);
   wc->stex = NULL;
   i = wc->selectionnamecount;
   while (i){
      free(wc->selectionnamelist[--i]);
   }
   free(wc->selectionnamelist);
   free(wc->texName);
   free(wc->texcoords);

#ifdef XWindows
   glXDestroyContext( wd->display, wc->ctx);
#endif					/* XWindows */
}

/*
 * check if we have enough textures names (and records)
 * try to allocate if we need more
 */
int make_enough_texture_space(wcp wc)
{
   if (wc->ntextures >= wc->nalced) {
      wc->nalced *= 2;
      wc->texName = realloc(wc->texName, wc->nalced * sizeof(GLuint));
      if (wc->texName==NULL) return Failed;
      /*
      wc->maxstex *= 2;
      printf(" realloc STEX STEX STEX !\n ");
      wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
      if (wc->stex==NULL) return Failed;
      printf(" realloc STEX DONEEEEEEEEEEEEEEEEEEEEEEEEEE !\n ");
      */
      glGenTextures(wc->nalced / 2, wc->texName + wc->nalced / 2);
   }

   return Succeeded;
}


/* calculates the surface normal "n" given three vertices on the surface */
void calcNormal( double* v0, double* v1, double *v2, double* n )
{
    double a, b, c;
    double d, e, f;
    double l;

    a = v1[0] - v0[0];
    b = v1[1] - v0[1];
    c = v1[2] - v0[2];

    d = v2[0] - v0[0];
    e = v2[1] - v0[1];
    f = v2[2] - v0[2];

    n[0] = b * f - c * e;
    n[1] = c * d - a * f;
    n[2] = a * e - b * d;

    /* no need for normalization for now. OpenGL do it for us */
    /*l = (GLfloat)sqrt((n[0] * n[0]) + (n[1] * n[1]) + (n[2] * n[2]));

    n[0] = n[0] / l;
    n[1] = n[1] / l;
    n[2] = n[2] / l;
    */
}



/*
 * code for primitives -- polygon, lines, points, segments, filled polygons,
 * tori, spheres, cubes, cylinders, and disks.
 */

/*
 * drawpoly() - draws polygons, lines, points, segments, and filled polygons
 */
int drawpoly(wbp w, double* v, int num, int type, int dim)
{
   int i, j;
   double n[3] = {0.0, 0.0, 1.0};
   wcp wc = w->context;

   makecurrent(w);
   /* must reset the current normal vector */
   glNormal3dv(n);

   /* each vertex has an x-coordinate and a y-coordinate */
   if (dim == 2){

      /* no texturing */
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i=i+2)
            glVertex2d(v[i], v[i+1]);
         glEnd();
        }
      else {
         /* opengl will generate texture coordinates */
         if (wc->autogen) {
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+2)
               glVertex2d(v[i], v[i+1]);
            glEnd();
           }
         else {
            /*
             * There must be at least the same number of texture coordinate
             * pairs as there are vertices. If not, fail.
             */
            if (num/2 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i = i+2) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex2d(v[i], v[i+1]);
               j += 2;
             }
            glEnd();
           }
        }
     }

   /* each vertex is of the form (x, y, z) */
   if (dim == 3){
      if (!wc->texmode) {
         glBegin(type);
	 if(wc->normmode==1)
	    for (i = 0; i < num; i = i+3){
	       if (i%9==0 && i+9<num){
		  calcNormal(&v[i], &v[i+3], &v[i+6], n);
		  glNormal3dv(n);
	       }
	       glVertex3d(v[i], v[i+1], v[i+2]);
	       }
	 else if(wc->normmode==2){
	    if (num > wc->numnormals) return Failed;
	    for (i = 0; i < num; i = i+3){
	       glNormal3dv(&(wc->normals[i]));
	       glVertex3dv(&v[i]);
	       }
	    }
	 else 
	    for (i = 0; i < num; i = i+3)
	       glVertex3dv(&v[i]);
         glEnd();
       }
      else {

	 /* opengl should generate the texture coordinate */
         if (wc->autogen){

            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);

	    glBegin(type);
	    if(wc->normmode==1)
	       for (i = 0; i < num; i = i+3){
		  if (i%9==0 && i+9<num){
		     calcNormal(&v[i], &v[i+3], &v[i+6], n);
		     glNormal3dv(n);
		     }
		  glVertex3d(v[i], v[i+1], v[i+2]);
		  }
	    else if(wc->normmode==2){
	       if (num > wc->numnormals) return Failed;
	       for (i = 0; i < num; i = i+3){
		  glNormal3dv(&(wc->normals[i]));
		  glVertex3dv(&v[i]);
		  }
	       }
	    else 
	       for (i = 0; i < num; i = i+3)
		  glVertex3dv(&v[i]);
	    glEnd();
           }
         else {
            /*
	     * If there are not the same number of texture coordinate pairs
	     * as there are vertices, fail.
	     */
            if (num/3 > wc->numtexcoords/2)
              return Failed;
	    j = 0;
	    
	    if(wc->normmode==1){
	       glBegin(type);
	       for (i = 0; i < num; i = i+3){
		  if (i%9==0 && i+9<num){
		     calcNormal(&v[i], &v[i+3], &v[i+6], n);
		     glNormal3dv(n);
		     }
		  glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
		  j = j + 2;
		  glVertex3d(v[i], v[i+1], v[i+2]);
		  }
	       glEnd();
	       }
	    else if(wc->normmode==2){
	       if (num > wc->numnormals) return Failed;
	       /*glEnableClientState(GL_VERTEX_ARRAY);
	       glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	       glEnableClientState(GL_NORMAL_ARRAY);
	       glVertexPointer(3, GL_DOUBLE, 0, v);
	       glNormalPointer(GL_DOUBLE, 0, wc->normals);
	       glTexCoordPointer(2, GL_DOUBLE, 0, wc->texcoords);
	       glDrawArrays(type, 0, num);
	       glDisableClientState(GL_VERTEX_ARRAY);
	       glDisableClientState(GL_TEXTURE_COORD_ARRAY);
	       glDisableClientState(GL_NORMAL_ARRAY);
	       */
	       
	       for (i = 0; i < num; i = i+3){
#ifdef Arrays		  
		  glNormal3dv(&(wc->normals[i]));
#endif					/* Arrays */
		  glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
		  j = j + 2;
		  glVertex3dv(&v[i]);
		  }
		  
	       }
	    else {
	       for (i = 0; i < num; i = i+3){
		  glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
		  j = j + 2;
		  glVertex3dv(&v[i]);
		  }
	       glEnd();
	       }
         }
      }
   }
   /* each vertex is of the form (x, y, z, w) */
   if (dim == 4){
      if (!wc->texmode){
         glBegin(type);
         for (i = 0; i < num; i=i+4)
            glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
         glEnd();
        }
      else {
         /* have opengl generate texture coordinates */
         if (wc->autogen){
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+4)
              glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
            glEnd();
           }
	 else {
	    /*
	     * fail if the number of vertices is more than
	     * the number of texture coordinate pairs
	     */
            if (num/4 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+4) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
               j = j + 2;
              }
            glEnd();
           }
         }
       }
   return Succeeded;
}


/* helper function to draw a torus */
void torus(double radius1, double radius2, double x,double y, double z, int slices, int rings, int gen)
{
   int i, j;
   GLfloat theta, phi, theta1;
   GLfloat cosTheta, sinTheta;
   GLfloat cosTheta1, sinTheta1;
   GLfloat ringDelta, sliceDelta;

   /* generate texture coordinates if needed */
   if (gen == 1){
      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      }

   /* push matrix to preform the needed translation */
   glPushMatrix();
   glTranslatef(x, y, z);

#ifndef M_PI
#define M_PI        3.14159265358979323846264338327950288419716939937511
#endif					/* M_PI */

   /* rotate to make the torus look nicer */
   glRotatef(130.0, 1.0, 0.0, 0.0);
   ringDelta = 2.0 * M_PI / rings;
   sliceDelta = 2.0 * M_PI / slices;
   theta = 0.0;
   cosTheta = 1.0;
   sinTheta = 0.0;

   /* draw the torus */
   for (i = rings - 1; i >= 0; i--) {
      theta1 = theta + ringDelta;
      cosTheta1 = cos(theta1);
      sinTheta1 = sin(theta1);
      glBegin(GL_QUAD_STRIP);
      phi = 0.0;
      for (j = slices; j >= 0; j--) {
         GLfloat cosPhi, sinPhi, dist;
         phi += sliceDelta;
         cosPhi = cos(phi);
         sinPhi = sin(phi);
         dist = radius2 + radius1 * cosPhi;
         glNormal3f(cosTheta1 * cosPhi, -sinTheta1 * cosPhi, sinPhi);
         glVertex3f(cosTheta1 * dist, -sinTheta1 * dist, radius1 * sinPhi);
         glNormal3f(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
         glVertex3f(cosTheta * dist, -sinTheta * dist,  radius1 * sinPhi);
         }
      glEnd();
      theta = theta1;
      cosTheta = cosTheta1;
      sinTheta = sinTheta1;
     }
   glPopMatrix();
   glFlush();
}

/* draw a cube */
void cube(double length, double x, double y, double z, int gen)
{
   static GLfloat n[6][3] = {
      {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0},{1.0, 0.0, 0.0},
      {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0},{0.0, 0.0, -1.0}
      };

   static GLint faces[6][4] = {
      {0, 1, 2, 3}, {3, 2, 6, 7}, {7, 6, 5, 4},
      {4, 5, 1, 0}, {5, 6, 2, 1}, {7, 4, 0, 3}
      };

   GLfloat v[8][3], len_div_2 = length / 2;
   GLint i;

   glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &i);
   glPushMatrix();
   glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &i);

   glTranslatef(x, y, z);

   v[0][0] = v[1][0] = v[2][0] = v[3][0] = -len_div_2;
   v[4][0] = v[5][0] = v[6][0] = v[7][0] = len_div_2;
   v[0][1] = v[1][1] = v[4][1] = v[5][1] = -len_div_2;
   v[2][1] = v[3][1] = v[6][1] = v[7][1] = len_div_2;
   v[0][2] = v[3][2] = v[4][2] = v[7][2] = -len_div_2;
   v[1][2] = v[2][2] = v[5][2] = v[6][2] = len_div_2;

   /* set default coordinates if needed */

   if (gen == 1) {
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      for (i = 5; i >= 0; i--) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glTexCoord2f(0.0, 0.0);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glTexCoord2f(0.0, 1.0);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glTexCoord2f(1.0, 1.0);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glTexCoord2f(1.0, 0.0);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   else {
      for (i = 5; i >= 0; i--) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      }
   glPopMatrix();
}

/*
 * draw a sphere. This routine makes use of the glu library
 */
void sphere(double radius, double x, double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;
   glPushMatrix();
   glTranslatef(x, y, z);
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* use the glu texture coordinates if texcoord ="auto" */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }
   gluSphere(qobj, radius, slices, rings);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}


/*
 * draw a cylinder. makes use of the glu library.
 */
void cylinder(double radius1, double radius2, double height,
              double x,  double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;

   /*
    * translate to the specified x,y, and z
    */
   glPushMatrix();
   glTranslatef(x, y, z);
   /*
    * rotate so cylinder points "up" by default
    */
   glRotated(270.0, 1.0, 0.0, 0.0);
   qobj = gluNewQuadric();

   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* if needed generate texture coordinates */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
     }
   /* draw the cylinder */
   gluCylinder(qobj, radius1, radius2, height, slices, rings);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
     }
   glPopMatrix();
}

/*
 * draw a disk. angle2 < 360 degrees specifies a partial disk
 */
void disk(double radius1, double radius2, double angle1, double angle2,
          double x, double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;

   /* translate to the given x, y, z */
   glPushMatrix();
   glTranslatef(x, y, z);

   /* create the glu quadric */
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* generate texture coordinate if needed. */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }

   /* draw a disk */
   if (angle2 < 360.0)
      gluPartialDisk(qobj, radius1, radius2, slices, rings, angle1, angle2);
   else
      gluDisk(qobj, radius1, radius2, 15, 5);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}

/* other helper functions */

/*
 * pop a matrix from either the projection or the modelview matrix stack
 */
int popmatrix()
{
   int params1, params2;

   /* determine what is the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. return failed if the
       * matrix stack is one
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 > 1)
         glPopMatrix();
      else
	 return Failed;
      }

   else {
      /*
       * We are using the Modelview stack (what about texture stack?).
       * check to see if there is more than one
       * matrix on the stack. if not return Failed
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
	 if (params2 > 1)
	    glPopMatrix();
    	 else {
	    return Failed;
            }
      }
   return Succeeded;
}


/* push a matrix onto the current stack -- that is
   either the modelview of projection matrix stack */
int pushmatrix()
{
   int params1, params2;

   /* determine the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. If there is already 2
       * matrices on the stack return Failed
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 < 2) {
         glPushMatrix();
         }
      else
	 return Failed;
      }

   else {
      /* must be the Modelview matrix stack
       * if the stack depth is greater than 32, fail
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
      if (params2 < 32)
	 glPushMatrix();
      else
	 return Failed;
      }
   return Succeeded;
}

/*
 * push matrix and return a descriptor for a corresponding record
 */
int pushmatrix_rd(wbp w, dptr f)
{
   static dptr constr;
   int nfields, draw_code;
   tended struct b_record *rp;

   if (!constr && !(constr = rec_structor3d("gl_pushmatrix")))
      syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   makecurrent(w);

   /* push a copy of the top matrix, if possible */
   if (pushmatrix() == 0)
      return 151;

   /*
    * create a record of the graphical object
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return -1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("PushMatrix", 10 ,&(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "PushMatrix");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   c_put(&(w->window->funclist), f);
   return 0;
}

int compare_GLuint (const void * xx, const void * yy)
{
   GLuint *x = (GLuint *) xx;
   GLuint *y = (GLuint *) yy;
   if (*x > *y)
      return 1;
   else if (*x < *y)
      return -1;
   else
      return 0;
}

GLfloat deflt_ambient[4] = {0.2, 0.2, 0.2, 1.0};
GLfloat deflt_diffuse[4] = {0.8, 0.8, 0.8, 1.0};
GLfloat deflt_emission[4] = {0.0, 0.0, 0.0, 1.0};
GLfloat deflt_specular[4] = {0.0, 0.0, 0.0, 1.0};

/*
 * Functions that implement redrawing of windows.
 */

/*
 * redraws a opengl window by traversing the specifed list
 */
int redraw3D(wbp w)
{
   wcp wc = w->context;
   wsp ws = w->window;

   makecurrent(w);

   /*
    * reset the defaults for those objects that used them
    */
   glClear(GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT);

   setlinewidth(w, 1);
   glLineWidth(1.0);
   wc->dim = 3;

  /*
   *  render in GL_RENDER mode otherwise GL_SELECT
   */
   if (!wc->selectionrendermode) {      /* GL_RENDER mode  */

    /* restore the viewing volume to the default  */
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);

      glMatrixMode(GL_MODELVIEW);
      glPushMatrix();
      glLoadIdentity();
      gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
		wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);

      glMaterialfv(GL_FRONT, GL_AMBIENT, deflt_ambient);
      glMaterialfv(GL_FRONT, GL_DIFFUSE, deflt_diffuse);
      glMaterialfv(GL_FRONT, GL_SPECULAR, deflt_specular);
      glMaterialfv(GL_FRONT, GL_EMISSION, deflt_emission);
      glMaterialf(GL_FRONT, GL_SHININESS, 50.0);

      if (!wc->autogen) {
	 glEnable(GL_TEXTURE_GEN_S);
	 glEnable(GL_TEXTURE_GEN_T);
	 wc->autogen = 1;
	 }
/*
      if (wc->texmode) {
	 glDisable(GL_TEXTURE_2D);
	 wc->texmode = 0;
	 }
*/
      if (w->window->funclist.vword.bptr != NULL) {
	 if (traversefunctionlist(w) == Failed)
	    return Failed;
	 }

      glPopMatrix();
      glXSwapBuffers(w->window->display->display, w->window->win);
      }
   else {	/* GL_SELECT mode  */
      GLint viewport[4];
      GLuint        selectionbuf[256];        /* selection buffer */
      GLuint        selectionhits=0;          /* number of hits   */
      GLuint *bufp = selectionbuf;
      unsigned int j, i = 0;


      /*  change the view volume  so that it is only restricted
       *  to a small region under the mouse cursor
       */
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();

      glGetIntegerv(GL_VIEWPORT, viewport);
      gluPickMatrix((GLdouble)ws->pointerx,
                   (GLdouble)(viewport[3]-ws->pointery),
                    3.0, 3.0,    /*  picking region width and height  */
                    viewport);

      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);

     glMatrixMode(GL_MODELVIEW);
     glPushMatrix();
     glLoadIdentity();
     gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	       wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);

      /* switch to GL_SELECT render mode  */

      glSelectBuffer(256, selectionbuf);
      glRenderMode(GL_SELECT);
      glInitNames();

      if (w->window->funclist.vword.bptr != NULL) {  /* render the scene in GL_SELECT render mode */
         if (traversefunctionlist(w) == Failed)
             return Failed;
      }

      /* switch back to GL_RENDER render mode and save the hits  */
      /*glFlush(); */
      selectionhits = glRenderMode(GL_RENDER);

      if (selectionhits){
         GLuint name, numnames, z1, z2, z_buf[128];
         tended struct b_list *namelist;
         tended struct descrip selectednameslist;
         GLuint savedhits=0;
         int newnameadded=0;

         if ((namelist = alclist(0, MinListSlots)) == NULL)
	    return Failed;
         selectednameslist.dword = D_List;
         selectednameslist.vword.bptr = (union block*) namelist;

	 /*
	  * first pass over the selection buffer to collect and sort z values
	  */
         bufp = selectionbuf;
         for(j = 0; j < selectionhits; j++){
       	    numnames = *bufp++;
 	    z_buf[j] = *bufp++;
	    bufp++;           /* skip z2 */
	    bufp+=numnames;   /* skip names */
            }

	 qsort(z_buf,selectionhits, sizeof(GLuint), compare_GLuint);

         /* second pass : get the data  */
         savedhits=0;
         while (savedhits<selectionhits){
            bufp = selectionbuf;
            for(j = 0; j < selectionhits; j++){
	       numnames = *bufp++;
	       z1 = *bufp++;
	       bufp++; /* skip z2 */

	       if (z1 == 1 || z1>z_buf[savedhits]) {
		  bufp+=numnames;   /* skip names */
		  continue;
		  }
	       else {
		  tended char *tmpname;
		  tended struct descrip the_newselectedname;
		  int numnam=numnames, memsize=0;
		  GLuint *bufp2 = bufp;
		  /*
		   * z is 2 locations back. set it to 1 so that
		   * it will be skipped next time
		   */
		  *(bufp-2)=1;
		  savedhits++;
		  while (numnam--) {
		     int i = *bufp2++;
		     if ((0 <= i) && (i < wc->selectionnamecount))
			memsize += strlen(wc->selectionnamelist[i])+1;
		     }

	          Protect(tmpname = alcstr(NULL, memsize), return Error);
	          tmpname[0] = '\0';

		  while (numnames) {
		     name = *bufp++;
		     --numnames;
		     if ((0 <= name) && (name < wc->selectionnamecount)) {
			strcat(tmpname, wc->selectionnamelist[name]);
			if (numnames)strcat(tmpname, "-");
			}
                     } /* while */

                  if ( strlen(tmpname) > 0 ){
		     newnameadded=1;
                     MakeStr(tmpname, strlen(tmpname), &the_newselectedname);
   	             c_put(&selectednameslist, &the_newselectedname);
   	             }
   	          }/* else*/
               } /*  for j  */
            } /* savedhits */

           if (newnameadded)
              c_put(&(ws->listp), &selectednameslist);     /*stick the new list of selected names to the pending event queue  */
         } /* selection hits  */
      glPopMatrix();
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);
      glMatrixMode(GL_MODELVIEW);
   }
   return Succeeded;
}

/*
 * traverse a list and produce the element given by position
 */
int c_traverse(struct b_list *hp, struct descrip * res, int position)
{
   register word i;
   register struct b_lelem *bp;
   int j, used;

   /*
    * Fail if the list is not big enough.
    */
   if (hp->size < position)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < position; j++){
      if (used <= 1){
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 if (i++ >= bp->nslots) i = 0;
	 used--;
         }
      }
   *res = bp->lslots[i];
   return 1;
}

/*
 * traverse the given list and write its contents from subscript m through n,
 * which must be reals, to a C array of doubles.  m and n are 1-based
 * subscripts. Replaces a loop of calls to c_traverse().
 */
int c_realarray(struct b_list *hp, int m, int n, double *a)
{
   register word i;
   tended struct b_lelem *bp;
   tended struct descrip d;
   int j, used;

   /*
    * Fail if the list is not big enough (caller should check this first)
    */
   if (hp->size < n)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < n; j++){
      if (j >= (m-1)) {
	 d = bp->lslots[i];
         if (!cnv:real(d, d)) return 0;
	 bp->lslots[i] = d;
	 a[j-(m-1)] = BlkD(d, Real)->realval;
	 }
      if (used <= 1){
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 if (i++ >= bp->nslots) i = 0;
	 used--;
         }
      }
   return 1;
}

#define	REDRAW_CUBE 16
#define	REDRAW_CYLINDER 32
#define	REDRAW_DISK 48
#define	REDRAW_LINE 64
#define	REDRAW_POINT 80
#define	REDRAW_POLYGON 96
#define	REDRAW_SEGMENT 112
#define	REDRAW_SPHERE 128
#define	REDRAW_TORUS 144
#define	REDRAW_FG 160
#define	REDRAW_FILLPOLYGON 176
#define	REDRAW_IDENTITY 192
#define	REDRAW_MATRIXMODE 208
#define	REDRAW_POPMATRIX 224
#define	REDRAW_PUSHMATRIX 240
#define	REDRAW_ROTATE 256
#define	REDRAW_SCALE 272
#define	REDRAW_TEXTURE 288
#define	REDRAW_TEXCOORD 304
#define	REDRAW_TRANSLATE 320
#define	REDRAW_DIM 336
#define	REDRAW_LINEWIDTH 352
#define	REDRAW_TEXMODE 368
#define REDRAW_FONT3D 384
#define REDRAW_DRAWSTRING3D 400
#define REDRAW_MARK 416
#define REDRAW_ENDMARK 432
#define REDRAW_MESHMODE 448
#define REDRAW_PICK 464
#define REDRAW_MULTMATRIX 480
#define REDRAW_NORMALS 496
#define REDRAW_NORMOD 512

/*
 * Map 3D redrawing names to which switch case to use, and how many
 * real number arguments to convert.
 */
stringint redraw3Dnames[] = {
   { 0,			32 },		/* number of entries */
   { "DrawCube",	REDRAW_CUBE | 4 },
   { "DrawCylinder",	REDRAW_CYLINDER | 6},
   { "DrawDisk",	REDRAW_DISK | 7 },
   { "DrawLine",	REDRAW_LINE },
   { "DrawPoint",	REDRAW_POINT },
   { "DrawPolygon",	REDRAW_POLYGON },
   { "DrawSegment",	REDRAW_SEGMENT },
   { "DrawSphere",	REDRAW_SPHERE | 4 },
   { "DrawString3d",    REDRAW_DRAWSTRING3D | 3},
   { "DrawTorus",	REDRAW_TORUS | 5},
   { "EndMark",         REDRAW_ENDMARK},
   { "Fg",		REDRAW_FG},
   { "FillPolygon",	REDRAW_FILLPOLYGON },
   { "Font3d",          REDRAW_FONT3D },
   { "Identity",	REDRAW_IDENTITY },
   { "Mark",            REDRAW_MARK},
   { "MatrixMode",	REDRAW_MATRIXMODE },
   { "MeshMode",        REDRAW_MESHMODE },
   { "MultMatrix",	REDRAW_MULTMATRIX },
   { "Normals",		REDRAW_NORMALS },
   { "Pick"	,	REDRAW_PICK},
   { "PopMatrix",	REDRAW_POPMATRIX },
   { "PushMatrix",	REDRAW_PUSHMATRIX },
   { "Rotate",		REDRAW_ROTATE | 4 },
   { "Scale",		REDRAW_SCALE | 3 },
   { "Texcoord",	REDRAW_TEXCOORD },
   { "Texture",		REDRAW_TEXTURE },
   { "Translate",	REDRAW_TRANSLATE | 3 },
   { "dim",		REDRAW_DIM },
   { "linewidth",	REDRAW_LINEWIDTH },
   { "normode",		REDRAW_NORMOD },
   { "texmode",		REDRAW_TEXMODE },
   };

/*
 * Traverse the list of functions and redraw the scene.
 */
int traversefunctionlist(wbp w)
{
   wcp wc = w->context;
   wsp ws = w->window;
   double x, y, z, r1, r2, h, a1, a2, *v, v2[256];
   C_integer num, dim;
   C_integer r, g, b, a;
   int i, j, tmp, vsize=256;
   tended struct descrip flist, fname, var1, var2, d;
   tended struct b_list *funclist;
   tended char *temp;
   tended struct b_record *rp;
   tended char *s;
   tended struct b_list *hp;
   tended struct b_lelem *bp, *bp1;
   int used, used1, count=0;
   word k,k1;
   int elements;

   hp = (struct b_list *) ws->funclist.vword.bptr;
   elements = hp->size;

   if (elements <= 0) return Succeeded;
   bp = (struct b_lelem *) hp->listhead;

   if (bp->nused<=0) {
        bp = (struct b_lelem *) bp->listnext;
        hp->listhead = (union block *) bp;
        bp->listprev = (union block *) hp;
   }
   k = bp->first;
   used =bp->nused;

   /*
    * The ith element of the list is a list with information
    * about the function call made on the window.
    */
   v = v2;
   for (i=0; i< elements; i++) {

      if (count>2) { /* skip forward as much as possible */
	 int asmuchaspossible = count-1;
	 if (used <= asmuchaspossible) asmuchaspossible = used-1;
	 if (asmuchaspossible >1) {
	    used -= asmuchaspossible;
	    k = (k+asmuchaspossible) % (bp->nslots);
	    count -= asmuchaspossible;
	    i += asmuchaspossible;
	    }
	 }
      flist = bp->lslots[k];
      k++;
      used--;
      if (k>=bp->nslots) k=0;

      if (used<=0) {
  	 bp = (struct b_lelem *) bp->listnext;
	 used = bp->nused;
         k = bp->first;
         }

      if (count) {
         count--;
         continue;
	 }

      if (v != v2) free(v);
      v = v2;
      vsize = 256;

      if (is:record(flist)) {
	 rp = BlkD(flist, Record);
	 fname = rp->fields[0];

         tmp = IntVal(rp->fields[1]);
	 if (tmp == -1) {
	    return Failed; /* probably should runerr on this */
	    }
	 for (j=0; j < (tmp&15); j++) {
	    var1 = rp->fields[j+2];
	    if (!cnv:C_double(var1, v[j])) goto free_v_and_fail;
	    }

	 switch(tmp & ~0xf) {
	 case REDRAW_TORUS:
	    torus(v[3], v[4], v[0], v[1], v[2],
		IntVal(BlkLoc(flist)->Record.fields[7]),    /*  slices  */
		IntVal(BlkLoc(flist)->Record.fields[8]),    /*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CUBE:
	    cube(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_SPHERE:
	    sphere(v[3], v[0], v[1], v[2],
		IntVal(BlkLoc(flist)->Record.fields[6]),    /*  slices  */
		IntVal(BlkLoc(flist)->Record.fields[7]),    /*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CYLINDER:
	    cylinder(v[4], v[5], v[3], v[0], v[1], v[2],
		IntVal(BlkLoc(flist)->Record.fields[8]),    /*  slices  */
		IntVal(BlkLoc(flist)->Record.fields[9]),    /*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_DISK:
	    disk(v[3], v[4], v[5], v[6], v[0], v[1], v[2],
		IntVal(BlkLoc(flist)->Record.fields[9]),    /*  slices  */
		IntVal(BlkLoc(flist)->Record.fields[10]),   /*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_ROTATE:
	    glRotated(v[3], v[0], v[1], v[2]);
	    break;
	 case REDRAW_TRANSLATE:
	    glTranslated(v[0], v[1], v[2]);
	    break;
	 case REDRAW_SCALE:
	    glScaled(v[0], v[1], v[2]);
	    break;
	 case REDRAW_POPMATRIX:
	    if (popmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_PUSHMATRIX:
	    if (pushmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_IDENTITY:
	    glLoadIdentity();
	    break;
	 case REDRAW_MATRIXMODE:
	    if (!cnv:C_string(rp->fields[2], temp)) goto free_v_and_fail;
	    if (!strcmp("modelview", temp)) glMatrixMode(GL_MODELVIEW);
	    else if (!strcmp("projection", temp)) glMatrixMode(GL_PROJECTION);
	    break;
	 case REDRAW_TEXTURE:
	    /*
	     * lookup the name of the texture and bind it
             * the objects using glBindTexture()
	     */
	    if (!cnv:C_integer(rp->fields[2], num)) goto free_v_and_fail;
	    glBindTexture(GL_TEXTURE_2D, wc->texName[num]);
	    if (wc->texmode)
	       glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, wc->texmode);
	    break;
         case REDRAW_FONT3D:
#if HAVE_FTGL
	    curr_font = (wfont *) IntVal(rp->fields[2]);
#endif					/* HAVE_FTGL */
	    break;
         case REDRAW_DRAWSTRING3D:
#if HAVE_FTGL
	    if (!cnv:C_double(rp->fields[2], x)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], y)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], z)) goto free_v_and_fail;
	    if (!cnv:C_string(rp->fields[5], s)) goto free_v_and_fail;
	    drawstrng3d(w,x,y,z,s);
#endif					/* HAVE_FTGL */
            break;
         case REDRAW_MARK: {
	    struct descrip d = BlkLoc(flist)->Record.fields[3];
            if (is:integer(d) && IntVal(d)==1) {
	       count = IntVal(BlkLoc(flist)->Record.fields[4]);
               }
            else count=0;

	   if (!count && wc->selectionenabled && wc->selectionrendermode ){
	      GLuint int_code = IntVal(BlkLoc(flist)->Record.fields[5]);
              glPushName(int_code);
              }
	    }
	    break;
	 case REDRAW_ENDMARK:
	    if (wc->selectionenabled && wc->selectionrendermode)
		    glPopName();
	    break;
	 case REDRAW_MESHMODE:
            if (!cnv:C_integer(rp->fields[2], num)) goto free_v_and_fail;
            w->context->meshmode = num;
            break;
	 default:
	    fprintf(stderr,"invalid displaylist entry '%s'\n",
		    (is:string(fname) ? StrLoc(fname) : "(corrupted)"));
            goto free_v_and_fail;
	    }
	 continue;
	 }
      else if (is:list(flist)) {
	 funclist = (struct b_list*)flist.vword.bptr;
         if (funclist->size<=1) continue;
         bp1 = (struct b_lelem *) funclist->listhead;
         if (bp1->nused<=0) {
            bp1 = (struct b_lelem *) bp1->listnext;
            funclist->listhead = (union block *) bp1;
            bp1->listprev = (union block *) funclist;
         }
         k1 = bp1->first;
         fname = bp1->lslots[k1];

         if (k1++>=bp1->nslots) k1=0;
         used1 = bp1->nused-1;
         if (used1<=0) {
            bp1 = (struct b_lelem *) bp1->listnext;
	    k1 = bp1->first;
            funclist->listhead = (union block *) bp1;
            bp1->listprev = (union block *) funclist;
         }
	 if (! is:integer(bp1->lslots[k1])) { /* should check for large int! */
	    return Error;
	    }
         tmp = IntVal(bp1->lslots[k1]);

/* OK, at this point, k1 has been preset to refer to the int code */

	 if (funclist->size-1 > vsize) {
	    if (v == v2)
	       v = calloc(funclist->size, sizeof (double));
	    else {
	       v = realloc(v, funclist->size * sizeof (double));
	       }
	    vsize = funclist->size-1;
	    if (v == NULL) return Error;
	    }

         switch(tmp & ~0xf) {
         case REDRAW_FG:
	    /* Fg() or WAttrib("fg=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_string(d, temp))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, r))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, g))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, b))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
                if (k1++>=bp1->nslots) k1=0;
                used1--;
                }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, a))
	       return Failed;

	    if(!determinematerial(temp, r, g, b, a)) {
		/*
        		if(!determinematerial(funclist)) {
		*/
               free_v_and_fail:
	       if (v != v2) free(v);
	          return Failed;
	       }
	    break;
         case REDRAW_DIM:
	    /* WAttrib("dim=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
            }
            var1 = bp1->lslots[k1];

    	    if ((!cnv:C_integer(var1, dim))||(dim<1)||(dim>3))
	       goto free_v_and_fail;
            wc->dim = dim;
	    break;
         case REDRAW_LINEWIDTH:
	    /* WAttrib("linewidth=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	       setlinewidth(w, num);
               glLineWidth(num);
	    break;
         case REDRAW_PICK:
	    /* WAttrib("pick=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
	       }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

	    wc->selectionenabled = num;
	    break;
         case REDRAW_TEXMODE:
	    /* WAttrib("texmode=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

            /* texturing is on */
            if (num) {
               if (wc->texmode == 0)
	          glEnable(GL_TEXTURE_2D);

               wc->texmode = num;
               }
               /* texturing is off */
            else {
               if (wc->texmode != 0)
                  glDisable(GL_TEXTURE_2D);
               wc->texmode = 0;
	       }
	    break;
         case REDRAW_TEXCOORD:      /* Texcoord() or WAttrib("texcoord=...") */
            /*
	     * first element tells us if opengl generates texture coordinates
	     */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

            if (num) {
               glEnable(GL_TEXTURE_GEN_S);
               glEnable(GL_TEXTURE_GEN_T);
               wc->autogen = 1;
               }

            /* there is a list of texture coordinates to use */
            else {
#ifdef Arrays
	       struct b_realarray *ap;
#endif					/* Arrays */
               glDisable(GL_TEXTURE_GEN_S);
               glDisable(GL_TEXTURE_GEN_T);
               wc->autogen = 0;

	       if (wc->ntexcoordsalced < funclist->size-3) {
	          printf("need to grow ntexcooords alced %d need %d\n",
		     wc->ntexcoordsalced, funclist->size-1);
	          goto free_v_and_fail;
	          }
#ifndef Arrays
               /* traverse the list and set the texture coordinates */
               for (j=0; j < (funclist->size)-3; j++){
#endif
                  if (used1 <= 1){
	             bp1 = (struct b_lelem *) bp1->listnext;
                     used1 = bp1->nused;
                     k1 = bp1->first;
                     }
                  else {
	             if (k1++ >= bp1->nslots) k1 = 0;
	             used1--;
                     }

                  if (used1>0) {
	             d = bp1->lslots[k1];
#ifdef Arrays
		     ap = (struct b_realarray *)BlkLoc(d);
		     if (ap->title!=T_Realarray){
			printf("NOT a real Array!!..\n");
			return Failed;
			}
		     wc->numtexcoords = (ap->blksize - sizeof(struct b_realarray) + sizeof(double))/sizeof(double);
		     wc->texcoords = ap->a;
#else					/* Arrays*/
		     if (!cnv:real(d, d)) return 0;
	             bp1->lslots[k1] = d;
	             wc->texcoords[j] = BlkD(d,Real)->realval;
#endif					/* Arrays*/
                     }
#ifndef Arrays
                  } /* for j=0 ... */

               wc->numtexcoords = funclist->size-3;
#endif					/* Arrays */
               }
	    break;
	    
         case REDRAW_NORMALS:     /* Normals() */
            /* there is a list of normal coordinates to use */
               if (used1 <= 1){
	          bp1 = (struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
	          if (k1++ >= bp1->nslots) k1 = 0;
	          used1--;
                  }

               if (used1>0) {
#ifdef Arrays
		  struct b_realarray *ap;
	          d = bp1->lslots[k1];
		  ap = (struct b_realarray *)BlkLoc(d);
		  if (ap->title!=T_Realarray){
		     printf("NOT a real Array!!..\n");
		     return Failed;
		     }
		  wc->numnormals = (ap->blksize - sizeof(struct b_realarray) + sizeof(double))/sizeof(double);
		  wc->normals = ap->a;
#endif					/* Arrays*/
                  }
	    break;
         case REDRAW_MULTMATRIX:      /* MultMatrix() */
            {
#ifdef Arrays
	       struct b_realarray *ap;
	       double *matvalues;
#else					/* Arrays */
	       double matvalues[16];
#endif					/* Arrays */
               int mi=0;
               /* check if we have a list of size 18.  18 = 2 reserved + 16 values */
#ifndef Arrays
               if ((funclist->size)!=18) goto free_v_and_fail;

               /* traverse the list and set matrix elements */
               for (j=0; j < (funclist->size)-2 /*16*/; j++){
#endif					/* Arrays */
                  if (used1 <= 1){
	             bp1 = (struct b_lelem *) bp1->listnext;
                     used1 = bp1->nused;
                     k1 = bp1->first;
                     }
                  else {
	             if (k1++ >= bp1->nslots) k1 = 0;
	             used1--;
                     }

                  if (used1>0) {
	             	 d = bp1->lslots[k1];
#ifdef Arrays
		     		 ap = (struct b_realarray *)BlkLoc(d);
		     		 if (ap->title!=T_Realarray){
					 	printf("NOT a real Array!!..\n");
					 	return Failed;
						}
		     		 matvalues = ap->a;
#else					/* Arrays*/
                     if (!cnv:real(d, d)) return 0;
	             	 bp1->lslots[k1] = d;
					 matvalues[mi++] = BlkD(d,Real)->realval;
#endif					/* Arrays */
                     } /*used1>0 */
#ifndef Arrays
                  } /* for j=0 ... */
#endif					/* Arrays */
#if HAVE_LIBGL
               glMultMatrixd((GLdouble *)matvalues);
#endif					/* HAVE_LIBGL */
               }
	    break;
         case REDRAW_POLYGON:      /* DrawPolygon() */
            /* element in position 1 is the dim attribute */
            for (j = 0; j < (funclist->size)-2; j++) {
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

               var2 = bp1->lslots[k1];
               if(!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	       }

	    /* call drawpoly with GL_LINE_LOOP to get a polygon */
	    drawpoly(w, v, (funclist->size)-2, w->context->meshmode, wc->dim);
	    break;
         case REDRAW_FILLPOLYGON:{      /* FillPolygon() */
	    double *vpoly;
#ifdef Arrays
	    struct b_realarray *ap;
#else					/* Arrays */
	    num= (funclist->size)-2;
	    for (j = 0; j < (funclist->size)-2; j++) {
#endif					/* Arrays */
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

               var2 = bp1->lslots[k1];
#ifdef Arrays
	       ap = (struct b_realarray *)BlkLoc(var2);
	       if (ap->title!=T_Realarray){
		  printf("NOT a real Array!!..\n");
		  return Failed;
	       }
	       vpoly=ap->a;
	       num=(ap->blksize - sizeof(struct b_realarray) + sizeof(double))/sizeof(double);
# else	/* Arrays */
	       if (!is:real(var2)) {
	          if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	          }
	       else
	          GetReal(&var2, v[j]);
               } /* for j=0 */
	       vpoly=v;
#endif	/* Arrays */
	    /* drawpoly with GL_POLYGON will give filled polygons */
            drawpoly(w, vpoly, num, w->context->meshmode, wc->dim);
	    break;
		}
         case REDRAW_SEGMENT:      /* DrawSegment() */
	    for (j = 0; j < (funclist->size)-1; j++) {
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
               }

               var2 = bp1->lslots[k1];
	       if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	       } /* for j=0 */
	    drawpoly(w, v, (funclist->size)-2, GL_LINES, wc->dim);
	    break;
         case REDRAW_LINE:       /* DrawLine() */
	    used1 = bp1->nused-2;
	    for (j = 0; j < (funclist->size-2); j++) {
               if (used1<=0) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

            var2 = bp1->lslots[k1];
	    if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	    }

	    drawpoly(w, v, (funclist->size)-2, GL_LINE_STRIP, wc->dim);
	    break;
         case REDRAW_POINT:       /* DrawPoint() */
	    for (j = 0; j < (funclist->size)-1; j++) {
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

            var2 = bp1->lslots[k1];
	    if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
            }
	    drawpoly(w, v, (funclist->size)-2, GL_POINTS, wc->dim);
	    break;
         default:
      	    fprintf(stderr,"invalid displaylist entry '%s'\n",
	       (is:string(fname) ? StrLoc(fname) : "(corrupted)"));
	       goto free_v_and_fail;
	 } /* switch tmp */
         } /* else if is:list  */
      else {
	 return Failed;
	 }
      }

   if (v!=v2) free(v);
   return Succeeded;
}

/*
 * traverse the given list and set material properties
 */
int determinematerial(temp, r, g, b, a)
char *temp;
C_integer r, g, b, a;
{
   struct descrip d;
   GLfloat color[4];

   /*
    * must convert from an integer between 0 and 65535
    * to a float between 0.0 and 0.0
    */
   color[0] = r/(GLfloat)65535;
   color[1] = g/(GLfloat)65535;
   color[2] = b/(GLfloat)65535;
   color[3] = a/(GLfloat)65535;  /* alpha value */

  /* set the material property */
   if (!strcmp(temp, "ambient"))
      glMaterialfv(GL_FRONT, GL_AMBIENT, color);
   else if (!strcmp(temp, "diffuse"))
      glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
   else if (!strcmp(temp, "specular"))
      glMaterialfv(GL_FRONT, GL_SPECULAR, color);
   else if (!strcmp(temp, "emission"))
      glMaterialfv(GL_FRONT, GL_EMISSION, color);
   else if(!strcmp(temp, "shininess"))
      glMateriali(GL_FRONT, GL_SHININESS, r);

   /*
    * if it is not a material property, change the
    * current foreground color to r, g, b
    */
   if (!strcmp(temp, "none")) {
      glColor4f(color[0], color[1], color[2], color[3]);
      }

   return Succeeded;
}

/* routines to return an attribute vale */

/* returns the current value of the specified light */
int getlight(int light, char* buf)
{
   GLfloat pos[4];
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];

   glGetLightfv(GL_LIGHT0 + light, GL_POSITION, pos);
   glGetLightfv(GL_LIGHT0 + light, GL_AMBIENT, amb);
   glGetLightfv(GL_LIGHT0 + light, GL_DIFFUSE, diff);
   glGetLightfv(GL_LIGHT0 + light, GL_SPECULAR, spec);

   sprintf(buf, "position %.2f,%.2f,%.2f; ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f",  pos[0], pos[1], pos[2], amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2]);
   return Succeeded;
}

/* returns the current material properties */
int getmaterials(char* buf)
{
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];
   GLfloat emis[4];
   GLfloat shine;

   /* query opengl for current values */
   glGetMaterialfv(GL_FRONT, GL_EMISSION, emis);
   glGetMaterialfv(GL_FRONT, GL_AMBIENT, amb);
   glGetMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
   glGetMaterialfv(GL_FRONT, GL_SPECULAR, spec);
   glGetMaterialfv(GL_FRONT, GL_SHININESS, &shine);

   sprintf(buf, "ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f; emission %.2f,%.2f,%.2f; shininess %.2f", amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2], emis[0], emis[1], emis[2], shine);
   return Succeeded;
}

int gettexture(wbp w, dptr dp)
{
   wcp wc= w->context;
   wtp wt = wc->textures;
   while (wt) {
      if (wt->texindex == wc->curtexture) {
	 *dp = wt->d;
	 return Succeeded;
	 }
      wt = wt->next;
      }
   return Failed;
}

void getatexcoord(double d, char *b)
{
   if ((double)(int)d == d) sprintf(b,"%d",(int)d);
   else sprintf(b,"%.3f",d);
}

/* get the user specified texture coordinates */
int gettexcoords(wbp w, char *buf)
{
   char *s = buf;
   int i;
   wcp wc = w->context;
   getatexcoord(wc->texcoords[0], s);
   s += strlen(s);
   for (i = 1; i < wc->numtexcoords; i++) {
      *s++ = ',';
      getatexcoord(wc->texcoords[i], s);
      s += strlen(s);
     }
   return Succeeded;
}

/* routines to set attribute values */

/* set the linewidth */
int setlinewidth3D(wbp w, LONG linewid)
{
   tended struct descrip f;
   struct descrip funcname, width, g;
   tended struct b_list *func;
   int draw_code;

   if (linewid < 0) return Error;
   makecurrent(w);
   setlinewidth(w, linewid);
   glLineWidth(linewid);

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block *) func;
   MakeStr("linewidth", 9, &funcname);
   c_put(&f, &funcname);

   draw_code = si_s2i(redraw3Dnames, "linewidth");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &g);
   c_put(&f, &g);

   MakeInt(linewid, &width);
   c_put(&f, &width);
   c_put(&(w->window->funclist), &f);

   return Succeeded;
}

/* given a string of semi-colon seperated material
 * properties (ambient, diffuse, specular, emission,
 * and shininess), parse the string and set material
 * properties
 */
int setmaterials(wbp w, char* s)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int k, j, i = 0, draw_code;
   long rd, gr, bl, al;
   GLfloat shine;
   GLfloat color[4];
   char sbuf1[MaxCvtLen];
   char sbuf2[MaxCvtLen];
   tended struct descrip f;
   struct descrip funcname, material, r, b, g, a, gg;
   tended struct b_list *func; /* tended added */

   makecurrent(w);
   while(s[i]) {
      j = 0;
      k = 0;

      /* create a list element for each material property */
      if ((func = alclist(0, 7)) == NULL)
         return Failed;
      f.dword = D_List;
      f.vword.bptr = (union block *) func;
      MakeStr("Fg", 2, &funcname);
      c_put(&f, &funcname);

      draw_code = si_s2i(redraw3Dnames, "Fg");
      if (draw_code == -1)
	return Failed;
      MakeInt(draw_code, &gg);
      c_put(&f, &gg);

     /*
      * parse the string to determine the material property and its value
      */
      while(isspace(s[i])) i++;
      while(s[i] && isalpha(s[i])) {
         sbuf1[k] = s[i];
         i++; k++;
	 }
      sbuf1[k] = '\0';

      /* ambient */
      if (!strcmp(sbuf1, "ambient")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
            sbuf2[j] = s[i];
            i++; j++;
	    }
         sbuf2[j] = '\0';
         /* determine the icon color */
         if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)== Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535; /* alpha value */

         /* set the property */
         glMaterialfv(GL_FRONT, GL_AMBIENT, color);
         MakeStr("ambient", 7, &material);
         c_put(&f, &material);
	   }

      /* diffuse */
      else if(!strcmp(sbuf1, "diffuse")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /* determine the appropriate icon color */
	 if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)==Failed)
            return Failed;

         /* convert values to floats between 0.0 and 1.0 */
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

         /* set the property */
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
	 MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
	 }

      /* specular */
      else if (!strcmp(sbuf1, "specular")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /*
	  * determine the icon color and convert to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the property */
         glMaterialfv(GL_FRONT, GL_SPECULAR, color);
         MakeStr("specular", 8, &material);
         c_put(&f, &material);
	 }

      /* shininess */
      else if(!strcmp(sbuf1, "shininess")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /* set the shininess */
	 shine = atof(sbuf2);
	 glMaterialf(GL_FRONT, GL_SHININESS, shine);
         MakeStr("shininess", 9, &material);
	 c_put(&f, &material);
	 rd = shine;
	 gr = 0;
	 bl = 0;
	 }
      /* emission */
      else if(!strcmp(sbuf1, "emission")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /*
	  * determine r, g, b and convert them to floats between 0.0 and 1.0
	  */
	 if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
	    return Failed;
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

	 /* set the emission color */
	 glMaterialfv(GL_FRONT, GL_EMISSION, color);
         MakeStr("emission", 8, &material);
	 c_put(&f, &material);
	 }

      /* otherwise set the current foreground color; treat as diffuse */
      else {
	 if(setfg(w, s) == Failed) return Failed;
         if(parsecolor(w, s, &rd, &gr, &bl, &al)==Failed)
            return Failed;
	 i = strlen(s);
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;
 	 glColor4f(color[0], color[1], color[2], color[3]);
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
         MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
         }

      /* put material property values on the list */
      MakeInt(rd, &r);
      c_put(&f, &r);
      MakeInt(gr, &g);
      c_put(&f, &g);
      MakeInt(bl, &b);
      c_put(&f, &b);
      MakeInt(al, &a);
      c_put(&f, &a);
      c_put(&(w->window->funclist), &f);

      /* fail if string is not in the correct format */
      if(s[i] != '\0' && s[i] != ';') return Failed;
      if (s[i])
         i++;
     }
   return Succeeded;
}


/*
 * set the lighting properties (position, ambient,
 * diffuse, specular, and "on" or "off")of a light
 */
int setlight(wbp w, char* s, int light)
{
   char* s2 = s;
   char s3[MaxCvtLen];
   GLboolean params;
   int i, j;
   GLfloat color[4];
   long rd, gr, bl, al;

   makecurrent(w);

   while(isspace(*s2)) s2++;

   /* turn on a light */
   if (!strncmp(s2, "on", 2)) {
      /* query opengl to see if it is already on */
      glGetBooleanv(light, &params);
      if (!params)
         glEnable(light);
      s2 = s2+2;
      if(*s2 != ',' && *s2 != '\0') return Failed;
      if(*s2 == ',') s2++;
      }
   /* turn off the light */
   if (!strncmp(s2, "off", 3)) {
      /* query opengl to make sure the light is not
          already off */
	 glGetBooleanv(light, &params);
	 if (params)
          glDisable(light);
       s2 = s2 + 3;
	 if(*s2 != ',' && *s2 != '\0') return Failed;
       if(*s2 == ',') s2++;
      }
   while(*s2 != '\0'){
      while(isspace(*s2)) s2++;

      /* set the ambient lighting values */
      if (!strncmp(s2, "ambient", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /*
	  * Determine the r, g, b values. Convert from an integer between
	  * 0 and 65535 to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, s3, &rd, &gr, &bl, &al) ==Failed)
	      return Failed;

         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the ambient light value */
         glLightfv(light, GL_AMBIENT, color);
         s2 = s2 + i;
	 if(*s2 != ';' && *s2 != '\0') return Failed;
	 if(*s2 != '\0') s2++;
         }

      /* set the diffuse lighting values */
      if (!strncmp(s2, "diffuse", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert the icon r, g, b values to floats
            between 0.0 and 1.0 */
         if(parsecolor(w, s3, &rd, &gr, &bl,&al) == Failed)
	      return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the diffuse value of the light */
         glLightfv(light, GL_DIFFUSE, color);
         s2 = s2 + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         }
      /* set the specular lighting values */
      if (!strncmp(s2, "specular", 8)) {
         s2 = s2 + 8;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert to appropriate values */
	 if (parsecolor(w, s3, &rd, &gr, &bl, &al) == Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;
         glLightfv(light, GL_SPECULAR, color);
         s2 = s2 + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         }
      /* set the positon of the light */
	if (!strncmp(s2, "position", 8)) {
         s2 = s2 + 8;
	   for (j = 0; j < 2; j++) {
	   while (isspace(*s2)) s2++;
           i = 0;
	   if (*s2 == '\0') return Failed;
	   while (s2[i] != '\0' && s2[i] != ',') {
              s3[i] = s2[i];
              i++;
              }
           s3[i] = '\0';
           color[j] = atof(s3);
           s2 = s2 + i;
	   if (*s2 != ',') return Failed;
           s2++;
           }
	 while (isspace(*s2)) s2++;
	 if (*s2 == '\0') return Failed;
	 while (s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         color[2] = atof(s3);
         color[3] = 0.0;
         s2 = s2  + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         glLightfv(light, GL_POSITION, color);
         }
      }

      /* the lighting on the scene has changed, we must redraw the window */
      redraw3D(w);
      return Succeeded;
}

/* set the dim attribute */
int setdim(wbp w, char* s)
{
   tended struct descrip f;
   struct descrip funcname, g;
   tended struct b_list *func; /* tended added */
   tended struct descrip d;
   int dim, draw_code;

   makecurrent(w);
   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("dim", 3, &funcname);
   c_put(&f, &funcname);

   draw_code = si_s2i(redraw3Dnames, "dim");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &g);
   c_put(&f, &g);

   dim = atoi(s);
   /* must be a value between 1 and 4 */
   if (dim < 1 || dim > 4)
      return Error;
   w->context->dim = dim;

   /* put the value of dim on the list of functions */
   MakeInt(dim, &d);
   c_put(&f, &d);
   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

void gettexmode(wbp w, char *abuf, dptr answer)
{
   wcp wc = w->context;
   switch (wc->texmode) {
   case GL_REPLACE: strcpy(abuf, "on"); break;
   case GL_BLEND: strcpy(abuf, "blend"); break;
   case GL_MODULATE: strcpy(abuf, "modulate"); break;
   case 0: strcpy(abuf, "off"); break;
   default: strcpy(abuf, "unknown texture mode"); break;
      }
   MakeStr(abuf, strlen(abuf), answer);
}

/* set the texture mode, either on or off */
int settexmode(wbp w, char* s)
{
   tended struct descrip f;
   struct descrip funcname, g;
   tended struct b_list *func;
   tended struct descrip mode;
   wcp wc = w->context;
   int oldtexmode = wc->texmode, draw_code;

   makecurrent(w);
    /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("texmode", 7, &funcname);
   c_put(&f, &funcname);

   draw_code = si_s2i(redraw3Dnames, "texmode");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &g);
   c_put(&f, &g);

   /*
    * turn textures on in replace, blend, or modulate (default mode = replace)
    */
   if (!strcmp("on", s) || !strcmp("replace", s)) {
      wc->texmode = GL_REPLACE;
      }
   else if (!strcmp("blend", s)) {
      wc->texmode = GL_BLEND;
      }
   else if (!strcmp("modulate", s)) {
      wc->texmode = GL_MODULATE;
      }
   /* turn texture off */
   else if (!strcmp("off", s)) {
      wc->texmode = 0;
     }
   /* not a valid texture mode so generate an error */
   else
      return Error;

   if ((oldtexmode == 0) && (wc->texmode != 0)) {
      glEnable(GL_TEXTURE_2D);
      }
   else if ((oldtexmode != 0) && (wc->texmode == 0)) {
      glDisable(GL_TEXTURE_2D);
      }

   MakeInt(wc->texmode, &mode);
   c_put(&f, &mode);
   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

/* set texture coordinates */
int settexcoords(wbp w, char* s)
{
   double r;
   char* s2 = s;
   char s3[MaxCvtLen];
   int j, i =0, draw_code;
   tended struct descrip f = nulldesc, val = nulldesc;
   struct descrip funcname, mode, g;
   tended struct b_list *func;
   makecurrent(w);

   /* create a list */
   if ((func = alclist(0, MinListSlots+2)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("Texcoord", 8, &funcname);
   c_put(&f, &funcname);

   draw_code = si_s2i(redraw3Dnames, "Texcoord");
   if (draw_code == -1)
      return Failed;
   MakeInt(draw_code, &g);
   c_put(&f, &g);

   while(isspace(*s2)) s2++;

   /*
    * check if we need to generate texture coordinates
    */
   if (!strcmp(s2, "auto")){
      w->context->autogen = 1;
      if (!glIsEnabled(GL_TEXTURE_GEN_S))
         glEnable(GL_TEXTURE_GEN_S);
      if (!glIsEnabled(GL_TEXTURE_GEN_T))
         glEnable(GL_TEXTURE_GEN_T);
      mode = onedesc;
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
      }

   /*
    * otherwise a string of texture coordinates should be given
    */
   else if(isdigit(*s2)) {
      mode = zerodesc;
      c_put(&f, &mode);
      j = w->context->numtexcoords = 0;
      w->context->autogen = 0;

      /* must turn off automatic texture generation */
      if (glIsEnabled(GL_TEXTURE_GEN_S))
         glDisable(GL_TEXTURE_GEN_S);
      if (glIsEnabled(GL_TEXTURE_GEN_T))
         glDisable(GL_TEXTURE_GEN_T);
      /* parse string */
      while(*s2 != '\0') {
         while(*s2 != ',' && *s2 != '\0' ) {
            s3[i] = *s2;
            i++; s2++;
           }
         s3[i]='\0';
        /* create a list element for the coordinate */
	 if (j >= w->context->ntexcoordsalced) {
	    w->context->texcoords = realloc(w->context->texcoords,
					    (w->context->ntexcoordsalced + 1+
					     strlen(s)/2) * sizeof(double));
	    if (w->context->texcoords == NULL)
	       return Failed;
	    w->context->ntexcoordsalced += (strlen(s)/2);
	    }
         w->context->texcoords[j] = r = atof(s3);
         BlkLoc(val) = (union block *)alcreal(r);
         val.dword = D_Real;
         c_put(&f, &val);
         j++;
	 if (*s2 == ',') {
	    s2++;
	    i=0;
	    }
         else break;
         }
      /* Number of texture coordinates must be even */
      if ((BlkD(f, List)->size-3) % 2)
	 return Error;
      /* save the number of texture coordinates */
      w->context->numtexcoords = j;
      c_put(&(w->window->funclist), &f);
     }
   /* return an error for any other value */
   else return Error;
   return Succeeded;
}

/* set the slices attribute */
int setslices(wbp w, char *s)
{
   int slices;
   wcp wc = w->context;

   slices = atoi(s);
   /* must be positive integer */
   if (slices < 1 )
      return Error;

   w->context->slices = slices;
   return Succeeded;
}

/* set the rings attribute */
int setrings(wbp w, char *s)
{
   int rings;
   wcp wc = w->context;

   rings = atoi(s);
   /* must be positive integer */
   if (rings < 1 )
      return Error;

   w->context->rings = rings;
   return Succeeded;
}

/* set the eyepos attribute */
int seteyepos(wbp w, char *s)
{
   char *s2 =s;
   wcp wc = w->context;

   /* parse string */
   while (isspace(*s2)) s2++;

   /* get the x-coordinate of eyepos */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the y-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the z-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;

   redraw3D(w);
   return Succeeded;
}

/* sets the eyedir attribute */
int seteyedir(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;
   /* find the x-coordinate of eyedir */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the y-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the z-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* if there are more entries return an error */
   if (*s2) return Error;
   redraw3D(w);
   return Succeeded;
}

/* sets the eyeup attribute */
int seteyeup(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the x-coordinate of eyeyp */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the y-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the z-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   redraw3D(w);
   return Succeeded;
}


/* set the eye attribute */
/* this set the eyeup, eyedir, and the eyepos attributes */
int seteye(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the eyepos attribute */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the eyedir attribute */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the eyeup attribute */
   if (*s2++ != ',') return Error;
   while (isspace(*s2)) s2++;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   if (redraw3D(w) == Failed)
      return Failed;
   return Succeeded;
}

/* set a texture */
int settexture(wbp w, char* str, int len, struct descrip *f, int curtex)
{
   wcp wc = w->context;
   char* s;
   int nfields, draw_code;
   /*tended struct descrip f; */
   tended struct descrip d;
   tended struct b_record *rp;
   static dptr constr;
   wtp wt;
   int ttype;

   makecurrent(w);
   if (!constr &&  !(constr = rec_structor3d("gl_texture")))
      syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * create a record of the graphical object and its parameters
    */
   if (!(rp = alcrecd(nfields, BlkLoc(*constr))))
      return Failed;
   (*f).dword = D_Record;
   (*f).vword.bptr = (union block *)rp;
   MakeStr("Texture", 7, &(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "Texture");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   s=str;
   while(isspace(*s)) s++;
   while(isdigit(*s)) s++;
   while(isspace(*s)) s++;
   if (*s == ',')  /* must be an image string */
      ttype = 3;
   else		  /* it is a file name */
      ttype = 1;

   wt = lookup_texture_byname(w, str, len, ttype, curtex);
   if (wt == NULL) return Failed;

   /*
    * To redraw the window we must keep track of the "texture name" assigned
    * to it by opengl. This name is stored in wc->texName[wc->ntextures].
    * So by remembering wc->ntextures we can recover the name of the texture.
    */
   MakeInt(wc->curtexture, &(rp->fields[2]));
   rp->fields[3] = nulldesc;
   c_put(&(w->window->funclist), f);

   return Succeeded;
}

/*
 * convert a icon image string into a useable opengl texture
 */
int imagestr(wbp w, char* str)
{
   struct palentry *e;
   int c, i, width, height, row, p;
   word nchars;
   unsigned char *t, *z, *s;

   /* Extract the Width and skip the following comma.*/

   s = (unsigned char *)str;
   z = s + strlen(str);		/* end+1 of string */
   width = 0;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   while (s < z && isdigit(*s))	/* scan number */
      width = 10 * width + *s++ - '0';
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (width == 0 || *s++ != ',') /* skip comma */
      return Failed;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (s >= z)			     /* if end of string */
	 return Failed;

 /* Check for a bilevel format */
   if ((c = *s) == '#' || c == '~') {
      s++;
      nchars = 0;
      for (t = s; t < z; t++)
         if (isxdigit(*t))
            nchars++;	         /* count hex digits */
         else if (*t != PCH1 && *t != PCH2)
            return Failed;	  /* illegal punctuation */
      if (nchars == 0)
         return Failed;
      row = (width + 3) / 4;	/* digits per row */
      if (nchars % row != 0)
         return Failed;
      height = nchars / row;

      i = bltex(w, width, height, c, (char *)s, (word)(z - s));
      if (i == Succeeded)
	   return Succeeded;
      else
	   return Failed;
      }


 /* Extract the palette name and skip its comma.*/
   c = *s++;		     /* save initial character */
   p = 0;
   while (s < z && isdigit(*s))    /* scan digits */
      p = 10 * p + *s++ - '0';
   while (s < z && *s == ' ')	  /* skip blanks */
	 s++;
   if (s >= z || p == 0 || *s++ != ',')/* skip comma */
      return Failed;
   if (c == 'g' && p >= 2 && p <= 256)	/* validate grayscale number */
      p = -p;
   else if (c != 'c' || p < 1 || p > 6)	/* validate color number */
      return Failed;

   /* Scan the image to see which colors are needed. */
   e = palsetup(p);
   if (e == NULL)
      return Failed;
   for (i = 0; i < 256; i++)
      e[i].used = 0;
   nchars = 0;
   for (t = s; t < z; t++) {
      c = *t;
      e[c].used = 1;
      if (e[c].valid || e[c].transpt)
         nchars++;	/* valid color, or transparent */
      else if (c != PCH1 && c != PCH2)
         return Failed;
      }
   if (nchars == 0)
      return Failed;			/* empty image */
   if (nchars % width != 0){
      return Failed;			/* not rectangular */
      }

   /* Create the texture */

   height = nchars/width;

   i = textureimg(w, width, height, e, s, (word)(z-s));
   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a file into a opengl texture */
int fileimage(wbp w, char* filename)
{
   int r, i, nwidth, nheight;
   int status;
   word l;
   struct imgdata im;

   /* a gif file */
   if ((r = readGIF(filename, 0, &im)) == Succeeded){
      i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                     (word)im.width*(word)im.height);
      free(im.data);
      free(im.paltbl);

      }
   else {
      /*
       * Not a gif file. We need to handle other cases beside gif...
       * what are those cases ? ... look at ReadImage
       */
     i = SCREENDEPTH(w);
     i = i / 8;
#if HAVE_LIBJPEG
     if ((r = readJPEG(filename, i, &im)) == Succeeded) {
        switch (i) {
        case 1: i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                        (word)im.width*(word)im.height);
                break;
        case 2: /* i = texture_16img(w, im);
                break; */
        case 3: i = texture_24img(w, im);
                break;
        }
      }
     else
#endif					/* HAVE_JPEG */
#if HAVE_LIBPNG
     if ((r = readPNG(filename, i, &im)) == Succeeded) {
        switch (i) {
        case 1: i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                        (word)im.width*(word)im.height);
                break;
        case 2: /* i = texture_16img(w, im);
                break; */
        case 3: i = texture_24img(w, im);
                break;
        }
      }
     else
#endif					/* HAVE_PNG */

         r = readimage(w, filename, 0, 0, &status);
   }
   if (i == Succeeded)
	 return Succeeded;
   else
      return Failed;
}


/*
 * converts the icon representation of an image into
 * a format accepted by opengl
 */
int textureimg(wbp w, int width, int height,
               struct palentry *e, unsigned char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   wcp wc = w->context;
   int c, v, i, k;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(height * width * 4 + 1);

   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   while (len--) {
      c = *s++;
      v = e[c].valid;
      if (v) {
         /* r,g,b component must be between 0 and 256 */
	   tex[(iy*width+ix)*3+0] = e[c].clr.red/256;
	   tex[(iy*width+ix)*3+1] = e[c].clr.green/256;
 	   tex[(iy*width+ix)*3+2] = e[c].clr.blue/256;
        }
      if (v || e[c].transpt) {		/* advance if valid or transparent */
	   if (e[c].transpt) { /* if transparent use background color */
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
         }
         if (++ix >= width) {
            ix = 0;
	  	/* reset for new row */
            iy--;
            }
         }
      }
      if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
	 }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   if (i == Succeeded)  {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = width;
      wc->stex[k].height = height;
      return Succeeded;
      }
   else {
      free(tex);
      return Failed;
      }
}

/* convert a bi-level image into an opengl texture */
int bltex(wbp w, int width, int height, int ch, char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   wcp wc = w->context;
   unsigned int m, msk1, c, ix, iy;
   int r, b, g, i, k, l;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);

   makecurrent(w);

   m = width % 4;
   if (m == 0)
      msk1 = 8;
   else               /* mask for first byte of row */
      msk1 = 1 << (m - 1);
   ix = width;
   iy = height-1;
   m = msk1;
   while (len--) {
      /* if hexadecimal character */
      if (isxdigit(c = *s++)) {
         if (!isdigit(c))
            c += 9;
         while (m > 0) {
	    --ix;
	    if (c & m){
	       r = (GLint)RED(w->context->fg);
	       g = (GLint)GREEN(w->context->fg);
 	       b = (GLint)BLUE(w->context->fg);
               l = (iy*width+ix)*3;
               tex[l] = r;	/* [ix][iy][0] */
               tex[l+1] = g;	/* [ix][iy][1] */
               tex[l+2] = b;	/* [ix][iy][2] */
            }
	    else if (ch != TCH1) {
    	       r = (GLint)RED(w->context->bg);
	       g = (GLint)GREEN(w->context->bg);
  	       b = (GLint)BLUE(w->context->bg);
               l = (iy*width+ix)*3;
               tex[l] = r;	/* [iy][ix][0] */
               tex[l+1] = g;	/* [iy][ix][1] */
               tex[l+2] = b;	/* [iy][ix][2] */
            }
            m >>= 1;
          }
         if (ix == 0) {	    /* if end of row */
            ix = width;
            iy--;
            m = msk1;
            }
         else
            m = 8;
         }
      }
   if (ix > 0)				/* pad final row if incomplete */
      while (ix < width){
         r = (GLint)RED(w->context->bg);
         g = (GLint)GREEN(w->context->bg);
         b = (GLint)BLUE(w->context->bg);
         l = (iy*width+ix)*3;
         tex[l] = r;	/* [iy][ix][0] */
         tex[l+1] = g;	/* [iy][ix][1] */
         tex[l+2] = b;	/* [iy][ix][2] */
         ix++;
       }

   i = texture(width, height, (GLubyte *)tex, w->context->texmode);
   if (i == Succeeded)  {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = width;
      wc->stex[k].height = height;
      return Succeeded;
      }
   else {
     free(tex);
     return Failed;
     }
}


/* check if a number is a power of two */
int powertwo(int a)
{
   int p = 1;
   while(p < a){
      p = p*2;
     }
   if (a == p) return 0;
   else return p;
}

static wclrp lastcp;

/* convert a 2D window into a texture */
int texwindow2D(wbp w, wbp w2d)
{
   struct imgmem imem;
   int i, j, r, k, l;
   long rv;
   wsp ws = w2d->window;
   char strout[50];
   char *s2;
   GLubyte *tex = (GLubyte *)malloc(ws->height * ws->width * 3);
   GLubyte *texp;
   LinearColor clr;
   wclrp cp;
   unsigned long c;
   wcp wc = w2d->context;
#ifdef XWindows
   wdp wd = w2d->window->display;
   Display *stddpy = wd->display;
   XColor colorcell;
   lastcp = wd->colors;
#endif					/* XWindows */

   makecurrent(w);
   imem.x = 0;
   imem.y = 0;
   imem.width = ws->width;
   imem.height = ws->height;
   /* call get pixel to get pixel information */
   if (getpixel_init(w2d, &imem) == Failed)
      return Failed;
   for(j=0; j < ws->height; j++)
	for(i=0; i < ws->width; i++) {
#ifdef XWindows
	   c = colorcell.pixel = XGetPixel(imem.im, i, j);
	   rv = 0xff000000;
	   if (lastcp->c == c) {
             l = ((ws->height-j-1)*ws->width)*3;
              texp = tex + l;
	      texp[0] = lastcp->r>>8;
	      texp[1] = lastcp->g>>8;
	      texp[2] = lastcp->b>>8;
	      continue;
	      }
	   else
	      for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
		 if (cp->c == c) {
		    lastcp = cp;
		 foundc:
                    l = ((ws->height-j-1)*ws->width)*3;
                    texp = tex + l;

		    texp[0] = cp->r>>8;
		    texp[1] = cp->g>>8;
		    texp[2] = cp->b>>8;
		    continue;
		    }
		 }
	   if (rv == 0xff000000) {
	      XQueryColor(stddpy, wd->cmap, &colorcell);
	      rv = 1;
	      clr = lcolor(w, colorcell);
              l = ((ws->height-j-1)*ws->width+i)*3;
              tex[l] = clr.red>>8;
              tex[l+1] = clr.green>>8;
              tex[l+2] = clr.blue>>8;
	      }
#else
 	   if (getpixel(w2d, i, j, &rv, strout, &imem) == Failed)
            return Failed;
	   s2 = strout;
         /* parse string to get pixel values */
	   while(isspace(*s2)) s2++;
           l = ((ws->height-j-1)*ws->width+i)*3;
           tex[l] = atoi(s2)/256;
  	   while(isdigit(*s2)) s2++;
   	   s2++;
           tex[l+1] = atoi(s2)/256;
   	   while (isdigit(*s2)) s2++;
  	   s2++;
           tex[l+2] = atoi(s2)/256;
#endif
        }

   /* apply the texture */
   r = texture(ws->width, ws->height, (GLubyte*)tex, w->context->texmode);
   if (r == Succeeded)  {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = ws->width;
      wc->stex[k].height = ws->height;
      return Succeeded;
      }
   else {
     free(tex);
     return Failed;
     }
}

/* use another opengl window as a texture source */
int texwindow3D(wbp w1, wbp w2)
{
   wsp ws = w2->window;
   wcp wc = w2->context;
   int width = ws->width;
   int height = ws->height;
   int i, k;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);

   /* change the current context to w2's context */
#ifdef XWindows
   glXMakeCurrent(ws->display->display, ws->win, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   glXMakeCurrent(w1->window->display->display, w1->window->win, w1->context->ctx);
    i = texture(width, height, (GLubyte *)tex, w1->context->texmode);
#endif					/* XWindows */
#ifdef MSWindows
   {
   HDC stddc = CreateWinDC(w2);
   wglMakeCurrent(stddc, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   ReleaseDC(ws->iconwin, stddc);
   stddc = CreateWinDC(w1);
   wglMakeCurrent(stddc, w1->context->ctx);
   i = texture(width, height, (GLubyte *)tex, w1->context->texmode);
   ReleaseDC(w1->window->iconwin, stddc);
   }
#endif					/* MSWindows */
    if (i == Succeeded) {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = width;
      wc->stex[k].height = height;
      return Succeeded;
      }
    else {
       free(tex);
       return Failed;
       }
}

/* apply a texture to a scene */
int texture(int width, int height, GLubyte *tex, int texmode)
{
   GLubyte *tex2;

   /* if not a power of two, scale image to closest power of two */
   if (powertwo(width) || powertwo(height)) {
      int neww=1, newh=1, rv;
      while (neww * 2 < width) neww *= 2;
      while (newh * 2 < height) newh *= 2;
      tex2 = (GLubyte *) malloc(neww * newh * 3);
      if (tex2 == NULL) return Failed;
      rv = gluScaleImage(GL_RGB, width, height, GL_UNSIGNED_BYTE, tex,
			 neww, newh, GL_UNSIGNED_BYTE, tex2);
      if (rv) { free(tex2); return Failed; }
      width = neww;
      height = newh;
      }
   else tex2 = tex;

   glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB,
		GL_UNSIGNED_BYTE, tex2);

   if (tex2 != tex) free(tex2);

   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texmode);
   return Succeeded;
}

int texture1(int width, int height, GLubyte *tex, int texmode)
{
   GLubyte *tex2;

   /* if not a power of two, scale image to closest power of two */
   if (powertwo(width) || powertwo(height)) {
      int neww=1, newh=1, rv;
      while (neww * 2 < width) neww *= 2;
      while (newh * 2 < height) newh *= 2;
      tex2 = (GLubyte *) malloc(neww * newh * 3);
      if (tex2 == NULL) return Failed;
      rv = gluScaleImage(GL_RGB, width, height, GL_UNSIGNED_BYTE, tex,
			 neww, newh, GL_UNSIGNED_BYTE, tex2);
      if (rv) { free(tex2); return Failed; }
      width = neww;
      height = newh;
      }
   else tex2 = tex;
   glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGB,
                GL_UNSIGNED_BYTE, tex2);

   if (tex2 != tex) free(tex2);

   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texmode);
   return Succeeded;
}


/*
 * do a translation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int translate(wbp w, dptr argv, int i, dptr f)
{
   static dptr constr;
   double coords[3];
   int j, nfields, draw_code;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_translate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform the translation
    */
   for (j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);

   makecurrent(w);
   glTranslated(coords[0], coords[1], coords[2]);

   /*
    * Create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Translate", 9, &(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "Translate");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   for (j = i; j < i+3; j++)
      rp->fields[2 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a rotation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int rotate(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j, draw_code;
   double coords[4];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_rotate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /* convert parameters and perform the rotation */
   for (j=0; j < 4; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);
   makecurrent(w);
   glRotated(coords[0], coords[1], coords[2], coords[3]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Rotate", 6, &(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "Rotate");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   /* strangeness here preserves name,x,y,z,... field ordering */
   rp->fields[5] = argv[i];
   rp->fields[2] = argv[i+1];
   rp->fields[3] = argv[i+2];
   rp->fields[4] = argv[i+3];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a scaling
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int scale(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j, draw_code;
   double coords[3];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_scale")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform scaling
    */
   for(j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return -(i+j)-1;
   makecurrent(w);
   glScaled(coords[0], coords[1], coords[2]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Scale", 5, &(rp->fields[0]));
   draw_code = si_s2i(redraw3Dnames, "Scale");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   for (j = i; j < i+3; j++)
      rp->fields[2 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * For each 3D graphics operation, there is a descriptor that
 * holds the record constructor for that type of primitive.
 * The first field is named "name"; for > 1 field, their names are in
 * an array. If fields > 2, then fields 2-4 are named "x", "y", "z".
 */
struct descrip gl_torus = {D_Null};
struct descrip gl_cube = {D_Null};
struct descrip gl_sphere = {D_Null};
struct descrip gl_cylinder = {D_Null};
struct descrip gl_disk = {D_Null};
struct descrip gl_rotate = {D_Null};
struct descrip gl_translate = {D_Null};
struct descrip gl_scale = {D_Null};
struct descrip gl_popmatrix = {D_Null};
struct descrip gl_pushmatrix = {D_Null};
struct descrip gl_identity = {D_Null};
struct descrip gl_matrixmode = {D_Null};
struct descrip gl_meshmode = {D_Null};
struct descrip gl_texture = {D_Null};
struct descrip gl_font3d = {D_Null};
struct descrip gl_drawstring3d = {D_Null};
struct descrip gl_mark = {D_Null};
struct descrip gl_endmark = {D_Null};

char * gl_torus_fields[] = {"radius1","radius2", "slices", "rings"};
char * gl_cube_fields[] = {"length"};
char * gl_sphere_fields[] = {"radius", "slices", "rings"};
char * gl_cylinder_fields[] ={"height","radius1","radius2","slices", "rings"};
char * gl_disk_fields[] = {"radius1","radius2", "angle1","angle2","slices", "rings"};
char * gl_rotate_fields[] = {"angle"};
char * gl_matrixmode_fields[] = {"mode"};
char * gl_meshmode_fields[] = {"mode"};
char * gl_texture_fields[] = {"texture_handle", "window_binding"};
char * gl_font_fields[] = {"font_ptr"};
char * gl_drawstring3d_fields[] = {"str"};
char * gl_mark_fields[] = {"section_name","skip","count","int_code", "depth"};
char * gl_endmark_fields[] = {"depth"};

dptr rec_structinate(dptr dp, char *name, int nfields, char *a[])
{
   int i;
   struct descrip s;
   struct descrip fields[16];
   if (is:null(*dp)) {
      AsgnCStr(s, name);
      AsgnCStr(fields[0], "name");
      AsgnCStr(fields[1], "code");
      if (nfields > 3) {
         if (!strcmp(name,"gl_mark") || !strcmp(name, "gl_texture")) {
           for(i=2; i < nfields; i++)
              AsgnCStr(fields[i], a[i-2]);
           }
         else {
           AsgnCStr(fields[2], "x");
           AsgnCStr(fields[3], "y");
           AsgnCStr(fields[4], "z");
           for(i=5; i < nfields; i++)
              AsgnCStr(fields[i], a[i-5]);
           }
         }
      else if (nfields == 3)
         AsgnCStr(fields[2], a[0]);
      dp->dword = D_Proc;
      dp->vword.bptr = (union block *)dynrecord(&s, fields, nfields);
      }
   return dp;
}


dptr rec_structor3d(char *name)
{
#ifdef Graphics3D
   if (!strcmp(name, "gl_torus"))
      return rec_structinate(&gl_torus, "gl_torus", 9, gl_torus_fields);
   else if (!strcmp(name, "gl_cube"))
      return rec_structinate(&gl_cube, "gl_cube", 6, gl_cube_fields);
   else if (!strcmp(name, "gl_sphere"))
      return rec_structinate(&gl_sphere, "gl_sphere", 8, gl_sphere_fields);
   else if (!strcmp(name, "gl_cylinder"))
      return rec_structinate(&gl_cylinder, "gl_cylinder", 10, gl_cylinder_fields);
   else if (!strcmp(name, "gl_disk"))
      return rec_structinate(&gl_disk, "gl_disk", 11, gl_disk_fields);
   else if (!strcmp(name, "gl_rotate"))
      return rec_structinate(&gl_rotate, "gl_rotate", 6, gl_rotate_fields);
   else if (!strcmp(name, "gl_translate"))
      return rec_structinate(&gl_translate, "gl_translate", 5, NULL);
   else if (!strcmp(name, "gl_scale"))
      return rec_structinate(&gl_scale, "gl_scale", 5, NULL);
   else if (!strcmp(name, "gl_popmatrix"))
      return rec_structinate(&gl_popmatrix, "gl_popmatrix", 2, NULL);
   else if (!strcmp(name, "gl_pushmatrix"))
      return rec_structinate(&gl_pushmatrix, "gl_pushmatrix", 2, NULL);
   else if (!strcmp(name, "gl_identity"))
      return rec_structinate(&gl_identity, "gl_identity", 2, NULL);
   else if (!strcmp(name, "gl_matrixmode"))
      return rec_structinate(&gl_matrixmode, "gl_matrixmode",
				3, gl_matrixmode_fields);
   else if (!strcmp(name, "gl_meshmode"))
      return rec_structinate(&gl_meshmode, "gl_meshmode",
				3, gl_meshmode_fields);
   else if (!strcmp(name, "gl_texture"))
      return rec_structinate(&gl_texture, "gl_texture", 4, gl_texture_fields);
   else if (!strcmp(name, "gl_font3d"))
      return rec_structinate(&gl_font3d, "gl_font3d", 3, gl_font_fields);
   else if (!strcmp(name, "gl_drawstring3d"))
	return rec_structinate(&gl_drawstring3d, "gl_drawstring3d",
				6, gl_drawstring3d_fields);
   else if (!strcmp(name, "gl_endmark"))
      return rec_structinate(&gl_endmark, "gl_endmark", 3, gl_mark_fields);
   else if (!strcmp(name, "gl_mark"))
	return rec_structinate(&gl_mark, "gl_mark", 7, gl_mark_fields);
#endif					/* Graphics3D */

   return 0;
}

wtp lookup_texture_byname(wbp w, char *name, int len, int ttype, int curtex)
{
   char filename[MaxFileName +1];
   wcp wc = w->context;
   wtp wt = wc->textures, wt2;
   int i, saved_tex;
   makecurrent(w);
   while (wt) {
      if (wt->textype == ttype) {
	 switch (ttype) {
	 case 1: /* file */
	    if ((StrLen(wt->d) == len) && strncmp(StrLoc(wt->d),name,len)==0) {
	       wc->curtexture = wt->texindex;
	       return wt;
	       }
	    break;
	 case 2: /* window */
	    break;
	 case 3: /* string */
	    break;
	    }
	 }
      wt = wt->next;
      }
   GRFX_ALLOC(wt2, _wtexture);
   wt2->textype = ttype;
   StrLoc(wt2->d) = strdup(name);
   StrLen(wt2->d) = len;

   wt2->next = wc->textures;
   if (wc->textures) {
      wc->textures->previous = wt2;
      }
   wc->textures = wt2;
   saved_tex = wc->curtexture;
   if (curtex==-1){
      /*
      * need a new texture name, make room for it if necessary
      */
      if (!make_enough_texture_space(wc)) return NULL;
      wc->curtexture = wc->ntextures;
      }
   else /* replace the curtex */
      wc->curtexture = curtex;


   glBindTexture(GL_TEXTURE_2D, wc->texName[wc->curtexture]);

   if (ttype == 3)
      i = imagestr(w, name);
   else {
      strncpy(filename, name, MaxFileName);
      filename[MaxFileName] = '\0';
      i = fileimage(w, filename);
      }

   if (i == Succeeded){
      wt2->texindex = wc->ntextures;
      wc->ntextures++;
      return wt2;
      }
   else{
      wc->curtexture=saved_tex;
      return NULL;
      }
}

int texture_24img(wbp w, struct imgdata im)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   wcp wc = w->context;
   int width=im.width, height=im.height;
   word len;
   int c, v, i, k;
   unsigned char *t;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(im.height * im.width * 3);

   width = im.width;
   len = (word)im.width * (word)im.height;
   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   t = im.data;
   while (len--) {
         /* r,g,b component must be between 0 and 256 */
      tex[(iy*width+ix)*3+0] = t[0];
      tex[(iy*width+ix)*3+1] = t[1];
      tex[(iy*width+ix)*3+2] = t[2];
      t = t+3;
      if (++ix >= width) {
         ix = 0;
 	/* reset for new row */
         iy--;
      }
    }
    if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
	 }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   if (i == Succeeded) {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = width;
      wc->stex[k].height = height;
      return Succeeded;
      }
   else {
      free(tex);
      return Failed;
      }
}

int texture_16img(wbp w, struct imgdata im)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   wcp wc = w->context;
   int width=im.width, height=im.height;
   word len;
   int c, v, i, k;
   unsigned char *t;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);

   len = (word)im.width * (word)im.height;
   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   t = im.data;
   while (len--) {
         /* r,g,b component must be between 0 and 256 */
      tex[(iy*width+ix)*3+0] = t[0] && 0xF8;
      tex[(iy*width+ix)*3+1] = t[1] && 0xF8;
      tex[(iy*width+ix)*3+2] = t[2] && 0xF8;
      t = t+3;
      if (++ix >= width) {
         ix = 0;
 	/* reset for new row */
         iy--;
      }
   }
   if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
    }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   if (i == Succeeded) {
      k = wc->curtexture;
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc)==Failed) return Failed;*/
      if (k>=wc->maxstex){
	 wc->maxstex *= 2;
	 wc->stex = realloc(wc->stex, sizeof(struct _savetexture)*wc->maxstex);
	 if (wc->stex==NULL) return Failed;
	 }

      wc->stex[k].tex = tex;
      wc->stex[k].width = width;
      wc->stex[k].height = height;
      return Succeeded;
      }
   else {
      free(tex);
      return Failed;
      }
}

int
drawstrng3d(wbp w, double x, double y, double z, char *s)
{
   int xx=0;
   char *p, *q;
#ifdef WIN32
   char path[255] = "..\\src\\lib\\fonts\\";
#else
   char path[255] = "../src/lib/fonts/";
#endif
   static char *full_name = NULL;
   FILE *f = 0;
#if HAVE_FTGL
   int len_full_name=0, len_path=0, len_font=strlen(curr_font->name);

   makecurrent(w);
   if (full_name==NULL) {
      full_name = (char *) malloc(sizeof(char)*255);
      findonpath("unicon", full_name, 255);
      q = full_name + strlen(full_name);
      while (q > full_name && q[-1] != '/')
	 q--;
      *q = '\0';
      }
   len_path = strlen(path);
   len_full_name = strlen(full_name);
   p = (char *) malloc(sizeof(char)*(len_full_name+len_path+len_font+1));
   if (!p) return Failed;
   strcpy(p, full_name);
   strcat(p,path);
   strcat(p,curr_font->name);
   f = fopen(p, "r");
   if (!f) {
      fprintf(stderr, "can't open font file %s\n", p);
      fflush(stderr);
      free(p);
      return Failed;
      }
   else fclose(f);

   xx=cpp_drawstring3d(x*64,y*64,z*64,s,p,curr_font->type, curr_font->size,
		       &(curr_font->fonts));

   switch (xx) {
   case 1: fprintf(stderr, "Error:file does not support point size\n"); break;
   case 2: fprintf(stderr, "Insufficient Memory to allocate font\n"); break;
   case 3: fprintf(stderr, "Return 3\n"); break;
      }

   free(p);
   return ((xx==0)?Succeeded:Failed);
#else
   return Failed;
#endif
}

int
add_3dfont(char *fname, int fsize, char ftype)
{
#if HAVE_FTGL
  if (end_font) {
     end_font->next = (struct _wfont *) malloc(sizeof(struct _wfont));
     end_font = end_font->next;
     if (!end_font) return 0;
     }
  else {
     end_font = (struct _wfont *) malloc(sizeof(struct _wfont));
     if (!end_font) return 0;
     start_font = end_font;
     }
   end_font->name = (char *) strdup(fname);
   if (!end_font->name)
	return 0;
   end_font->size = fsize;
   end_font->type = ftype;
   end_font->fonts = 0;
   end_font->next = 0;
#endif
   return 1;
}

wfp
srch_3dfont(char *fname, int fsize, char ftype)
{
#if HAVE_FTGL
   wfp g = start_font;
   while (g) {
      if (!strcmp(g->name, fname) && g->size==fsize && g->type==ftype) {
	 return g;
	 }
      g = g->next;
      }
#endif
  return 0;
}

int setmeshmode(wbp w, char* s)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif                                  /* XWindows */
   int draw_code, t=0;
   static dptr constr;
   int nfields;
   tended struct b_record *rp;
   tended struct descrip f;

   if (!constr && !(constr = rec_structor3d("gl_meshmode")))
      syserr("failed to create opengl record constructor");

   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   makecurrent(w);

   /*
    * create a record of the graphical object
    */

   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return -1);

   f.dword = D_Record;
   f.vword.bptr = (union block *)rp;

   MakeStr("MeshMode", 8 ,&(rp->fields[0]));


   draw_code = si_s2i(redraw3Dnames, "MeshMode");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   if (!strcmp(s, "points")) t=GL_POINTS;
   else if (!strcmp(s, "lines")) t=GL_LINES;
   else if (!strcmp(s, "linestrip")) t=GL_LINE_STRIP;
   else if (!strcmp(s, "lineloop")) t=GL_LINE_LOOP;
   else if (!strcmp(s, "triangles")) t=GL_TRIANGLES;
   else if (!strcmp(s, "trianglefan")) t=GL_TRIANGLE_FAN;
   else if (!strcmp(s, "trianglestrip")) t=GL_TRIANGLE_STRIP;
   else if (!strcmp(s, "quads")) t=GL_QUADS;
   else if (!strcmp(s, "quadstrip")) t=GL_QUAD_STRIP;
   else if (!strcmp(s, "polygon")) t=GL_POLYGON;
   else return Failed;

   MakeInt(t, &(rp->fields[2]));
   c_put(&(w->window->funclist), &f);

   w->context->meshmode = t;
   return Succeeded;
}

void getmeshmode(wbp w, char *answer)
{
   switch(w->context->meshmode) {
      case GL_POINTS: strcpy(answer, "points"); break;
      case GL_LINES: strcpy(answer, "lines"); break;
      case GL_LINE_STRIP: strcpy(answer, "linestrip"); break;
      case GL_LINE_LOOP: strcpy(answer, "lineloop"); break;
      case GL_TRIANGLES: strcpy(answer, "triangles"); break;
      case GL_TRIANGLE_FAN: strcpy(answer, "trianglefan"); break;
      case GL_TRIANGLE_STRIP: strcpy(answer, "trianglestrip"); break;
      case GL_QUADS: strcpy(answer, "quads"); break;
      case GL_QUAD_STRIP: strcpy(answer, "quadstrip"); break;
      case GL_POLYGON: strcpy(answer, "polygon"); break;
   }
}

int section_length(wbp w)
{
   wsp ws = w->window;
   int i, tmp, flag=0;
   C_integer v;
   tended struct descrip flist, save_flist, fname;
   tended struct b_list *funclist;
   tended struct b_list *hp;
   tended struct b_lelem *bp;
   tended struct b_record *rp;
   int used, elements;
   word k;

   hp = BlkD(ws->funclist, List);
   elements = hp->size;
   if (hp->size <= 0)
        return 0;

   bp = Blk(hp->listtail, Lelem);
   used=bp->nused;
   k = bp->first + used-1;
   if (k>=bp->nslots) k = k - bp->nslots;

   for (i=0; i<elements; i++) {
      flist = bp->lslots[k];
      k--;
      used--;
      if (k<0) k=bp->nslots-1;

      if (used<=0) {
  	 bp = (struct b_lelem *) bp->listprev;
	 used = bp->nused;
         k = bp->first + used-1;
         if (k>=bp->nslots) k=k-bp->nslots-1;
      }
      if (is:record(flist)) {
	 rp = BlkD(flist, Record);
         fname = rp->fields[0];
         tmp=si_s2i(redraw3Dnames, StrLoc(fname));

	 if (tmp == -1) {
	    return Failed;
	    }
         if ((tmp & ~0xf)==REDRAW_MARK) {
             if (!cnv:C_integer(rp->fields[4], v)) return Failed;
	     if (v==0) {
		save_flist = flist;
                flag = 1;
                break;
                }
             }
         }
      }

   /* # of elements plus the new element which mark the end of the section */
   if (w->context->selectionenabled) i++;

   if (flag) {  /* count */
      MakeInt(i, &(((struct b_record *) BlkLoc(save_flist))->fields[4]));
      }
   return Succeeded;
}

int swapno(int *x, int *y)
{
   int t;
   t=*x;
   *x=*y;
   *y=t;
   return 1;
}

int TexDrawLine(wbp w, int texhandle, int x1, int y1, int x2, int y2)
{
   wcp wc=w->context;
   char bfmode = wc->buffermode, steep, ystep;
   int cred, cgreen, cblue;
   int wd3, wd, ht, w3, yy, xx, l, dx, dy, ee, ty, tx;
   GLubyte *tex;

   cred = (GLint) RED(wc->fg);
   cgreen = (GLint) GREEN(wc->fg);
   cblue = (GLint) BLUE(wc->fg);

   tex = wc->stex[texhandle].tex;
   wd  = wc->stex[texhandle].width;
   ht  = wc->stex[texhandle].height;

   /* Bresenham algorithm for line drawing */
   if (x2 - x1 == 0) {
      /* Vertical line (i.e. y-direction) */
      if (y2 < y1) swapno(&y1, &y2);
      xx = x1 * 3;
      wd3 = wd * 3;
      w3 = wd * 3 * y1;
      for (yy = y1; yy <= y2; yy++) {
	 l = xx + w3;
	 tex[l] = cred;
	 tex[l+1]=cgreen;
	 tex[l+2]=cblue;
	 w3 += wd3;
	 }
      wc->curtexture = texhandle;
      if (bfmode) {
	 glBindTexture(GL_TEXTURE_2D, wc->texName[wc->curtexture]);
	 texture1(wd, ht, tex, wc->texmode);
	 }
      return Succeeded;
      }

   /* Other than vertical lines */
   steep = abs(y2 - y1) > abs(x2 - x1);
   if (steep) {
      swapno(&x1, &y1);
      swapno(&x2, &y2);
      }
   if (x1 > x2) {
      swapno(&x1, &x2);
      swapno(&y1, &y2);
      }
   dx = x2 - x1;
   dy = abs(y2 - y1);
   ee  = 0;
   yy = y1;
   if (y1 < y2) ystep = 1;
   else ystep = -1;
   wd3 = wd * 3;
   if (steep) w3 = wd3 * x1;
   else w3 = wd3 * y1;
   ty = y1 * 3;
   tx = x1 * 3;
   for (xx=x1; xx<=x2; xx++) {
      if (steep) {
	 l = w3+ty;
	 }
      else {
	 l = w3+tx;
	 }
      tex[l] = cred;
      tex[l+1] = cgreen;
      tex[l+2] = cblue;
      ee += dy;
      if (2 * ee >= dx) {
	 yy = yy + ystep;
	 ty += 3*ystep;
	 if (!steep) w3 += wd3*ystep;
	 ee -= dx;
	 }
      if (steep) w3 += wd3;
      else tx += 3;
      }

   wc->curtexture = texhandle;
   if (bfmode) {
      glBindTexture(GL_TEXTURE_2D, wc->texName[wc->curtexture]);
      texture1(wd, ht, tex, wc->texmode);
      }
   return Succeeded;
}

int TexDrawPoint(wbp w, int texhandle, int x, int y)
{
   wcp wc=w->context;
   char bfmode = wc->buffermode;
   int cred, cgreen, cblue, l, wd, ht;
   GLubyte *tex;

   cred = (GLint) RED(wc->fg);
   cgreen = (GLint) GREEN(wc->fg);
   cblue = (GLint) BLUE(wc->fg);

   tex = wc->stex[texhandle].tex;
   wd  = wc->stex[texhandle].width;
   ht  = wc->stex[texhandle].height;

   l = x + wd*3*y;
   tex[l] = cred;
   tex[l+1]=cgreen;
   tex[l+2]=cblue;

   wc->curtexture = texhandle;
   if (bfmode) {
      glBindTexture(GL_TEXTURE_2D, wc->texName[wc->curtexture]);
      texture1(wd, ht, tex, wc->texmode);
      }
   return Succeeded;
}


/*
 * Update Texture with new image data
 */

int TexReadImage(wbp w, int texhandle, int x, int y, struct imgdata *imd)
{
   wcp wc=w->context;
   char bfmode = wc->buffermode;
   int wd, ht, l, nextLineOffset, i, j;
   GLubyte *tex;
   unsigned char *s;

   tex = wc->stex[texhandle].tex;
   wd  = wc->stex[texhandle].width;
   ht  = wc->stex[texhandle].height;

   /*  check for width and height.  the old texture with the new image  */
   if (wd<x+imd->width || ht<y+imd->height)
      return Failed;

   s = imd->data ;  /* point to the image data*/
   l = (ht-y)*wd*3- ( wd-x)*3; /* first byte in texture data to be updated */
   nextLineOffset = (wd+imd->width)*3;

   for (i=0; i<imd->height; i++) {
      for (j=0; j<imd->width; j++) {
	 tex[l++] = (GLubyte) *s++;
	 tex[l++] = (GLubyte) *s++;
	 tex[l++] = (GLubyte) *s++;
	 }
      l -= nextLineOffset;
      }

   wc->curtexture = texhandle;
   if (bfmode) {
      glBindTexture(GL_TEXTURE_2D, wc->texName[wc->curtexture]);
      texture1(wd, ht, tex, wc->texmode);
      }
   return Succeeded;
}

int setselectionmode(wbp w, char* s)
{
   tended struct descrip f;
   struct descrip funcname, g;
   tended struct b_list *func;
   tended struct descrip mode;
   int draw_code;
   wcp wc = w->context;

   makecurrent(w);
   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
	   return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("Pick", 4, &funcname);
   c_put(&f, &funcname);

   draw_code = si_s2i(redraw3Dnames, "Pick");
   if (draw_code == -1)
	   return Failed;
   MakeInt(draw_code, &g);
   c_put(&f, &g);

   if (!strcmp("on", s))
	   wc->selectionenabled = 1;
   else if (!strcmp("off", s))
	   wc->selectionenabled = 0;
   else
	   return Error;

   wc->app_use_selection3D = 1;

   MakeInt(wc->selectionenabled, &mode);
   c_put(&f, &mode);

   c_put(&(w->window->funclist), &f);
   return Succeeded;
}
