/*
 *  File: ropengl.ri
 *     opengl support routines
 */

FILE *wopengl(char *name, struct b_list *lp, dptr attr, int n, int *err_index)
{
   FILE *f;
   wbp  w;
   wsp  ws;
   GLfloat ambient_model[] = {0.2, 0.2, 0.2, 1.0};
   int  query;
   int major, minor;

   /* create an opengl window */
#ifdef XWindows
   int  L[] = {GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 16, None};

  /* create an opengl window */
   wdp wd = alc_display(NULL);
   if (!glXQueryExtension(wd->display, &query, &query)) {
      printf("X server has no OpenGL GLX extension");
      return NULL;
      }
   wd->vis = glXChooseVisual(wd->display, wd->screen, L);
   if (wd->vis == NULL) {
      printf("visual failed");
      return NULL;
      }
#endif					/* XWindows */
   f = wopen(name, lp, attr, n, err_index, 1);

   if (!f) return NULL;
   w = (wbp) f;
   ws = w->window;

  /* set defaults for attributes */
   w->context->eyeupx = w->context->eyeupz = 0.0;
   w->context->eyeupy = 1.0;
   w->context->dim = 3;
   w->context->eyeposx = w->context->eyeposy =  w->context->eyeposz = 0.0;
   w->context->eyedirx = w->context->eyediry = 0.0;
   w->context->eyedirz = -100.0;
   w->context->autogen = 1;
   w->context->texmode = 0;
   w->context->numtexcoords = 0;
   w->context->ntextures = 0;

   /* create an empty list for list of function calls */
   if ((ws->flist = alclist(0, MinListSlots)) == NULL)
      return NULL;
   ws->funclist.dword = D_List;
   ws->funclist.vword.bptr = (union block *)ws->flist;

   /* set up the appropriate opengl states */
   glViewport(0, 0, (GLsizei)ws->width, (GLsizei)ws->height);
   glClearColor(RED(w->context->bg)/(GLfloat)255,
		GREEN(w->context->bg)/(GLfloat)255,
		BLUE(w->context->bg)/(GLfloat)255, 0.0);

   glGenTextures(10, w->context->texName);
   glEnable(GL_DEPTH_TEST);
   glEnable(GL_TEXTURE_GEN_S);
   glEnable(GL_TEXTURE_GEN_T);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glFrustum(-0.5, 0.5, -0.5, 0.5, 1.0, 15.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   return f;
}


/* code for primitives -- polygon, lines, points,
   segments, filled polygons, tori, spheres, cubes,
   cylinders, and disks.  */

/* drawpoly() - draws polygons, lines, points, segments,
   and filled polygons */

int drawpoly(wbp w, double* v, int num, int type, int dim)
{
   int i, j;
   wcp wc = w->context;

   /* must reset the current normal vector */
   glNormal3f(0.0, 0.0, 1.0);

   /* each vertex has an x-coordinate and a y-coordinate */
   if (dim == 2){

      /* no texturing */
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i=i+2)
            glVertex2d(v[i], v[i+1]);
         glEnd();
        }
      else {
         /* opengl will generate texture coordinates */
         if (wc->autogen) {
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+2)
               glVertex2d(v[i], v[i+1]);
            glEnd();
           }
         else {
            /* there must be at least the same
              number of texture coordinate pairs as
              there are vertices. If not fail */
            if (num/2 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i = i+2) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex2d(v[i], v[i+1]);
               j += 2;
             }
            glEnd();
           }
        }
     }

   /* each vertex is of the form (x, y, z) */
   if (dim == 3){
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i = i+3)
            glVertex3d(v[i], v[i+1], v[i+2]);
         glEnd();
       }
      else {

   /* opengl should generate the texture coordinate */
         if (wc->autogen){

            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);

            glBegin(type);
            for (i = 0; i < num; i=i+3)
               glVertex3d(v[i], v[i+1], v[i+2]);
            glEnd();
           }
         else {
            /* if there are not the same number of
               texture coordinate pairs  as there are
               vertices, fail */
            if (num/3 > wc->numtexcoords/2)
              return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+3) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex3d(v[i], v[i+1], v[i+2]);
               j = j + 2;
             }
            glEnd();
         }
      }
   }
   /* each vertex is of the form (x, y, z, w) */
   if (dim == 4){
      if (!wc->texmode){
         glBegin(type);
         for (i = 0; i < num; i=i+4)
            glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
         glEnd();
        }
      else {
         /* have opengl generate texture coordinates */
         if (wc->autogen){
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+4)
              glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
            glEnd();
           }
          else {
         /* fail if the number of vertices is more than
             the number of texture coordinate pairs */
            if (num/4 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+4) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
               j = j + 2;
              }
            glEnd();
           }
         }
       }
   return Succeeded;
}


/* helper function to draw a torus */
void torus(double radius1, double radius2, double x,double y, double z,int gen)
{
   int i, j;
   GLfloat theta, phi, theta1;
   GLfloat cosTheta, sinTheta;
   GLfloat cosTheta1, sinTheta1;
   GLfloat ringDelta, sideDelta;
   GLint rings = 16, nsides = 16;

   /* generate texture coordinates if needed */
   if (gen == 1){
      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      }

   /* push matrix to preform the needed translation */
   glPushMatrix();
   glTranslatef(x, y, z);

#ifndef M_PI
#define M_PI        3.14159265358979323846264338327950288419716939937511
#endif					/* M_PI */

   /* rotate to make the torus look nicer */
   glRotatef(130.0, 1.0, 0.0, 0.0);
   ringDelta = 2.0 * M_PI / rings;
   sideDelta = 2.0 * M_PI / nsides;
   theta = 0.0;
   cosTheta = 1.0;
   sinTheta = 0.0;

   /* draw the torus */
   for (i = rings - 1; i >= 0; i--) {
      theta1 = theta + ringDelta;
      cosTheta1 = cos(theta1);
      sinTheta1 = sin(theta1);
      glBegin(GL_QUAD_STRIP);
      phi = 0.0;
      for (j = nsides; j >= 0; j--) {
         GLfloat cosPhi, sinPhi, dist;
         phi += sideDelta;
         cosPhi = cos(phi);
         sinPhi = sin(phi);
         dist = radius2 + radius1 * cosPhi;
         glNormal3f(cosTheta1 * cosPhi, -sinTheta1 * cosPhi, sinPhi);
         glVertex3f(cosTheta1 * dist, -sinTheta1 * dist, radius1 * sinPhi);
         glNormal3f(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
         glVertex3f(cosTheta * dist, -sinTheta * dist,  radius1 * sinPhi);
         }
      glEnd();
      theta = theta1;
      cosTheta = cosTheta1;
      sinTheta = sinTheta1;
     }
   glPopMatrix();
   glFlush();
}

/* draw a cube */
void cube(double length, double x, double y, double z, int gen)
{
  static GLfloat n[6][3] =
  {
    {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0},{1.0, 0.0, 0.0},
    {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0},{0.0, 0.0, -1.0}
  };

  static GLint faces[6][4] =
  {
    {0, 1, 2, 3}, {3, 2, 6, 7}, {7, 6, 5, 4},
    {4, 5, 1, 0}, {5, 6, 2, 1}, {7, 4, 0, 3}
  };

  GLfloat v[8][3];
  GLint i;

  glPushMatrix();

  glTranslatef(x, y, z);
  glRotatef(45.0, 0.0, 0.0, 1.0);
  glRotatef(45.0, 1.0, 0.0, 0.0);

  v[0][0] = v[1][0] = v[2][0] = v[3][0] = -length / 2;
  v[4][0] = v[5][0] = v[6][0] = v[7][0] = length / 2;
  v[0][1] = v[1][1] = v[4][1] = v[5][1] = -length / 2;
  v[2][1] = v[3][1] = v[6][1] = v[7][1] = length / 2;
  v[0][2] = v[3][2] = v[4][2] = v[7][2] = -length / 2;
  v[1][2] = v[2][2] = v[5][2] = v[6][2] = length / 2;

  /* set default coordinates if needed */

  if (gen == 1) {
     glDisable(GL_TEXTURE_GEN_S);
     glDisable(GL_TEXTURE_GEN_T);
     for (i = 5; i >= 0; i--) {
       glBegin(GL_QUADS);
       glNormal3fv(&n[i][0]);
       glTexCoord2f(0.0, 0.0);
       glVertex3fv(&v[faces[i][0]][0]);
       glTexCoord2f(0.0, 1.0);
       glVertex3fv(&v[faces[i][1]][0]);
       glTexCoord2f(1.0, 1.0);
       glVertex3fv(&v[faces[i][2]][0]);
       glTexCoord2f(1.0, 0.0);
       glVertex3fv(&v[faces[i][3]][0]);
       glEnd();
       }
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
    }
  else {
     for (i = 5; i >= 0; i--) {
       glBegin(GL_QUADS);
       glNormal3fv(&n[i][0]);
       glVertex3fv(&v[faces[i][0]][0]);
       glVertex3fv(&v[faces[i][1]][0]);
       glVertex3fv(&v[faces[i][2]][0]);
       glVertex3fv(&v[faces[i][3]][0]);
       glEnd();
       }
     }
     glPopMatrix();
}

/* helper function to draw a sphere. This routine makes
   use of the glu library */

void sphere(double radius, double x, double y,
              double z, int gen)
{
   GLUquadricObj *qobj;
   glPushMatrix();
   glTranslatef(x, y, z);
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

  /* use the glu texture coordinates if texcoord ="auto" */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
     }
   gluSphere(qobj, radius, 15, 10);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
     }
   glPopMatrix();
}


/* helper function to draw cylinders. makes use of the
   glu library */

void cylinder(double radius1, double radius2, double height,
              double x,  double y, double z, int gen)
{
   GLUquadricObj *qobj;

   /* translate to the specified x,y, and z */
   glPushMatrix();
   glTranslatef(x, y, z);
   glRotated(300.0, 1.0, 0.0, 0.0); /* is this really needed */
   qobj = gluNewQuadric();

   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

  /* if needed generate texture coordinates */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
     }
  /* draw the cylinder */
   gluCylinder(qobj, radius1, radius2, height, 15, 5);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
     }
   glPopMatrix();

}

/* routine to draw a disk. specifing angle1 and
    angle2, give a partial disk */

void disk(double radius1, double radius2, double angle1, double angle2,
          double x, double y, double z, int gen)
{
   GLUquadricObj *qobj;

   /* translate to the given x, y, z */
   glPushMatrix();
   glTranslatef(x, y, z);

   /* create the glu quadric */
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* generate texture coordinate if needed. */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }

   /* draw a disk */
   gluPartialDisk(qobj, radius1, radius2, 15, 5,
                  angle1, angle2);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}

/* other helper functions */
  	
/* pop a matrix from either the projection or
   the modelview matrix stack */
int popmatrix()
{
   int params1, params2;

  /* determine what is the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {

      /* check the stack depth. return failed if the
          matrix stack is one */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 > 1)
         glPopMatrix();
      else
	    return Failed;
      }

      /* we must be the Modelview stack */
   else {
      /* check to see if there is more than one
          matrix on the stack. if not return Failed */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
	 if (params2 > 1)
	    glPopMatrix();
    	 else
	    return Failed;
      }
   return Succeeded;
}

/* push a matrix onto the current stack -- that is
   either the modelview of projection matrix stack */
int pushmatrix()
{
   int params1, params2;

   /* determine the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. If there is already 2
       * matrices on the stack return Failed
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 < 2)
         glPushMatrix();
      else
	 return Failed;
      }

     /* must be the Modelview matrix stack */
   else {

       /* if the stack depth is greater than 32,
          return Failed */
       glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
       if (params2 < 32)
          glPushMatrix();	
       else
          return Failed;
        }
   return Succeeded;
}


/* functions needed to implement redrawing of windows */

/*
 * redraws a opengl window by traversing the specifed list
 */
int redraw3D(wbp w)
{
   GLfloat deflt_ambient[4] = {0.2, 0.2, 0.2, 1.0};
   GLfloat deflt_diffuse[4] = {0.8, 0.8, 0.8, 1.0};
   GLfloat deflt_emission[4] = {0.0, 0.0, 0.0, 1.0};
   GLfloat deflt_specular[4] = {0.0, 0.0, 0.0, 1.0};

   /*
    * reset the defaults for those objects that used them
    */
   glClear(GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_MODELVIEW);
   glPushMatrix();
   glLoadIdentity();

   glMaterialfv(GL_FRONT, GL_AMBIENT, deflt_ambient);
   glMaterialfv(GL_FRONT, GL_DIFFUSE, deflt_diffuse);
   glMaterialfv(GL_FRONT, GL_SPECULAR, deflt_specular);
   glMaterialfv(GL_FRONT, GL_EMISSION, deflt_emission);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);

   setlinewidth(w, 1);
   glLineWidth(1.0);
   w->context->dim = 3;

   if (!w->context->autogen) {
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      w->context->autogen = 1;
      }
   if (w->context->texmode) {
      glDisable(GL_TEXTURE_2D);
      w->context->texmode = 0;
      }

   if (w->window->flist)
      if (traversefunctionlist(w) == Failed)
         return Failed;
   glPopMatrix();
   glXSwapBuffers(w->window->display->display, w->window->win);
   return Succeeded;
}

/*
 * traverse the given list and looked to the element in given by position
 */
int c_traverse(struct b_list *hp, struct descrip * res, int position)
{
   register word i;
   register struct b_lelem *bp;
   int j, used;

   /*
    * Fail if the list is empty.
    */
   if (hp->size <= 0)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < position; j++){
      if (used <= 1){
	 bp->listprev = (union block *) hp;
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 i++;
	 used--;
         }
      }
   *res = bp->lslots[i];
   return 1;
}

/* traverse the list of functions and redraw the scene */
int traversefunctionlist(wbp w)
{
   struct descrip flist, fname;
   struct descrip var1, var2, var3, var4, var5, var6, var7;
   struct b_list *funclist;
   struct b_list *list = w->window->flist;
   wcp wc = w->context;
   double x, y, z, r1, r2, h, a1, a2;
   double *v, v2[256];
   int i, j, dim, num;
   int elements = list->size;
   tended char *temp;
   tended struct b_record *rp;

   /*
    * The ith element of the list is a list with information
    * about the function call made on the window.
    */
   for (i=0; i< elements; i++) {
      c_traverse(list, &flist, i);
      if (flist.dword == D_Record) {
	 rp = (struct b_record *)BlkLoc(flist);
	 if (rp->recdesc == BlkLoc(gl_torus)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], r1)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[5], r2)) goto free_v_and_fail;
	    torus(r1, r2, x, y, z, (wc->texmode ? wc->autogen : 0));
	    }
	 else if (rp->recdesc == BlkLoc(gl_cube)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], r1)) goto free_v_and_fail;
	    cube(r1, x, y, z, (wc->texmode ? wc->autogen : 0));
	    }
	 else if (rp->recdesc == BlkLoc(gl_sphere)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], r1)) goto free_v_and_fail;
	    sphere(r1, x, y, z, (wc->texmode ? wc->autogen : 0));
	    }
	 else if (rp->recdesc == BlkLoc(gl_cylinder)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], h))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[5], r1)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[6], r2)) goto free_v_and_fail;
	    cylinder(r1,r2,h,x,y,z, (wc->texmode ? wc->autogen : 0));
	    }
	 else if (rp->recdesc == BlkLoc(gl_disk)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], r1)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[5], r2)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[6], a1)) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[7], a2)) goto free_v_and_fail;
	    disk(r1, r2, a1, a2, x, y, z, (wc->texmode ? wc->autogen : 0));
	    }
	 else if (rp->recdesc == BlkLoc(gl_rotate)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], r1)) goto free_v_and_fail;
	    glRotated(r1, x, y, z);
	    }
	 else if (rp->recdesc == BlkLoc(gl_translate)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    glTranslated(x, y, z);
	    }
	 else if (rp->recdesc == BlkLoc(gl_scale)) {
	    if (!cnv:C_double(rp->fields[1], x))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[2], y))  goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], z))  goto free_v_and_fail;
	    glScaled(x, y, z);
	    }
	 else if (rp->recdesc == BlkLoc(gl_popmatrix)) {
	    popmatrix();
	    }
	 else if (rp->recdesc == BlkLoc(gl_pushmatrix)) {
	    pushmatrix();
	    }
	 else if (rp->recdesc == BlkLoc(gl_identity)) {
	    glLoadIdentity();
	    }
	 else if (rp->recdesc == BlkLoc(gl_matrixmode)) {
	    if (!cnv:C_string(rp->fields[1], temp)) goto free_v_and_fail;
	    if (!strcmp("modelview", temp)) glMatrixMode(GL_MODELVIEW);
	    if (!strcmp("projection", temp)) glMatrixMode(GL_PROJECTION);
	    }
	 else if (rp->recdesc == BlkLoc(gl_texture)) {
	    /*
	     * lookup the name of the texture and bind it
             * the objects using glBindTexture()
	     */
	    if (!cnv:C_integer(rp->fields[1], num)) goto free_v_and_fail;
	    glBindTexture(GL_TEXTURE_2D, wc->texName[num]);
	    }

	 else return Failed;
	 continue;
	 }
      if (flist.dword == D_List) {
	 funclist = (struct b_list*)flist.vword.bptr;
   	 c_traverse (funclist, &fname, 0);
         }
      else return Failed;

      if (funclist->size-1 > 256) {
	 v = calloc(funclist->size, sizeof (double));
	 if (v == NULL) return Error;
	 }
      else v = v2;

      /* Fg() or WAttrib("fg=...") */
      if (!strcmp(fname.vword.sptr, "Fg")) {
	 if(!determinematerial(funclist)) {
free_v_and_fail:
	    if (v != v2) free(v);
	    return Failed;
	    }
         }

      /* WAttrib("dim=...") */
      else if(!strcmp(fname.vword.sptr, "dim")) {
	 c_traverse(funclist, &var1, 1);
    	 cnv:C_integer(var1, dim);
         wc->dim = dim;
         }

      /* WAttrib("linewidth=...") */
      else if(!strcmp(fname.vword.sptr, "linewidth")) {
         c_traverse(funclist, &var1, 1);
         cnv:C_integer(var1, num);
	 setlinewidth(w, num);
         glLineWidth(num);
      }
      /* WAttrib("texmode=...") */
      else if(!strcmp(fname.vword.sptr, "texmode")) {
         c_traverse(funclist, &var1, 1);
         cnv:C_integer(var1, num);

         /* texturing is on */
         if (num) {
            if (wc->texmode == 0)
	       glEnable(GL_TEXTURE_2D);
            wc->texmode = 1;
           }
         /* texturing is off */
         else {
            if (wc->texmode == 1)
               glDisable(GL_TEXTURE_2D);
            wc->texmode = 0;
           }
       }

      /* Texcoord() or WAttrib("texcoord=...") */
      else if(!strcmp(fname.vword.sptr, "Texcoord")) {
         /* first element tells us if opengl generates
            texture coordinates */
         c_traverse(funclist, &var1, 1);
         cnv:C_integer(var1, num);
         if (num) {
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            wc->autogen = 1;
            }

        /* there is a list of texture coordinates to use */
         else {
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
            wc->autogen = 0;

           /* traverse the list and set the texture
                 coordinates */
            for (j = 0; j < (funclist->size)-2; j++) {
               c_traverse(funclist, &var2, j+2);
               cnv:C_double(var2, wc->texcoords[j]);
              }
            wc->numtexcoords = j;
           }
         }


      /* DrawPolygon() */
      else if(!strcmp(fname.vword.sptr, "DrawPolygon")) {
         /* element in position 1 is the dim attribute */
         for (j = 0; j < (funclist->size)-1; j++) {
            c_traverse(funclist, &var2, j+1);
            cnv:C_double(var2, v[j]);
         }

        /* call drawpoly with GL_LINE_LOOP to get a polygon */
        drawpoly(w, v, (funclist->size)-1, GL_LINE_LOOP, wc->dim);
        }

      /* FillPolygon() */
      else if(!strcmp(fname.vword.sptr, "FillPolygon")) {
	 for (j = 0; j < (funclist->size)-1; j++) {
            c_traverse(funclist, &var2, j+1);
            cnv:C_double(var2, v[j]);
            }
	  /* drawpoly with GL_POLYGON will give filled polygons */
         drawpoly(w, v, (funclist->size)-1, GL_POLYGON, wc->dim);
        }

      /* DrawSegment() */
       else if(!strcmp(fname.vword.sptr, "DrawSegment")) {
          for (j = 0; j < (funclist->size)-1; j++) {
             c_traverse(funclist, &var2, j+1);
             cnv:C_double(var2, v[j]);
             }
          drawpoly(w, v, (funclist->size)-1, GL_LINES, wc->dim);
          }

       /* DrawLine() */
       else if(!strcmp(fname.vword.sptr, "DrawLine")) {
          for (j = 0; j < (funclist->size)-1; j++) {
             c_traverse(funclist, &var2, j+1);
             cnv:C_double(var2, v[j]);
           }
          drawpoly(w, v, (funclist->size)-1, GL_LINE_STRIP, wc->dim);
         }

       /* DrawPoint() */
       else if(!strcmp(fname.vword.sptr, "DrawPoint")) {
          for (j = 0; j < (funclist->size)-1; j++) {
             c_traverse(funclist, &var2, j+1);
             cnv:C_double(var2, v[j]);
            }
          drawpoly(w, v, (funclist->size)-1, GL_POINTS, wc->dim);
         }



     if (v!=v2) free(v);
     }
   return Succeeded;
}

/* traverse the given list and set material properties */
int determinematerial(struct b_list *list)
{
   struct descrip mat, var1, var2, var3;
   int r, g, b, i;
   tended char *temp;
   GLfloat color[4];

   /* convert the elements of the list to the
    * appropriate type. The first element is a string
    * which give the material property. the last three
    * elements should be the r, g, b value of that
    * property */

   c_traverse( list, &mat, 1);
   if (!cnv:C_string(mat, temp))
	 return Failed;
   c_traverse( list, &var1, 2);
   if (!cnv:C_integer(var1, r))
	 return Failed;
   c_traverse( list, &var2, 3);
   if (!cnv:C_integer(var2, g))
	return Failed;
   c_traverse( list, &var3, 4);
   if (!cnv:C_integer(var3, b))
	 return Failed;

   /* must convert from an integer between 0 and 65535
      to a float between 0.0 and 0.0 */
   color[0] = r/(GLfloat)65535;
   color[1] = g/(GLfloat)65535;
   color[2] = b/(GLfloat)65535;
   color[3] = 1.0;  /* alpha value */

  /* set the material property */
   if (!strcmp(temp, "ambient"))
	glMaterialfv(GL_FRONT, GL_AMBIENT, color);
   if (!strcmp(temp, "diffuse"))
	glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
   if (!strcmp(temp, "specular"))
	glMaterialfv(GL_FRONT, GL_SPECULAR, color);
   if (!strcmp(temp, "emission"))
	glMaterialfv(GL_FRONT, GL_EMISSION, color);
   if(!strcmp(temp, "shininess"))
      glMateriali(GL_FRONT, GL_SHININESS, r);

  /* if it is not a material property, change the
     current forground color to r, g, b */
   if (!strcmp(temp, "none"))
	glColor3f(color[0], color[1], color[2]);

   return Succeeded;
}

/* routines to return an attribute vale */

/* returns the current value of the specified light */
int getlight(int light, char* buf)
{
   GLfloat pos[4];
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];

   glGetLightfv(GL_LIGHT0 + light, GL_POSITION, pos);
   glGetLightfv(GL_LIGHT0 + light, GL_AMBIENT, amb);
   glGetLightfv(GL_LIGHT0 + light, GL_DIFFUSE, diff);
   glGetLightfv(GL_LIGHT0 + light, GL_SPECULAR, spec);

   sprintf(buf, "position %.2f,%.2f,%.2f; ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f",  pos[0], pos[1], pos[2], amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2]);
   return Succeeded;
}

/* returns the current material properties */
int getmaterials(char* buf)
{
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];
   GLfloat emis[4];
   GLfloat shine;

   /* query opengl for current values */
   glGetMaterialfv(GL_FRONT, GL_EMISSION, emis);
   glGetMaterialfv(GL_FRONT, GL_AMBIENT, amb);
   glGetMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
   glGetMaterialfv(GL_FRONT, GL_SPECULAR, spec);
   glGetMaterialfv(GL_FRONT, GL_SHININESS, &shine);

   sprintf(buf, "ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f; emission %.2f,%.2f,%.2f; shininess %.2f", amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2], emis[0], emis[1], emis[2], shine);
   return Succeeded;
}

/* get the user specified texture coordinates */
int gettexcoords(wbp w, char *buf)
{
   int i;
   wcp wc = w->context;
   sprintf(buf, "%.f", wc->texcoords[0]);
   for (i = 1; i < wc->numtexcoords; i++) {
      sprintf(buf, "%s,%.3f", buf, wc->texcoords[i]);
     }
   return Succeeded;

}

/* routines to set attribute values */

/* set the linewidth */
int setlinewidth3D(wbp w, LONG linewid)
{

   struct descrip f, funcname, width;
   struct b_list *func;

   if (linewid < 0) return Error;
   setlinewidth(w, linewid);
   glLineWidth(linewid);

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block *) func;
   MakeStr("linewidth", 9, &funcname);
   c_put(&f, &funcname);
   MakeInt(linewid, &width);
   c_put(&f, &width);
   c_put(&(w->window->funclist), &f);

   return Succeeded;
}

/* given a string of semi-colon seperated material
 * properties (ambient, diffuse, specular, emission,
 * and shininess), parse the string and set material
 * properties
 */
int setmaterials(wbp w, char* s)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int k, j, i = 0;
   long rd, gr, bl;
   GLfloat shine;
   GLfloat color[4];
   char sbuf1[MaxCvtLen];
   char sbuf2[MaxCvtLen];
   struct descrip f, funcname, material, r, b,g;
   struct b_list *func;

   while(s[i]) {
      j = 0;
      k = 0;

    /* create a list element for each material property */
      if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
      f.dword = D_List;
      f.vword.bptr = (union block *) func;
      MakeStr("Fg", 2, &funcname);
      c_put(&f, &funcname);

     /* parse the string to determine the material
        property and its value */
      while(isspace(s[i])) i++;
      while(s[i] && isalpha(s[i])) {
         sbuf1[k] = s[i];
         i++; k++;
	   }
      sbuf1[k] = '\0';

     /* ambient */
      if (!strcmp(sbuf1, "ambient")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
            sbuf2[j] = s[i];
            i++; j++;
	      }
         sbuf2[j] = '\0';
         /* determine the icon color */
         if(parsecolor(w,sbuf2, &rd, &gr, &bl)== Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = 1.0; /* alpha value */

         /* set the property */
         glMaterialfv(GL_FRONT, GL_AMBIENT, color);
         MakeStr("ambient", 7, &material);
         c_put(&f, &material);
	   }
     /* diffuse */
 	else if(!strcmp(sbuf1, "diffuse")) {
	   while(isspace(s[i])) i++;
  	   if(s[i] == '\0') return Failed;
	   while(s[i] != '\0' && s[i] != ';') {
	      sbuf2[j] = s[i];
	      i++; j++;
	      }
	   sbuf2[j] = '\0';
         /* determine the appropriate icon color */
	   if(parsecolor(w,sbuf2, &rd, &gr, &bl)==Failed)
            return Failed;
         /* convert values to floats between 0.0 and 1.0 */
	   color[0] = rd/(GLfloat)65535;
	   color[1] = gr/(GLfloat)65535;
	   color[2] = bl/(GLfloat)65535;
	   color[3] = 1.0;

         /* set the property */
	   glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
	   MakeStr("diffuse", 7, &material);
	   c_put(&f, &material);
	   }

      /* specular */
      else if (!strcmp(sbuf1, "specular")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
	      sbuf2[j] = s[i];
	      i++; j++;
	      }
	   sbuf2[j] = '\0';
         /* determine the icon color and convert to a
             float between 0.0 and 1.0 */
         if(parsecolor(w, sbuf2, &rd, &gr,&bl)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = 1.0;

         /* set the property */
         glMaterialfv(GL_FRONT, GL_SPECULAR, color);
         MakeStr("specular", 8, &material);	
         c_put(&f, &material);
	   }

      /* shininess */
      else if(!strcmp(sbuf1, "shininess")) {
	   while(isspace(s[i])) i++;
	   if(s[i] == '\0') return Failed;
 	   while(s[i] != '\0' && s[i] != ';') {
	      sbuf2[j] = s[i];
	      i++; j++;
	      }
	   sbuf2[j] = '\0';
        /* shininess is a single value */
  	   shine = atof(sbuf2);
        /* set shininess value */
    	   glMaterialf(GL_FRONT, GL_SHININESS, shine);
         MakeStr("shininess", 9, &material);		
	   c_put(&f, &material);
    	   rd = shine;
	   gr = 0;
   	   bl = 0;
	  }
      /* emission */
      else if(!strcmp(sbuf1, "emission")) {
	   while(isspace(s[i])) i++;
   	   if(s[i] == '\0') return Failed;
	   while(s[i] != '\0' && s[i] != ';') {
	      sbuf2[j] = s[i];
	      i++; j++;
	      }
	   sbuf2[j] = '\0';

        /* determine the r, g, b value and convert them
           to floats between 0.0 and 1.0 */
    	   if(parsecolor(w, sbuf2, &rd, &gr,&bl)==Failed)
    	      return Failed;
	   color[0] = rd/(GLfloat)65535;
	   color[1] = gr/(GLfloat)65535;
	   color[2] = bl/(GLfloat)65535;
	   color[3] = 1.0;

       /* set the emission color */
	   glMaterialfv(GL_FRONT, GL_EMISSION, color);
         MakeStr("emission", 8, &material);
	   c_put(&f, &material);
        }

     /* otherwise set the current forground color */
      else {
	   if(setfg(w, s) == Failed) return Failed;
	   rd = RED(w->context->fg);
	   gr = GREEN(w->context->fg);
   	   bl = BLUE(w->context->fg);
 	   glColor3f(rd/(GLfloat)255,
                	 gr/(GLfloat)255, bl/(GLfloat)255);
         MakeStr("none", 4, &material);
	   c_put(&f, &material);
        }
      /* put material property values on the list */
      MakeInt(rd, &r);
      c_put(&f, &r);
      MakeInt(gr, &g);
      c_put(&f, &g);
      MakeInt(bl, &b);
      c_put(&f, &b);
      c_put(&(w->window->funclist), &f);

      /* fail if string is not in the correct format */
      if(s[i] != '\0' && s[i] != ';') return Failed;
      i++;
     }
   return Succeeded;
}


/* set the lighting properties (position, ambient,
   diffuse, specular, and "on" or "off")of a light */
int setlight(wbp w, char* s, int light)
{
   char* s2 = s;
   char s3[MaxCvtLen];
   GLboolean params;
   int i, j;
   GLfloat color[4];
   long rd, gr, bl;
   while(isspace(*s2)) s2++;

   /* turn on a light */
   if (!strncmp(s2, "on", 2)) {
      /* query opengl to see if it is already on */
      glGetBooleanv(light, &params);
      if (!params)
         glEnable(light);
      s2 = s2+2;
      if(*s2 != ',' && *s2 != '\0') return Failed;
      if(*s2 == ',') s2++;
      }
   /* turn off the light */
   if (!strncmp(s2, "off", 3)) {
      /* query opengl to make sure the light is not
          already off */
	 glGetBooleanv(light, &params);
	 if (params)
          glDisable(light);
       s2 = s2 + 3;
	 if(*s2 != ',' && *s2 != '\0') return Failed;
       if(*s2 == ',') s2++;
      }
   while(*s2 != '\0'){
      while(isspace(*s2)) s2++;

      /* set the ambient lighting values */
      if (!strncmp(s2, "ambient", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* determine the r, g, b values */
         if(parsecolor(w, s3, &rd, &gr, &bl) ==Failed)
	      return Failed;
         /* convert from an integer between 0 and
            65535 to a float between 0.0 and 1.0 */
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = 1.0;
         /* set the ambient light value */
         glLightfv(light, GL_AMBIENT, color);
         s2 = s2 + i;
	   if(*s2 != ';' && *s2 != '\0') return Failed;
	   if(*s2 != '\0') s2++;
         }
     /* set the diffuse lighting values */
	if (!strncmp(s2, "diffuse", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert the icon r, g, b values to floats
            between 0.0 and 1.0 */
         if(parsecolor(w, s3, &rd, &gr, &bl) == Failed)
	      return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = 1.0;
         /* set the diffuse value of the light */
         glLightfv(light, GL_DIFFUSE, color);
         s2 = s2 + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         }
      /* set the specular lighting values */
      if (!strncmp(s2, "specular", 8)) {
         s2 = s2 + 8;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert to appropriate values */
         if (parsecolor(w, s3, &rd, &gr, &bl)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = 1.0;
         glLightfv(light, GL_SPECULAR, color);
         s2 = s2 + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         }
      /* set the positon of the light */
	if (!strncmp(s2, "position", 8)) {
         s2 = s2 + 8;
	   for (j = 0; j < 2; j++) {
           while(isspace(*s2)) s2++;
           i = 0;
           if(*s2 == '\0') return Failed;
           while(s2[i] != '\0' && s2[i] != ',') {
              s3[i] = s2[i];
              i++;
              }
           s3[i] = '\0';
           color[j] = atof(s3);
           s2 = s2 + i;
           if(*s2 != ',') return Failed;
           s2++;
           }
         while(isspace(*s2)) s2++;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         color[2] = atof(s3);
         color[3] = 0.0;
         s2 = s2  + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         glLightfv(light, GL_POSITION, color);
         }
      }

      /* the lighting on the scene has changed, we must redraw the window */
      redraw3D(w);
      return Succeeded;
}

/* set the dim attribute */
int setdim(wbp w, char* s)
{
   struct descrip f, funcname;
   struct b_list *func;
   struct descrip d;
   int dim;

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("dim", 3, &funcname);
   c_put(&f, &funcname);

   dim = atoi(s);
   /* must be a value between 1 and 4 */
   if (dim < 1 || dim > 4)
      return Error;
   w->context->dim = dim;

   /* put the value of dim on the list of functions */
   MakeInt(dim, &d);
   c_put(&f, &d);
   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

/* set the texture mode, either on or off */
int settexmode(wbp w, char* s)
{
   struct descrip f, funcname;
   struct b_list *func;
   struct descrip mode;

    /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("texmode", 7, &funcname);
   c_put(&f, &funcname);

   /* turn textures on */
   if (!strcmp("on", s)) {
      if (w->context->texmode == 0)
         glEnable(GL_TEXTURE_2D);
      w->context->texmode = 1;
      MakeInt(1, &mode);
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
	}
   /* turn texture off */
   else if (!strcmp("off", s)) {
      if (w->context->texmode == 1)
         glDisable(GL_TEXTURE_2D);
      w->context->texmode = 0;
      MakeInt(0, &mode);
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
     }
   /* not on or off so generate and error */
   else
      return Error;
}

/* set texture coordinates */
int settexcoords(wbp w, char* s)
{
   char* s2 = s;
   char s3[MaxCvtLen];
   char s4[MaxCvtLen];
   int j, i =0;
   struct descrip f, funcname;
   struct b_list *func;
   struct descrip mode, val, test;

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("Texcoord", 8, &funcname);
   c_put(&f, &funcname);

   while(isspace(*s2)) s2++;

 /* check if we need to generate texture coordinates */
   if (!strcmp(s2, "auto")){
      w->context->autogen = 1;
      if (!glIsEnabled(GL_TEXTURE_GEN_S))
         glEnable(GL_TEXTURE_GEN_S);
      if (!glIsEnabled(GL_TEXTURE_GEN_T))
         glEnable(GL_TEXTURE_GEN_T);
      MakeInt(1, &mode);
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
     }

  /* otherwise a string of texture coordinate
     should be given */
   else if(isdigit(*s2)) {
      MakeInt(0, &mode);
      c_put(&f, &mode);
      j = w->context->numtexcoords = 0;
      w->context->autogen = 0;

      /* must turn of automatic texture generateion */
      if (glIsEnabled(GL_TEXTURE_GEN_S))
         glDisable(GL_TEXTURE_GEN_S);
      if (glIsEnabled(GL_TEXTURE_GEN_T))
         glDisable(GL_TEXTURE_GEN_T);
      /* parse string */
      while(*s2 != '\0') {
         while(*s2 != ',' && *s2 != '\0' ) {
            s3[i] = *s2;
            i++; s2++;
           }
         s3[i]='\0';
        /* create a list element for the coordinate */
         val.dword = strlen(s3);
         val.vword.sptr = strdup(s3);
         c_put(&f, &val);
         w->context->texcoords[j] = atof(s3);
         j++;
         s2++;
         i=0;
        }
      /* save the number of texture coordinates */
      w->context->numtexcoords = j;
      c_put(&(w->window->funclist), &f);
     }
   /* return an error for any other value */
   else return Error;	
}

/* set the eyepos attribute */
int seteyepos(wbp w, char *s)
{
   char *s2 =s;
   wcp wc = w->context;

   /* parse string */
   while (isspace(*s2)) s2++;

   /* get the x-coordinate of eyepos */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the y-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the z-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;

   gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	     wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);
   redraw3D(w);
   return Succeeded;
}

/* sets the eyedir attribute */
int seteyedir(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;
   /* find the x-coordinate of eyedir */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the y-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the z-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* if there are more entries return an error */
   if (*s2) return Error;
   gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	     wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);
   redraw3D(w);
   return Succeeded;
}

/* sets the eyeup attribute */
int seteyeup(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the x-coordinate of eyeyp */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the y-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the z-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	     wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);
   redraw3D(w);
   return Succeeded;
}


/* set the eye attribute */
/* this set the eyeup, eyedir, and the eyepos attributes */
int seteye(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the eyepos attribute */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the eyedir attribute */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the eyeup attribute */
   if (*s2++ != ',') return Error;
   while (isspace(*s2)) s2++;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	     wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);
   redraw3D(w);
   return Succeeded;

}


/* set a texture */
int settexture(wbp w, char* str)
{
   char* s;
   char filename[MaxFileName +1];
   int i, nfields;
   struct descrip f;
   struct descrip d;
   tended struct b_record *rp;
   static dptr constr;

   if (!constr &&  !(constr = rec_structor3d("gl_texture")))
      syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * create a record of the graphical object and its parameters
    */
   if (!(rp = alcrecd(nfields, BlkLoc(*constr))))
      return Failed;
   f.dword = D_Record;
   f.vword.bptr = (union block *)rp;
   MakeStr("Texture", 7, &(rp->fields[0])); 

   /* to redraw the window we must keep track of the
      texture name assigned to it by opengl. This name
      is stored in w->context->texName[w->context->ntextures].
      So by remembering w->context->ntextures we can
      recover the name of the texture */
   MakeInt(w->context->ntextures, &(rp->fields[1]));
   c_put(&(w->window->funclist), &f);
   glBindTexture(GL_TEXTURE_2D, w->context->texName[w->context->ntextures]);
   w->context->ntextures++;

   s=str;
   while(isspace(*s)) s++;
   while(isdigit(*s)) s++;
   while(isspace(*s)) s++;
   if (*s == ',')  /* must be an image string */
      i = imagestr(w, str);
   else  {  /* it is a file name */
      strncpy(filename, str, MaxFileName);
      filename[MaxFileName] = '\0';
      i = fileimage(w, filename);
      }
   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a icon image string into a useable
   opengl texture */
int imagestr(wbp w, char* str)
{
   struct palentry *e;
   int c, i, width, height, row, p;
   word nchars;
   unsigned char *t, *z, *s;

   /* Extract the Width and skip the following comma.*/

   s = str;
   z = s + strlen(str);		/* end+1 of string */
   width = 0;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   while (s < z && isdigit(*s))	/* scan number */
      width = 10 * width + *s++ - '0';
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (width == 0 || *s++ != ',') /* skip comma */
      return Failed;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (s >= z)			     /* if end of string */
	 return Failed;

   /* if the width is not a power of two fail */
   if(powertwo(width) > 0) return Failed;


 /* Check for a bilevel format */
   if ((c = *s) == '#' || c == '~') {
      s++;
      nchars = 0;
      for (t = s; t < z; t++)
         if (isxdigit(*t))
            nchars++;	         /* count hex digits */
         else if (*t != PCH1 && *t != PCH2)
            return Failed;	  /* illegal punctuation */
      if (nchars == 0)
         return Failed;
      row = (width + 3) / 4;	/* digits per row */
      if (nchars % row != 0)
         return Failed;
      height = nchars / row;
      if (powertwo(height) > 0)
         return Failed;
      i = bltex(w, width, height, c, s, (word)(z - s));
      if (i == Succeeded)
	   return Succeeded;
      else
	   return Failed;
      }
	

 /* Extract the palette name and skip its comma.*/
   c = *s++;		     /* save initial character */
   p = 0;
   while (s < z && isdigit(*s))    /* scan digits */
      p = 10 * p + *s++ - '0';
   while (s < z && *s == ' ')	  /* skip blanks */
	 s++;
   if (s >= z || p == 0 || *s++ != ',')/* skip comma */
      return Failed;
   if (c == 'g' && p >= 2 && p <= 256)	/* validate grayscale number */
      p = -p;
   else if (c != 'c' || p < 1 || p > 6)	/* validate color number */
      return Failed;

   /* Scan the image to see which colors are needed. */
   e = palsetup(p);
   if (e == NULL)
      return Failed;
   for (i = 0; i < 256; i++)
      e[i].used = 0;
   nchars = 0;
   for (t = s; t < z; t++) {
      c = *t;
      e[c].used = 1;
      if (e[c].valid || e[c].transpt)
         nchars++;	/* valid color, or transparent */
      else if (c != PCH1 && c != PCH2)
         return Failed;
      }
   if (nchars == 0)
      return Failed;			/* empty image */
   if (nchars % width != 0){
      return Failed;			/* not rectangular */
      }

   /* Create the texture */

   height = nchars/width;
   /* if the height is not a power of two
      return failed */
   if (powertwo(height) > 0)
      return Failed;
   i = textureimg(w, width, height, e, s, (word)(z-s));
   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a file into a opengl texture */
int fileimage(wbp w, char* filename)
{
   int r, i, nwidth, nheight;
   int status;
   struct imgdata im;
   r = readGIF(filename, 0, &im);

   /* a gif file */
   if (r == Succeeded){
      /* check to make sure the image is a power of two */
      nwidth = powertwo(im.width);
      nheight = powertwo(im.height);
      if (nwidth == 0 && nheight == 0)
         i = textureimg(w, im.width, im.height, im.paltbl, im.data, (word)im.width*(word)im.height);
      else
         return Failed;

   /* we need to handle other cases beside gif...
	 what are those cases ? ... look at ReadImage */
     }
   /* not a gif file */
   else{
     r = readimage(w, filename, 0, 0, &status);

    }
   if (i == Succeeded)
	 return Succeeded;
   else
      return Failed;
}


/* converts the icon representation of an image into
   a format accepted by opengl */
int textureimg(wbp w, int width, int height,
               struct palentry *e, unsigned char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int c, v, i;
   unsigned int ix, iy;
   GLubyte tex[height][width][3];

   ix = 0; iy = height-1;
   /* convert the string s into an array that can be used
      by opengl as a texture */
   /* we must start at height=height-1 and width=0 to make this
      look right */

   while (len--) {
      c = *s++;
      v = e[c].valid;
      if (v) {
         /* r,g,b componet must be between 0 and 256 */
	   tex[iy][ix][0] = e[c].clr.red/256;
	   tex[iy][ix][1] = e[c].clr.green/256;
 	   tex[iy][ix][2] = e[c].clr.blue/256;
        }
      if (v || e[c].transpt) {		/* advance if valid or transparent */
	   if (e[c].transpt) { /* if transparent use background color */
            tex[iy][ix][0] = (GLint)RED(w->context->bg);
            tex[iy][ix][1] = (GLint)GREEN(w->context->bg);
            tex[iy][ix][2] = (GLint)BLUE(w->context->bg);
         }
         if (++ix >= width) {
            ix = 0;	
	  	/* reset for new row */
            iy--;
            }
         }
      }
      if (ix > 0)	/* pad final row if incomplete */
         while (ix < width) {
            tex[iy][ix][0] = (GLint)RED(w->context->bg);
            tex[iy][ix][1] = (GLint)GREEN(w->context->bg);
            tex[iy][ix][2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
      /* set the texture */
      i = texture(width, height, tex);
      if (i == Succeeded)
         return Succeeded;
      else
         return Failed;
}

/* convert a bi-level image into an opengl texture */
int bltex(wbp w, int width, int height, int ch, char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   unsigned int m, msk1, c, ix, iy;
   int r, b, g, i;
   GLubyte tex[height][width][3];
   m = width % 4;
   if (m == 0)
      msk1 = 8;
   else               /* mask for first byte of row */
      msk1 = 1 << (m - 1);		
   ix = width;
   iy = height-1;
   m = msk1;
   while (len--) {
      /* if hexadecimal character */
      if (isxdigit(c = *s++)) {		
         if (!isdigit(c))		
            c += 9;
         while (m > 0) {
	    --ix;
	    if (c & m){
	       r = (GLint)RED(w->context->fg);
	       g = (GLint)GREEN(w->context->fg);
 	       b = (GLint)BLUE(w->context->fg);
	       tex[iy][ix][0] = r;
	       tex[iy][ix][1] = g;
	       tex[iy][ix][2] = b;
            }
	    else if (ch != TCH1) {
    	       r = (GLint)RED(w->context->bg);
	       g = (GLint)GREEN(w->context->bg);
  	       b = (GLint)BLUE(w->context->bg);
	       tex[iy][ix][0] = r;
	       tex[iy][ix][1] = g;
	       tex[iy][ix][2] = b;
            }
            m >>= 1;
          }
         if (ix == 0) {	    /* if end of row */
            ix = width;
            iy--;
            m = msk1;
            }
         else
            m = 8;
         }
      }
   if (ix > 0)				/* pad final row if incomplete */
      while (ix < width){
         r = (GLint)RED(w->context->bg);
         g = (GLint)GREEN(w->context->bg);
         b = (GLint)BLUE(w->context->bg);
         tex[iy][ix][0] = r;
         tex[iy][ix][1] = g;
         tex[iy][ix][2] = b;
         ix++;
       }

   i = texture(width, height, tex);
   if (i == Succeeded)
	return Succeeded;
   else
     return Failed;
}


/* check if a number is a power of two */
int powertwo(int a)
{
   int p = 1;
   while(p < a){
      p = p*2;
     }
   if (a == p) return 0;
   else return p;
}

/* convert a 2D window into a texture */
int texwindow2D(wbp w)
{
   struct imgmem imem;
   int i, j, r;
   long rv;
   wsp ws = w->window;
   char strout[50];
   char *s2;
   GLubyte tex[ws->height][ws->width][3];

   imem.x = 0;
   imem.y = 0;
   imem.width = ws->width;
   imem.height = ws->height;
   /* call get pixel to get pixel information */
   if (getpixel_init(w, &imem) == Failed)
      return Failed;
   for(j=0; j < ws->height; j++)
	for(i=0; i < ws->width; i++) {
 	   if (getpixel(w, i, j, &rv, strout, &imem) == Failed)
            return Failed;
	   s2 = strout;
         /* parse string to get pixel values */
	   while(isspace(*s2)) s2++;
   	   tex[ws->height-j-1][i][0] = atoi(s2)/256;
  	   while(isdigit(*s2)) s2++;
   	   s2++;
   	   tex[ws->height-j-1][i][1] = atoi(s2)/256;
   	   while (isdigit(*s2)) s2++;
  	   s2++;
    	   tex[ws->height-j-1][i][2] = atoi(s2)/256;
        }

   /* apply the texture */
   r = texture(ws->width, ws->height, tex);
   if (r == Succeeded)
	return Succeeded;
   else
     return Failed;
}

/* use another opengl window as a texture source */
int texwindow3D(wbp w1, wbp w2)
{
   wsp ws = w2->window;
   int width = ws->width;
   int height = ws->height;
   int i;
   GLubyte tex[height][width][3];
   if (powertwo(width) > 0)
       return Failed;
   if (powertwo(height) > 0)
       return Failed;

   /* change the current context to w2's context */
#ifdef XWindows
   glXMakeCurrent(w2->window->display->display, w2->window->win, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   glXMakeCurrent(w1->window->display->display, w1->window->win, w1->context->ctx);
#endif					/* XWindows */
#ifdef MSWindows
{
HDC stddc = CreateWinDC(w1);
   wglMakeCurrent(stddc, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   wglMakeCurrent(stddc, w1->context->ctx);
ReleaseDC(w1->window->iconwin, stddc);
}
#endif					/* MSWindows */
    i = texture(width, height, tex);
    if (i == Succeeded)
       return Succeeded;
    else
       return Failed;
}

/* apply a texture to a scene */
int texture(int width, int height, GLubyte ***tex)
{
   /* make sure texture is a power of two */
   if (powertwo(width) > 0)
       return Failed;
   if (powertwo(height) > 0)
       return Failed;
   glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, tex);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
   return Succeeded;
}


/*
 * For each 3D graphics operation, there is a descriptor that
 * holds the record constructor for that type of primitive.
 * The first field is named "name"; for > 1 field, their names are in an array.
 * If fields > 2, then fields 2-4 are named "x", "y", "z"
 */
struct descrip gl_torus = {D_Null};
struct descrip gl_cube = {D_Null};
struct descrip gl_sphere = {D_Null};
struct descrip gl_cylinder = {D_Null};
struct descrip gl_disk = {D_Null};
struct descrip gl_rotate = {D_Null};
struct descrip gl_translate = {D_Null};
struct descrip gl_scale = {D_Null};
struct descrip gl_popmatrix = {D_Null};
struct descrip gl_pushmatrix = {D_Null};
struct descrip gl_identity = {D_Null};
struct descrip gl_matrixmode = {D_Null};
struct descrip gl_texture = {D_Null};

char * gl_torus_fields[] = {"radius1","radius2"};
char * gl_cube_fields[] = {"length"};
char * gl_sphere_fields[] = {"radius"};
char * gl_cylinder_fields[] ={"height","radius1","radius2"};
char * gl_disk_fields[] = {"radius1","radius2", "angle1","angle2"};
char * gl_rotate_fields[] = {"angle"};
char * gl_matrixmode_fields[] = {"mode"};
char * gl_texture_fields[] = {"texture_handle"};

dptr rec_structinate(dptr dp, char *name, int nfields, char *a[])
{
   int i;
   struct descrip s;
   struct descrip fields[16];
   if (is:null(*dp)) {
      AsgnCStr(s, name);
      AsgnCStr(fields[0], "name");
      if (nfields > 2) {
         AsgnCStr(fields[1], "x");
         AsgnCStr(fields[2], "y");
         AsgnCStr(fields[3], "z");
         for(i=4; i < nfields; i++)
            AsgnCStr(fields[i], a[i-4]);
         }
      else if (nfields == 2)
         AsgnCStr(fields[1], a[0]);
      dp->dword = D_Proc;
      dp->vword.bptr = (union block *)dynrecord(&s, fields, nfields);
      }
   return dp;
}

dptr rec_structor3d(char *name)
{
#ifdef Graphics3D
   if (!strcmp(name, "gl_torus"))
      return rec_structinate(&gl_torus, "gl_torus", 5, gl_torus_fields);
   else if (!strcmp(name, "gl_cube"))
      return rec_structinate(&gl_cube, "gl_cube", 5, gl_cube_fields);
   else if (!strcmp(name, "gl_sphere"))
      return rec_structinate(&gl_sphere, "gl_sphere", 5, gl_sphere_fields);
   else if (!strcmp(name, "gl_cylinder"))
      return rec_structinate(&gl_cylinder, "gl_cylinder",7,gl_cylinder_fields);
   else if (!strcmp(name, "gl_disk"))
      return rec_structinate(&gl_disk, "gl_disk", 7, gl_disk_fields);
   else if (!strcmp(name, "gl_rotate"))
      return rec_structinate(&gl_rotate, "gl_rotate", 5, gl_rotate_fields);
   else if (!strcmp(name, "gl_translate"))
      return rec_structinate(&gl_translate, "gl_translate", 4, NULL);
   else if (!strcmp(name, "gl_scale"))
      return rec_structinate(&gl_scale, "gl_scale", 4, NULL);
   else if (!strcmp(name, "gl_popmatrix"))
      return rec_structinate(&gl_popmatrix, "gl_popmatrix", 1, NULL);
   else if (!strcmp(name, "gl_pushmatrix"))
      return rec_structinate(&gl_pushmatrix, "gl_pushmatrix", 1, NULL);
   else if (!strcmp(name, "gl_identity"))
      return rec_structinate(&gl_identity, "gl_identity", 1, NULL);
   else if (!strcmp(name, "gl_matrixmode"))
      return rec_structinate(&gl_matrixmode, "gl_matrixmode",
				2, gl_matrixmode_fields);
   else if (!strcmp(name, "gl_texture"))
      return rec_structinate(&gl_texture, "gl_texture", 2, gl_texture_fields);
#endif					/* Graphics3D */

   return 0;
}
