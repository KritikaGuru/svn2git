/*
 * rwin3d.ri - platform-independent 3D facilities code
 *
 * The analogy in 2D is the rwindow.r file.  As much of ropengl.ri as possible
 * should be moved here and used in all 3D implementations.
 */
#ifdef Graphics3D

/*
 * For each 3D graphics operation, there is a descriptor that
 * holds the record constructor for that type of primitive.
 * The first field is named "name"; for > 1 field, their names are in
 * an array. If fields > 2, then fields 2-4 are named "x", "y", "z".
 */
struct descrip gl_torus = {D_Null};
struct descrip gl_cube = {D_Null};
struct descrip gl_sphere = {D_Null};
struct descrip gl_cylinder = {D_Null};
struct descrip gl_disk = {D_Null};
struct descrip gl_rotate = {D_Null};
struct descrip gl_translate = {D_Null};
struct descrip gl_scale = {D_Null};
struct descrip gl_popmatrix = {D_Null};
struct descrip gl_pushmatrix = {D_Null};
struct descrip gl_identity = {D_Null};
struct descrip gl_matrixmode = {D_Null};
struct descrip gl_meshmode = {D_Null};
struct descrip gl_texture = {D_Null};
struct descrip gl_font3d = {D_Null};
struct descrip gl_drawstring3d = {D_Null};
struct descrip gl_mark = {D_Null};
struct descrip gl_endmark = {D_Null};

char * gl_torus_fields[] = {"radius1","radius2"};
char * gl_cube_fields[] = {"length"};
char * gl_sphere_fields[] = {"radius"};
char * gl_cylinder_fields[] ={"height","radius1","radius2"};
char * gl_disk_fields[] = {"radius1","radius2", "angle1","angle2"};
char * gl_rotate_fields[] = {"angle"};
char * gl_matrixmode_fields[] = {"mode"};
char * gl_meshmode_fields[] = {"mode"};
char * gl_texture_fields[] = {"texture_handle", "window_binding"};
char * gl_font_fields[] = {"font_ptr"};
char * gl_drawstring3d_fields[] = {"str"};
char * gl_mark_fields[] = {"section_name","skip","count","int_code", "depth"};
char * gl_endmark_fields[] = {"depth"};

dptr rec_structinate(dptr dp, char *name, int nfields, char *a[])
{
   int i;
   struct descrip s;
   struct descrip fields[16];
   if (is:null(*dp)) {
      AsgnCStr(s, name);
      AsgnCStr(fields[0], "name");
      AsgnCStr(fields[1], "code");
      if (nfields > 3) {
         if (!strcmp(name,"gl_mark") || !strcmp(name, "gl_texture")) {
           for(i=2; i < nfields; i++)
              AsgnCStr(fields[i], a[i-2]);
           }
         else {
           AsgnCStr(fields[2], "x");
           AsgnCStr(fields[3], "y");
           AsgnCStr(fields[4], "z");
           for(i=5; i < nfields; i++)
              AsgnCStr(fields[i], a[i-5]);
           }
         }
      else if (nfields == 3)
         AsgnCStr(fields[2], a[0]);
      dp->dword = D_Proc;
      dp->vword.bptr = (union block *)dynrecord(&s, fields, nfields);
      }
   return dp;
}


dptr rec_structor3d(char *name)
{
#ifdef Graphics3D
   if (!strcmp(name, "gl_torus"))
      return rec_structinate(&gl_torus, "gl_torus", 7, gl_torus_fields);
   else if (!strcmp(name, "gl_cube"))
      return rec_structinate(&gl_cube, "gl_cube", 6, gl_cube_fields);
   else if (!strcmp(name, "gl_sphere"))
      return rec_structinate(&gl_sphere, "gl_sphere", 6, gl_sphere_fields);
   else if (!strcmp(name, "gl_cylinder"))
      return rec_structinate(&gl_cylinder, "gl_cylinder", 8, gl_cylinder_fields);
   else if (!strcmp(name, "gl_disk"))
      return rec_structinate(&gl_disk, "gl_disk", 9, gl_disk_fields);
   else if (!strcmp(name, "gl_rotate"))
      return rec_structinate(&gl_rotate, "gl_rotate", 6, gl_rotate_fields);
   else if (!strcmp(name, "gl_translate"))
      return rec_structinate(&gl_translate, "gl_translate", 5, NULL);
   else if (!strcmp(name, "gl_scale"))
      return rec_structinate(&gl_scale, "gl_scale", 5, NULL);
   else if (!strcmp(name, "gl_popmatrix"))
      return rec_structinate(&gl_popmatrix, "gl_popmatrix", 2, NULL);
   else if (!strcmp(name, "gl_pushmatrix"))
      return rec_structinate(&gl_pushmatrix, "gl_pushmatrix", 2, NULL);
   else if (!strcmp(name, "gl_identity"))
      return rec_structinate(&gl_identity, "gl_identity", 2, NULL);
   else if (!strcmp(name, "gl_matrixmode"))
      return rec_structinate(&gl_matrixmode, "gl_matrixmode",
				3, gl_matrixmode_fields);
   else if (!strcmp(name, "gl_meshmode"))
      return rec_structinate(&gl_meshmode, "gl_meshmode",
				3, gl_meshmode_fields);
   else if (!strcmp(name, "gl_texture"))
      return rec_structinate(&gl_texture, "gl_texture", 4, gl_texture_fields);
   else if (!strcmp(name, "gl_font3d"))
      return rec_structinate(&gl_font3d, "gl_font3d", 3, gl_font_fields);
   else if (!strcmp(name, "gl_drawstring3d"))
	return rec_structinate(&gl_drawstring3d, "gl_drawstring3d",
				6, gl_drawstring3d_fields);
   else if (!strcmp(name, "gl_endmark"))
      return rec_structinate(&gl_endmark, "gl_endmark", 3, gl_mark_fields);
   else if (!strcmp(name, "gl_mark"))
	return rec_structinate(&gl_mark, "gl_mark", 7, gl_mark_fields);
#endif					/* Graphics3D */

   return 0;
}

int create3Dlisthdr(dptr dp, char *strname, word size){
   int draw_code;
   struct descrip funcname, g;	/* do not need to be tended */
   tended struct b_list *func;
  
   /* create a list to save function information */
   Protect(func = alclist(0, size), return Error);
   dp->dword = D_List;
   dp->vword.bptr = (union block *) func;
   MakeStr(strname, strlen(strname), &funcname);
   c_put(dp, &funcname);
  
   draw_code = si_s2i(redraw3Dnames, strname);
   if (draw_code == -1)
      return Error;
   MakeInt(draw_code, &g);
   c_put(dp, &g);
   return Succeeded;
}


void getmeshmode(wbp w, char *answer)
{
   switch(w->context->meshmode) {
      case U3D_POINTS: strcpy(answer, "points"); break;
      case U3D_LINES: strcpy(answer, "lines"); break;
      case U3D_LINE_STRIP: strcpy(answer, "linestrip"); break;
      case U3D_LINE_LOOP: strcpy(answer, "lineloop"); break;
      case U3D_TRIANGLES: strcpy(answer, "triangles"); break;
      case U3D_TRIANGLE_FAN: strcpy(answer, "trianglefan"); break;
      case U3D_TRIANGLE_STRIP: strcpy(answer, "trianglestrip"); break;
      case U3D_QUADS: strcpy(answer, "quads"); break;
      case U3D_QUAD_STRIP: strcpy(answer, "quadstrip"); break;
      case U3D_POLYGON: strcpy(answer, "polygon"); break;
   }
}

void gettexmode(wbp w, char *abuf, dptr answer)
{
   wcp wc = w->context;
   switch (wc->texmode) {
      case U3D_REPLACE: strcpy(abuf, "on"); break;
      case U3D_BLEND: strcpy(abuf, "blend"); break;
      case U3D_MODULATE: strcpy(abuf, "modulate"); break;
      case 0: strcpy(abuf, "off"); break;
      default: strcpy(abuf, "unknown texture mode"); break;
      }
   MakeStr(abuf, strlen(abuf), answer);
}


void getatexcoord(double d, char *b)
{
   if ((double)(int)d == d) sprintf(b,"%d",(int)d);
   else sprintf(b,"%.3f",d);
}

/* get the user specified texture coordinates */
int gettexcoords(wbp w, char *buf)
{
   char *s = buf;
   int i;
   wcp wc = w->context;
   getatexcoord(wc->texcoords->a[0], s);

   s += strlen(s);
   for (i = 1; i < wc->numtexcoords; i++) {
      *s++ = ',';
      getatexcoord(wc->texcoords->a[i], s);
      s += strlen(s);
     }
   return Succeeded;
}

int gettexture(wbp w, dptr dp)
{
   wcp wc= w->context;
   wtp wt = wc->textures;
   while (wt) {
      if (wt->texindex == wc->curtexture) {
	 *dp = wt->d;
	 return Succeeded;
	 }
      wt = wt->next;
      }
   return Failed;
}


int init_3dcontext(wcp wc)
{
  /* set defaults for attributes */
   wc->eyeupx = wc->eyeupz = 0.0;
   wc->eyeupy = 1.0;
   wc->dim = 3;
   wc->slices = 15;
   wc->rings = 10;
   wc->selectionenabled = 0;
   wc->selectionrendermode=0;
   wc->selectionnamelistsize=256;
   wc->selectionnamecount=0;
   wc->selectionnamelist = malloc(wc->selectionnamelistsize*sizeof(char*));
   if (wc->selectionnamelist == NULL) return Failed;
   wc->app_use_selection3D = 0;

   wc->eyeposx = wc->eyeposy =  wc->eyeposz = wc->eyedirx = wc->eyediry = 0.0;
   wc->eyedirz = -100.0;
   wc->autogen = 1;
   wc->normode = 1;
   wc->normals = NULL;
   wc->texmode = wc->numtexcoords = 0;
   wc->texName = malloc(16 * sizeof(GLuint));
   if (wc->texName == NULL) return Failed;
   wc->nalced = 16;
   wc->maxstex=16;

   wc->stex = (struct _savetexture *) malloc(16*sizeof(struct _savetexture));
   if (wc->stex == NULL) return Failed;

   wc->texcoords = NULL; 
   wc->ntextures = 0;
   wc->curtexture = -1;
   wc->buffermode = IMMEDIATE3D;
   wc->meshmode = U3D_POLYGON;
   return Succeeded;
}

int copy_3dcontext(wcp wc, wcp rv)
{
  /* set defaults for attributes */
   rv->eyeupx = wc->eyeupx;
   rv->eyeupz = wc->eyeupz;
   rv->eyeupy = wc->eyeupy;
   rv->dim = wc->dim;
   rv->slices = wc->slices;
   rv->rings = wc->rings;
   rv->selectionenabled = wc->selectionenabled;
   rv->selectionrendermode = wc->selectionrendermode;
   rv->selectionnamelistsize = wc->selectionnamelistsize;
   rv->selectionnamecount = wc->selectionnamecount;
   rv->selectionnamelist = wc->selectionnamelist;
   rv->app_use_selection3D = wc->app_use_selection3D;

   rv->eyeposx = wc->eyeposx;
   rv->eyeposy = wc->eyeposy;
   rv->eyeposz = wc->eyeposz;
   rv->eyedirx = wc->eyedirx;
   rv->eyediry = wc->eyediry;
   rv->eyedirz = wc->eyedirz;
   rv->autogen = wc->autogen;
   rv->normode = wc->normode;
   rv->normals = wc->normals;
   rv->texmode = wc->texmode;
   rv->numtexcoords = wc->numtexcoords;
   rv->texName = wc->texName;
   rv->nalced = wc->nalced;
   rv->maxstex = wc->maxstex;

   rv->stex = wc->stex;

   rv->texcoords = wc->texcoords;
   rv->ntextures = wc->ntextures;
   rv->curtexture = wc->curtexture;
   rv->buffermode = wc->buffermode;
   rv->meshmode = wc->meshmode;
   return Succeeded;
}



#endif					/* Graphics3D */
