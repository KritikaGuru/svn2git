\chapter{Portable 2D and 3D Graphics}

Two-dimensional graphics were originally added to Icon version 8 as
part of Clint Jeffery's response to Ralph Griswold's interest in
software visualization. Visualization research called for rapid
graphics prototyping and we were in possession of a rapid prototyping
language. The facilities were successful enough to warrant painstaking
porting (to OS/2 and then MS Windows) and documentation (Griswold wrote
a larger book for the Icon graphics facilities than the Icon book) efforts.
Two elaborate graphic user interface libraries (with interface
builders) were developed, the first in Idol by Jon Lipp and Mary
Cameron, and the second in Unicon by Robert Parlett.
Unicon Version 11 introduced a powerful set of 3D graphics facilities,
increasing the footprint of the graphics in the overall implementation.

This chapter describes the design and implementation internals of the
2D and 3D graphics facilities and their window system
implementation. It is intended for persons extending the graphics
facilities or porting Unicon to a new window system.This chapter is
derived from Unicon Technical Report \#5, by Clint Jeffery, Naomi
Martinez and Jafar Al Gharaibeh.


\section[27.1 Window Systems and Platform-Independence]{27.1 Window Systems and Platform-Independence}

This chapter describes the internals of the implementation of Unicon's
graphics and window system facilities. Much of the code is devoted to
hiding specific features of C graphics interfaces that were deemed
overly complex or not worth the coding effort they entail. Other
implementation techniques are motivated by portability concerns. The
graphics interface described below has been implemented to various
levels of completeness on the X Window System, Microsoft Windows, OS/2
Presentation Manager, and Macintosh platforms. Most of this discussion
is relevant also for Icon Version 9.4; Unicon's graphics facilities
include minor improvements.

{\sffamily
Relevant Source File Summary}

This document assumes a familiarity with the general organization and
layout of Unicon sources and the configuration and installation
process. For more information on these topics, consult Icon Project
Documents IPD 238 [TGJ96] and IPD 243 [TGJ98] for UNIX, and Appendix B
of this document for MS Windows.

Unicon's window facilities consist of several source files, all in the
runtime directory unless otherwise noted. They are discussed in more
detail later in this document.

\textbf{header files} -- \textsf{h/graphics.h} contains structures and
macros common across platforms. Each platform adds platform-specific
elements to the common window structures defined in this file. In
addition, each platform gets its own header file, currently these
consist of X Windows (\textsf{h/xwin.h}), Microsoft Windows
(\textsf{h/mswin.h}), OS/2 Presentation Manager
(\textsf{h/pmwin.h}),and the Macintosh (\textsf{h/mac.h}). Every
platform defines several common macros in the window-system specific
header file in addition to its window system specific structures and
macros. The common macros are used to insert platform-dependent pieces
into platform-independent code.

\textbf{Unicon functions} -- \textsf{fwindow.r} contains the RTL
(Run-Time Language) interface code used to define built-in graphics
functions for the Unicon interpreter and compiler. For most functions,
this consists of type checking and conversion code followed by calls
to platform-dependent graphics functions. The platform dependent
functions are described later in this document; \textsf{fwindow.r} is
platform independent. You will generally modify it only if you are
adding a new built-in function. For example, the Windows native
functions are at the bottom of this file.

\textbf{internal support routines} -- \textsf{rwindow.r, rwinrsc.r,
rgfxsys.r} and \textsf{rwinsys.r} are basically C files with some
window system dependencies but mostly consisting of code that is used
on all systems. For example, \textsf{rwindow.r} is almost 100
kilobytes of portable source code related to Unicon's event model,
attribute/value system, portable color names, GIF and JPEG image file
support, palettes, fonts, patterns, spline curves and so forth.

\textbf{window-system specific files} -- Each window system gets its
own source files for C code, included by the various \textsf{r*.r}
files in the previous section. Currently these include
\textsf{rxwin.ri} and \textsf{rxrsc.ri} for X Window;
\textsf{rmswin.ri} for MS Windows; \textsf{rpmwin.ri},
\textsf{rpmrsc.ri}, and \textsf{rpmgraph.ri} for Presentation Manager;
and \textsf{rmac.ri} for the Macintosh. Each platform will implement
one or more such \textsf{r*.ri} files. In addition,
\textsf{common/xwindow.c} contains so many X Window includes that it
won't even compile under UNIX Sys V/386 R 3.2 if all of the Unicon
includes are also present -- so its a \textsf{.c} file instead of a
\textsf{.r} file.

\textbf{tainted {\textquotedbl}regular{\textquotedbl} Unicon sources}
-{}- Many of the regular Unicon source files include code under
\textsf{\#ifdef Graphics} and/or one or more specific window system
definitions such as \textsf{\#ifdef XWindows} or \textsf{\#ifdef
PresentationManager}. The tainted files that typically have to be
edited for a new window system include \textsf{h/grttin.h},
\textsf{h/features.h}, \textsf{h/rexterns.h}, \textsf{h/rmacros.h},
\textsf{h/rproto.h}, \textsf{h/rstructs.h}, and
\textsf{h/sys.h}. Other files also contain \textsf{Graphics}
code. This means that most of the system has to be recompiled with rtt
and cc after \textsf{Graphics} is defined in \textsf{h/define.h}. You
will also want to study the \textsf{Graphics} stuff in
\textsf{h/grttin.h} since several profound macros are there. Also, any
new types (such as structures) defined in your window system include
files will need dummy declarations (of the form \textsf{typedef int
foo;}) to be added there.

Under UNIX the window facilities are turned on at configuration time by typing

\textsf{make X-Configure name=system}

\noindent instead of the usual \textsf{make Configure} invocation. The
X configuration modifies makefiles and defines the symbolic constant
\textsf{Graphics} in \textsf{h/define.h}. If OpenGL libraries are
detected, configuration enables them automatically. Similar but less
automatic configuration handling is performed for other systems; for
example, an alternate .\textsf{bat} file is used in place of
\textsf{os2.bat} or \textsf{turbo.bat}.

{\sffamily
\textbf{Graphics \#define{}-d symbols}}

The primary, window-system-independent defined symbol that turns on
window facilities is simply \textsf{Graphics}.  Underneath this parent
\textsf{\#ifdef}, the symbol \textsf{XWindows} is meant to mark all X
Window code. \ Other window systems have a definition comparable to
\textsf{XWindows}: for Microsoft Windows it is \textsf{MSWindows}, for
OS/2 it is \textsf{PresentationManager}, and for the Macintosh,
\textsf{MacGraph}. \ Turning on any of the platform specific graphics
\textsf{\#define} symbols turns on \textsf{Graphics} implicitly.

\section[27.2 Structures Defined in graphics.h]{27.2 Structures Defined in graphics.h}

The header file \textsf{graphics.h} defines a collection of C
structures that contain pointers to other C structures from
\textsf{graphics.h} as well as pointers into the window system library
structures. \ The internals for the simplest Unicon window structure
under X11 are depicted in Figure 1. The picture is slightly simpler
under MS Windows, with no display state or related color or font
management; on the other hand MS Windows maps the Unicon context onto
a large set of resources, including pens, brushes, fonts and bitmaps.


\bigskip


\bigskip


\bigskip


\ \  \ \ \ \ \ \ \ \ \ \ Figure 1: Internal Structure of an Unicon Window Value


At the top, Unicon level, there is a simple structure called a
\textit{binding} that contains a pointer to a window state and a
window context. Pointers to bindings are stored in the \textsf{FILE *}
variable of the Unicon file structure, and most routines that deal
with a window take a pointer to a binding as their first
argument. Beneath this facade, several structures are accessed to
perform operations on each window.

The window state holds the typical window information (size, text
cursor location, an Unicon list of events waiting to be read) as well
as a window system pointer to the actual window, a pointer to a
backing pixmap (a {\textquotedbl}compatible device
context{\textquotedbl} used to handle redraw requests), and a pointer
to the display state.

The window context contains the current font, foreground, and
background colors used in drawing/writing to the window.  It also
contains drawing style attributes such as the fill style. Contexts are
separate from the window state so that they may be shared among
windows. This is a big win, and Unicon programs tend to use it
heavily, so in porting the window functions a central design issue
must be the effective use of a comparable facility on other window
systems, or emulating the context abstraction if
necessary. Nevertheless, one might start out with \textsf{Couple()}
and \textsf{Clone()} disabled and only allow one hardwired context
associated with each window.

The display state contains whatever system resources (typically
pointers or handles) that are shared among all the windows on a given
display in the running program. For example, in X this includes the
fonts, the colors, and a window system pointer for an internal Display
structure required by all X library calls to denote the connection to
the X server.


\section[27.3 Platform Macros and Coding Conventions]{27.3 Platform Macros and Coding Conventions}

Since the above structure is many layers deep and sometimes confusing,
Unicon's graphics interface routines employ coding conventions to
simplify things. In order to avoid many extra memory references in
accessing fields in the multi-level structure,
{\textquotedbl}standard{\textquotedbl} local variables are declared in
most of the platform dependent interface routines in \textsf{rxwin.ri}
and \textsf{rmswin.ri}. \ The macro \textsf{STDLOCALS(w)} declares
local variables pointing to the most commonly used pieces of the
window binding, and initializes them from the supplied argument; each
window system header should define an appropriate
\textsf{STDLOCALS(w)} macro. Under some window systems, such as MS
Windows, \textsf{STDLOCALS(w)} allocates resources which must be freed
before execution continues, in which case a corresponding
\textsf{FREE\_STDLOCALS(w)} macro is defined.

Some common standard locals are \textsf{wc}, \textsf{ws},
\textsf{stdwin}, and \textsf{stdpix}. While \textsf{wc}, and
\textsf{ws} are pointers to structures copied from the window binding,
\textsf{stdwin}, and \textsf{stdpix} are actual X (or MS Window)
resources that are frequently supplied to the platform-dependent
routines as arguments. Each window system will have its own standard
locals. For example, MS Windows adds \textsf{stddc} and \textsf{pixdc}
since it uses a device context concept not found in X11.

In much of the platform-dependent source code, the window system calls
are performed twice. This is because most platforms including X, MS
Windows, and PresentationManager do not remember the contents of
windows when they are reduced to iconic size or obscured behind other
windows. When the window is once again exposed, it is sent a message
to redraw itself. Unicon hides this entirely, and remembers the
contents of the window explicitly in a window-sized bitmap of
memory. The calling of platform graphics routines twice is so common
that a set of macros is defined in \textsf{xwin.h} to facilitate it.
The macros are named \textsf{RENDER2} through \textsf{RENDER6}, and
each of them takes an Xlib function and then some number of arguments
to pass that function, and then calls that function twice, once on the
window and once on the bitmap.

Platforms that provide backing store may avoid this duplicated
effort. In practice however it seems most window systems have redraw
events even if they implement retained windows (for example, MGR
[Uhler88]).

\section[27.4 Window Manipulation in rxwin.ri and rmswin.ri]{27.4 Window Manipulation in rxwin.ri and rmswin.ri}

The platform-dependent calls in the Unicon run-time system can be
categorized into several major areas:

\liststyleLxlv
\begin{itemize}
\item 
\ Window creation and destruction
\item 
\ Low-level event processing
\item 
\ Low-level text output operations
\item 
\ Window and context attribute manipulation
\end{itemize}

\subsection[27.4.1 Window Creation and Destruction]{27.4.1 Window Creation and Destruction}

A graphics window is created when the Unicon program calls
\textsf{open()} with file attribute
\textsf{{\textquotedbl}g{\textquotedbl}}. The window opening sequence
consists of a call to \textsf{wopen()} to allocate appropriate Unicon
structures for the window and evaluate any initial window attributes
given in additional arguments to \textsf{open()}. After these
attributes have been evaluated, platform resources such as fonts and
colors are allocated and and the window itself is instantiated. Under
X, \textsf{wopen()} busy-waits until the window has received its first
expose event, ensuring that no subsequent window operation takes place
before the window has appeared onscreen.

A window is closed by a call to \textsf{wclose()}; this removes the
on-screen window even if other bindings (Unicon window values) refer
to it. A closed window remains in memory until all Unicon values that
refer to it are closed. A call to \textsf{unbind()} removes a binding
without necessarily closing the window.

\subsection[27.4.2 Event Processing]{27.4.2 Event Processing}

The system software for each graphics platform has a huge number of
different types of events. Unicon ignores most of them. Of the
remainder, some are handled by the runtime system code in the
\textsf{.ri} files implicitly, and some are explicitly passed on to
the Unicon program.

Most native graphic systems require that applications be event-driven;
they must be tightly I/O bound around the user's actions. The
interaction between user and program must be handled at every instant
by the program. Unicon, on the other hand, considers this event-driven
model optional.


Making the event-driven model optional means that the Unicon interface
must occasionally read and process events when the Unicon program
itself is off in some other computation. In particular, keystrokes and
mouse events must be stored until the user requests them, but exposure
events and resizes must be processed immediately. The Unicon
interpreter pauses at regular intervals in between its virtual machine
instructions (the Unicon compiler emits polling code in its generated
C code, so window system facilities are supported by the compiler as
well) and polls the system for events that must be processed; this
technique fails when no virtual machine instructions are executing,
such as during garbage collections or when blocked on file I/O.

On some platforms such as X, this probably could be done using the
platform event queue manipulation routines.  Instead, the Unicon
window interface maintains its own keystroke and mouse event queue
from which the Unicon functions obtain their events. This additional
queue makes the implementation more portable. Various window systems
probably do not support queue manipulation to the extent or in the
same way that X does. It also provides the programmer with a higher
level event processing abstraction which has proven useful.

Window resizing is partly handled by the interface. The old contents
of the window are retained in their original positions, but the
program is informed of the resize so it can handle the resize in a
more reasonable manner. As has already been noted exposure events are
hidden entirely via the use of a backing pixmap with identical
contents for each window. The pixmap starts out the same size as the
window. It is resized whenever the window grows beyond one of its
dimensions. It could be reduced whenever the window shrinks, but then
part of the window contents would be lost whenever the user
accidentally made the window smaller than intended.

The platform-dependent modules also contains tables of type
\textsf{stringint}. These tables are supported by routines that map
strings for various attributes and values to native window system
integer constants. Binary search is employed. This approach is a crude
but effective way to provide symbolic access
{\textquotedbl}built-in{\textquotedbl} to the language without
requiring include files. Additional tables mapping strings to
integers are found in the platform independent source files.

\subsection[27.4.3 Resource Management]{27.4.3 Resource Management}

One of the most important tasks performed by platform-specific
graphics functions is the management of resources, both the on-screen
resources (windows) and the drawing context elements used by the
window system in performing output.

\subsection[27.4.4 Memory Management and r*rsc.ri Files]{27.4.4 Memory Management and r*rsc.ri Files}

Memory management for internal window structures is independent of
Unicon's standard memory management system. Xlib memory is allocated
using \textsf{malloc(2)}.

Most internal Unicon window structures could be allocated in Unicon's
block region, but since they are acyclic and cannot contain any
pointers to Unicon values, this would serve little purpose (Actually,
it is probably the right thing to do, and will probably happen some
day, but its just not in the cards right now unless you feel like
messing with the garbage collector.). In addition when an incoming
event is being processed it has to be matched up with the appropriate
window state structure, so some of the window structures must be
easily reached, not lost in the block region. The window interface
structures are reference counted and freed when the reference count
reaches 0.

\subsection[27.4.5 Color Management]{27.4.5 Color Management}

Managing colors under X Windows is painful. In particular, if the same
color is allocated twice the color table entry is shared (which is
good) and that entry may only be freed once (which is bad). For this
reason, every color allocated by Unicon is remembered and duplicate
requests are identified and freed only once. In the general case it is
impossible to detect when a particular color is no longer being
displayed, and so colors are only freed on window closure or when a
window is cleared.

\subsection[27.4.6 Font Management]{27.4.6 Font Management}

Unicon supports a portable font name syntax. Since the available fonts
on systems vary widely, {\textquotedbl}interesting{\textquotedbl} code
has been written to support these portable names on various X servers.
Each window system may need to include heuristics to pick an
appropriate font in the font allocation routine in the window system's
\textsf{r*.ri} file.

\section[27.5 External Image Files and Formats]{27.5 External Image Files and Formats}

Reading and writing window contents to external files is accomplished
by the routines \textsf{loadimage()} and \textsf{dumpimage()},
implemented in each platform's window system specific file, such as
\textsf{rxwin.ri}. These routines take a window binding and a string
filename and perform the I/O transfer. Presently, the file format is
assumed to be indicated by the filename extension; this is likely to
change. Ideally Unicon should tolerate different file formats more
flexibly, inferring input file formats by reading the file header
where possible, and running external conversion programs where
appropriate.

GIF and JPEG files are self-identifying, so they are always recognized
independent of name. They are checked in system-independent code
before platform-specific image reading code is invoked.


\section[27.6 Implementation of 3D Facilities]{27.6 Implementation of 3D Facilities}

In order to implement the 3D facilities, the Unicon runtime system was
modified to support 2D and 3D windows. The Unicon runtime system is
written in a custom superset dialect of C called RTL [Walker94]. The
3D facilities use the existing 2D facilities code for window creation
and destruction, as well as handling keyboard and mouse input.

\subsection[27.6.1 3D Facilities Requirements]{27.6.1 3D Facilities Requirements}

OpenGL 1.2 or later must be present on the system in order for
Unicon's 3D graphics facilities to work. A check for this is performed
in \textsf{wopengl()} which can be found in the file
\textsf{ropengl.ri}. The requirement of OpenGL 1.2 is based on the
fact that the function \textsf{glTexBind(),}\texttt{ }which make the
implementation of textures more efficient, is only available in OpenGL
1.2 and later.

Also needed for the Unicon 3D graphics facilities is a system that
supports a true color visual with a depth buffer of 16 and a double
buffer. The requirement of a depth buffer is a necessity to implement
lighting. For lighting to work properly in OpenGL, a depth test must
be performed, hence the need of a depth buffer. A double buffer is
needed to implement the list structure that is used to redraw a
window. More information can be found on redrawing of windows in
section 7.3.

\subsection[27.6.2 Files]{27.6.2 Files}

Several existing files contain extensions to support the Unicon 3D
graphics facilities under \#ifdef Graphics3D, including data.r (new
runtime error codes), fwindow.r (new 3D functions), rmemmgt.r (3D
window display lists), rxwin.ri and rmswin.ri (modified wopen() and
wmap() to support 3d mode), rwindow.r (new 3D attributes), and
graphics.h (new 3D fields in canvas and context structures). Also a
new file, ropengl.ri was added that contains the C helper functions
for functions in \textsf{fwindow.r, rxwin.ri}, and \textsf{rwindow.r}.

\subsection[27.6.3 Redrawing Windows]{27.6.3 Redrawing Windows}

In the 2D graphics facilities, events that require the redrawing of a
window are handled by using a pixmap. Instead of using a pixmap, for
the Unicon 3D graphics facilities, a Unicon list of lists is created
for each window opened in \textsf{{}``gl''} mode. This list of lists
keeps track of all objects in a 3D graphics scene. This list is called
\textsf{funclist} and is found in the wstate structure of a
\textsf{{\textquotedbl}gl{\textquotedbl}} window. The individual lists
of contain the function name and the parameters of that function. Also
placed on the list are attributes that affect the scene. These include
\textsf{dim}, \textsf{linewidth}, \textsf{texcoord}, \textsf{texture},
\textsf{texmode}, and \textsf{fg}. When a window receives an event
that requires redrawing, the window is cleared, all attributes are
reset to the defaults, and the Unicon list of lists is traversed to
redraw every object in the scene.

There are some functions and attributes that are not placed in the
list. Instead they much either modify the list or call the list to
redraw the scene. The function \textsf{EraseArea()}, not only clears
the screen but also clears the contents of the list. The attributes
\textsf{light0-light7}, \textsf{eye}, \textsf{eyeup}, \textsf{eyedir},
and \textsf{eyepos} use the list to redraw the window with the new
attributes. So if the position of a light changes, the new lighting
calculations are preformed and the scene is redraw. Besides these
functions and attributes, every function or attribute available in the
3D graphics facilities is placed on this list. In is important to note
that functions and attributes that have no effect in the 3D graphics
facilities are not placed in this list.

\subsection[27.6.4 Textures]{27.6.4 Textures}

In OpenGL, textures can be one, two, or three-dimensional and are
represented as multi-dimensional arrays. In the Unicon 3D graphics
facilities all texture are 2D dimensional, and represented as
three-dimensional arrays. This array keeps track of the position and
red, green, and blue components of each pixel in the texture
image. When a texture image is specified in a Unicon program, the
texture is converted from the Unicon internal representation of the
image to a three-dimensional array. For most cases, this does not take
a long time, but as a texture image gets larger, the slower the
application will run. Several measures have been taken in order to
increase the efficiency of converting the texture image into an
array. Since lighting and texturing are fairly expensive operations,
especially if several lights are activated, these features are
temporarily deactivated. Despite these efforts, converting a
{\textquotedbl}\textsf{g{\textquotedbl}} window to a texture is still
fairly expensive. Possible future work includes ways to speed up this
process.

Instead of adding a texture to the list of lists as described in
section 7.3, OpenGL's internal texture resources are used. OpenGL
assigns to each texture a name. The names assigned to each texture in
a Unicon scene are stored in \textsf{texname[]}, which can be found in
a \textsf{``gl''} window's context. To ensure that a texture name is
not reused, a call to \textsf{glGenTextures()} made which produces
unused texture names. When a texture is applied to the scene, only the
index of the array \textsf{texname[]} is stored in the list. When the
list is traversed, a call to \textsf{glBindTexture()} is made which
binds the texture to the subsequent objects in the scene. One problem
of using this representation of textures is that it places an upper
bound on the number of texture used. This is because
\textsf{glGenTextures()} requires the number of texture names to
generate. Also by using \textsf{glBindTexture()}, never deletes a
texture from the texture resources, possibly using up all texture
resources. Future work might look into when to delete a texture an
ways to check when the texture resources have been used up.

\subsection[27.6.5 Texture Coordinates]{27.6.5 Texture Coordinates}

The primitives as mentioned in previous sections are cubes, tori,
cylinders, disks, partial disks, points, lines, polygons, spheres,
line segments, and filled polygons. Some of these primitives are drawn
using different aspect of the OpenGL library, with some using the glu
library. Points, lines, line segments, polygons, and filled polygons
are drawing using \textsf{glBegin()}, \textsf{glEnd()}, and vertices
in between the function calls. Cylinders, disks, partial disks, and
spheres are implemented using the glu library. They are considered to
be\textsf{ gluQuadrics} objects. Finally cubes and tori are a
composition of several polygons.

The texturing method used is influenced by the how the primitive is
composed. For the primitives built using the OpenGL library, default
texture coordinates are obtain much differently than those primitives
built using the glu library. For those primitives built using
\textsf{glBegin()} and \textsf{glEnd()}, \textsf{glTexGen()} is used
to determine the default parameters when
\textsf{{\textquotedbl}texcoord=auto{\textquotedbl}}. In order to use
this feature we must enable \textsf{GEN\_S} and \textsf{GEN\_T} with
\textsf{glEnable().} This generates texture coordinates for a 2D
textures. The texture coordinates for a torus are obtained in the same
ways.

Primitives built using the glu library, have texture coordinates
associated with them. These texture coordinates can be obtained by
calling \textsf{gluQuadricTexture()}.The use of the glu texture
coordinates verses the OpenGL coordinates, is due to the fact that the
glu texture coordinate look nicer. In order to use these texture
coordinates instead of the ones specified by OpenGL, it is necessary
to disable \textsf{GEN\_S} and \textsf{GEN\_T}. After the object has
been drawn, \textsf{GEN\_S} and \textsf{GEN\_T} are turned back on.

A cube uses default texture coordinates that map the texture onto each
of the faces of a cube. In order to use these default coordinates, it
is necessary to disable \textsf{GEN\_S} and \textsf{GEN\_T}, similar
to glu objects.

\section[27.7 Graphics Facilities Porting Reference]{27.7 Graphics Facilities Porting Reference}

This section documents the window-system specific functions and macros
that generally must be implemented in order to port Unicon's graphics
facilities to a new window system. The list is compiled primarily by
studying \textsf{fwindow.r}, \textsf{rwindow.r}, and the existing
platforms.


A note on types: \textsf{w} is a window binding pointer
(\textsf{wbp}), the top level Unicon
{\textquotedbl}window{\textquotedbl} value. \textsf{i} is an integer,
\textsf{s} is a string. \textsf{wsp} is the window state
(a.k.a. canvas) pointer, and \textsf{wcp} is the window context
pointer. A \textsf{bool} return value returns one of the C macro
values \textsf{Succeeded} or \textsf{Failed}, instead of the usual C
booleans 1 and 0.


\bigskip\hrule\vspace{0.1cm}
\noindent
ANGLE(a)


Convert from radians into window system units. For example, under X
these are 1/64 of a degree integer values, while under
PresentationManager it converts to units of 1/65536 of a degree in a
fixed-point format.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
ARCHEIGHT(arc)}


The height component of an XArc.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
ARCWIDTH(arc)}


The width component of an XArc.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
ASCENT(w)}


Returns the number of pixels above the baseline for the current
font. Note that when Unicon writes text, the (x,y) coordinate gives
the left edge of the character at its baseline; some window systems
may need to translate our coordinates.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
int blimage(w, x, y, width, height, ch, s, len)}

Draws a bi-level (i.e. monochrome, 1-bit-per-pixel) image; used in
\textsf{DrawImage()} which draws bitmap data stored in Unicon strings.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
wcp clone\_context(w)}


Allocate a new context, cloning attributes from w's context.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
COLTOX(w, i)}


Return integer conversion from a 1-based text column to a pixel coordinate.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
copyArea(w1, w2, x, y, width, height, x2, y2)}


Copies a rectangular block of pixels from w1 to w2.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
DESCENT(w)}


Returns the number of pixels below the baseline for the current font.


\bigskip\hrule\vspace{0.1cm}
\noindent
DISPLAYHEIGHT(w)


Return w's display (screen) height in pixels.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
DISPLAYWIDTH(w)}


Return w's display width in pixels.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
bool do\_config(w, i)}


Performs move/resize operations after one or more attributes have been
evaluated. Config is a word with two flags: the one bit indicates a
move, the two bit indicates a resize. The desired sizes are in the
window state pointer, e.g.
w-{\textgreater}window-{\textgreater}width.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
drawarcs(w, thearcs, i)}


Draw i arcs on w, given in an array of XArc structures. \ Define an appropriate XArc structure for your window system;
it must include fields x, y and width and height fields accessible through macros \textsf{ARCWIDTH()} and
\textsf{ARCHEIGHT()}. \ Also, a starting angle angle1 and arc extent angle2, assigned through macros \textsf{ANGLE()},
\textsf{EXTENT()}, and \textsf{FULLARC}. \ This is currently a mess. \ Imitation of the X or PresentationManager code
is in order.


\bigskip\hrule\vspace{0.1cm}
\noindent
drawlines(w, points, i)


Draw i-1 connected lines, connecting the dots given in points.


\bigskip\hrule\vspace{0.1cm}
\noindent
drawpoints(w, points, i)


Draw i points.


\bigskip\hrule\vspace{0.1cm}
\noindent
drawsegments(w, segs, i)


Draw i disconnected line segments; define an Xsegment structure appropriate do your window system, consisting of fields
x1, y1, x2, y2. \ This type definition requirement should be cleaned up someday.


\bigskip\hrule\vspace{0.1cm}
\noindent
drawstring(w, x, y, s, s\_len)


Draw string s at coordinate (x,y) on w. \ Note that y designates a baseline, not an upper-left corner, of the string.


\bigskip\hrule\vspace{0.1cm}
\noindent
drawrectangles(w, rectangles, i)


Draw \textsf{i} rectangles. \ Define an XRectangle structure appropriate to your window system.

\bigskip\hrule\vspace{0.1cm}
\noindent



int dumpimage(w, s, x, y, width, height)


Write an image of a rectangular area in w to file s. Returns \textsf{Succeeded}, \textsf{Failed}, or \textsf{NoCvt} if
the platform doesn't support the requested format. \ Note that this is the {\textquotedbl}platform- dependent image
writing function{\textquotedbl}; requests to write GIF \ or JPEG are handled outside of this function.


\bigskip\hrule\vspace{0.1cm}
\noindent
eraseArea(w, x, y, width, height)


Erase a rectangular area, that is, set it to the current background color. \ Compare with \textsf{fillrectangles()}.


\bigskip\hrule\vspace{0.1cm}
\noindent
EXTENT(a)


Convert from radians into window system units, e.g. under PresentationManager it converts to units of 1/65536 of a
circle and does some weird type conversion.


\bigskip\hrule\vspace{0.1cm}
\noindent
fillarcs(w, arcs, i)


Fill wedge-like arc sections (pie pieces). \ See \textsf{drawarcs()}.


\bigskip\hrule\vspace{0.1cm}
\noindent
fillrectangles(w, rectangles, i)


Fill i rectangles. \ See \textsf{drawrectangles()}.


\bigskip\hrule\vspace{0.1cm}
\noindent
fillpolygon(w, points, i)


Fill a polygon defined by i points. \ Connect first and last points if they are not the same.


\bigskip\hrule\vspace{0.1cm}
\noindent
FHEIGHT(w)


Returns the pixel height of the current font, hopefully \textsf{ASCENT + DESCENT.}


\bigskip\hrule\vspace{0.1cm}
\noindent
free\_binding(w)


Free binding associated with \textsf{w}. \ This gets rid of a binding that refers to \textsf{w}, without necessarily
closing the window itself (other bindings may point to that window).


\bigskip\hrule\vspace{0.1cm}
\noindent
free\_context(wc)


Free window context \textsf{wc}.


\bigskip\hrule\vspace{0.1cm}
\noindent
free\_mutable(w, i)


Free mutable color index \textsf{i}.


\bigskip\hrule\vspace{0.1cm}
\noindent
free\_window(ws)


Free window canvas \textsf{ws}.


\bigskip\hrule\vspace{0.1cm}
\noindent
freecolor(w, s)


Free a color allocated on \textsf{w}{}'s display.


\bigskip\hrule\vspace{0.1cm}
\noindent
FS\_SOLID


Define this to be the window system's solid fill style symbol.


\bigskip\hrule\vspace{0.1cm}
\noindent
FS\_STIPPLE


Define this to be the window system's stippled fill style symbol.


\bigskip\hrule\vspace{0.1cm}
\noindent
FULLARC


Window-system value for a complete (360 degree) circle or arc.


\bigskip\hrule\vspace{0.1cm}
\noindent
FWIDTH(w)


Returns the pixel width of the widest character in the current font.


\bigskip\hrule\vspace{0.1cm}
\noindent
wsp getactivewindow()


Return a window state pointer to an active window, blocking until a
window is active. Probably will be generalized to include a
non-blocking variant. Returns \textsf{NULL} if no windows are opened.


\bigskip\hrule\vspace{0.1cm}
\noindent
getbg(w, s)


Returns (writes into \textsf{s}) the current background color.


\bigskip\hrule\vspace{0.1cm}
\noindent
getcanvas(w, s)


Returns (writes into \textsf{s}) the current canvas state.


\bigskip\hrule\vspace{0.1cm}
\noindent
getdefault(w, s\_prog, s\_opt, s)


Get any window system defaults for a program named s\_prog resource
named s\_opt, write result in s.


\bigskip\hrule\vspace{0.1cm}
\noindent
getdisplay(w, s)


Write a string to s with the current display name.


\bigskip\hrule\vspace{0.1cm}
\noindent
getdrawop(w, s)


Return current drawing operation, one of various logical combinations
of source and destination bits.


\bigskip\hrule\vspace{0.1cm}
\noindent
getfg(w, s)


Returns (writes into s) the current foreground color.


\bigskip\hrule\vspace{0.1cm}
\noindent
getfntnam(w, s)


Returns (writes into s) the current font. This interface may get
changed since a portable font naming mechanism is to be
installed. Name is presently always prefixed by
{\textquotedbl}font={\textquotedbl} (pretty stupid, huh); must be an
artifact of merging window system ports, will be changed.


\bigskip\hrule\vspace{0.1cm}
\noindent
geticonic(w, s)


Return current window iconic state in s, could
{\textquotedbl}iconify{\textquotedbl} or whatever. Obsolete (subsumed
by canvas attribute, getcanvas()).


\bigskip\hrule\vspace{0.1cm}
\noindent
geticonpos(w, s)


Return icon's position to \textsf{s}, an encoded
{\textquotedbl}x,y{\textquotedbl} format string.


\bigskip\hrule\vspace{0.1cm}
\noindent
int getimstr(w, x, y, width, height, paltbl, data)


Gets an image as a string. Used in GIF code.


\bigskip\hrule\vspace{0.1cm}
\noindent
getlinestyle(w, s)


Return current line style, one of solid, dashed, or striped.


\bigskip\hrule\vspace{0.1cm}
\noindent
get\_mutable\_name(w, i)


Returns the string color name currently associated with a mutable color.


\bigskip\hrule\vspace{0.1cm}
\noindent
getpattern(w, s)


Return current fill pattern in s.


\bigskip\hrule\vspace{0.1cm}
\noindent
getpixel(w, x, y, long *rv)


Assign RGB value for pixel (x,y) into *rv.


\bigskip\hrule\vspace{0.1cm}
\noindent
getpixel\_init(w, struct imgmem *imem)


Prepare to fetch pixel values from window, obtaining contents from
server if necessary. This function does all the real work used by
subsequent calls to getpixel().


\bigskip\hrule\vspace{0.1cm}
\noindent
getpointername(w, s)


Write mouse pointer appearance, by name, to s.


\bigskip\hrule\vspace{0.1cm}
\noindent
getpos(w)


Update the window state's posx and posy fields with the current window position.


\bigskip\hrule\vspace{0.1cm}
\noindent
getvisual(w, s)


Write a string to s that explains what type of display w is on,
e.g. {\textquotedbl}visual=x,y,z{\textquotedbl}, where x is a class, y
is the bits per pixel, and z is number of colormap entries
available. This X-specific anachronism is likely to go away.


\bigskip\hrule\vspace{0.1cm}
\noindent
HideCursor(wsp ws)


Hide the text cursor on window state ws.


\bigskip\hrule\vspace{0.1cm}
\noindent
ICONFILENAME(w)


Produce char * for window's icon image file name if there is one.


\bigskip\hrule\vspace{0.1cm}
\noindent
ICONLABEL(w)


Produce char * for icon's title if there is one.


\bigskip\hrule\vspace{0.1cm}
\noindent
isetbg(w, i)


Set background color to mutable color table entry i. Mutable colors
are not available on all display types.


\bigskip\hrule\vspace{0.1cm}
\noindent
isetfg(w, i)


Set foreground color to mutable color table entry i. Mutable colors
are not available on all display types.


\bigskip\hrule\vspace{0.1cm}
\noindent
ISICONIC(w)


Return 1 if the window is presently minimized/iconic, 0 otherwise.


\bigskip\hrule\vspace{0.1cm}
\noindent
ISFULLSCREEN(w)


Return 1 if the window is presently maximized/fullscreen, 0 otherwise.


\bigskip\hrule\vspace{0.1cm}
\noindent
ISNORMALWINDOW(w)


Return 1 if the window is neither minimized nor maximized, 0 otherwise.


\bigskip\hrule\vspace{0.1cm}
\noindent
LEADING(w)


Return current integer leading, the number of pixels from line to line.


\bigskip\hrule\vspace{0.1cm}
\noindent
LINEWIDTH(w)


Return current integer line width used during drawing.


\bigskip\hrule\vspace{0.1cm}
\noindent
lowerWindow(w)


Lower the window to the bottom of the stack.


\bigskip\hrule\vspace{0.1cm}
\noindent
mutable\_color(w, dptr dp, i, C\_integer *result)


Allocate a mutable color from color spec given by \textsf{dp} and
\textsf{i}, placing result (a small negative integer) in
\textsf{*result}.


\bigskip\hrule\vspace{0.1cm}
\noindent
nativecolor(w, s, r, g, b)


Interpret a platform-specific color name s (define appropriately for
your window system). Under X, we can do this only if there is a
window.


\bigskip\hrule\vspace{0.1cm}
\noindent
pollevent()


Poll for available events on all opened displays. This is where the
interpreter calls the window system interface. Return a -1 on an
error, otherwise return count of how long before it should be polled
(400).


\bigskip\hrule\vspace{0.1cm}
\noindent
query\_pointer(w, XPoint *xp)


Produce mouse pointer location relative to w.


\bigskip\hrule\vspace{0.1cm}
\noindent
query\_rootpointer(XPoint *xp)


Produce mouse pointer location relative to root window on default screen.


\bigskip\hrule\vspace{0.1cm}
\noindent
raiseWindow(w)


Raise the window to the top of the stack.


\bigskip\hrule\vspace{0.1cm}
\noindent
bool readimage(w, s, x, y, int *status)


Read image from file s into w at (x,y). Status is 0 if everything was
kosher, 1 if some colors weren't available but the image was read OK;
if a major problem occurs it returns Failed. See loadimage() for the
real action.


\bigskip\hrule\vspace{0.1cm}
\noindent
rebind(w, w2)


Assign w's context to that of w2.


\bigskip\hrule\vspace{0.1cm}
\noindent
RECHEIGHT(rec)


The height component of an XRectangle. Gets {\textquotedbl}fixed
up{\textquotedbl} (converted) into a Y2 value if necessary, in window
system specific code.


\bigskip\hrule\vspace{0.1cm}
\noindent
RECWIDTH(rec)


The width component of an XRectangle. Gets {\textquotedbl}fixed
up{\textquotedbl} (converted) into a X2 value if necessary, in window
system specific code.


\bigskip\hrule\vspace{0.1cm}
\noindent
RECX(rec)


The x component of an XRectangle.


\bigskip\hrule\vspace{0.1cm}
\noindent
RECY(rec)


The y component of an XRectangle.


\bigskip\hrule\vspace{0.1cm}
\noindent
ROWTOY(w, i)


Return integer conversion from a 1-based text row to a pixel coordinate.


\bigskip\hrule\vspace{0.1cm}
\noindent
SCREENDEPTH(w)


Returns the number of bits per pixel.


\bigskip\hrule\vspace{0.1cm}
\noindent
int setbg(w, s)


Set the context background color to \textsf{s}. Returns
\textsf{Succeeded} or \textsf{Failed}.


\bigskip\hrule\vspace{0.1cm}
\noindent
setcanvas(w, s)


Set canvas state to \textsf{s}, make it
\textsf{{\textquotedbl}iconic{\textquotedbl}},
\textsf{{\textquotedbl}hidden{\textquotedbl}} or whatever. A canvas
value extension such as fullscreen would go here.  Changes in canvas
state are tantamount to destroying the old window, creating a new
window (with appropriate size and style) and adjusting the pixmap size
correspondingly. Much of the associated logic, however, might be
located in the event handlers for related window system events.


\bigskip\hrule\vspace{0.1cm}
\noindent
setclip(w)


Set (enable) clipping on \textsf{w} from its context.


\bigskip\hrule\vspace{0.1cm}
\noindent
setcursor(w, i)


Turn text cursor on or off. Text cursor is off (invisible) by default.


\bigskip\hrule\vspace{0.1cm}
\noindent
setdisplay(w, s)


Set the display to use for this window; fails if the window is already
open somewhere.


\bigskip\hrule\vspace{0.1cm}
\noindent
setdrawop(w, s)


Set drawing operation to one of various logical combinations of source
and destination bits.


\bigskip\hrule\vspace{0.1cm}
\noindent
int setfg(w, s)


Set the context foreground color to s. Returns Succeeded or Failed.


\bigskip\hrule\vspace{0.1cm}
\noindent
setfillstyle(w, s)


Set fill style to solid, masked, or textured.


\bigskip\hrule\vspace{0.1cm}
\noindent
bool setfont(w, char **s)


Set the context font to \textsf{s}. This function first attempts to
use the portable font naming mechanism; it resorts to the system font
mechanism if the name is not in portable syntax.


\bigskip\hrule\vspace{0.1cm}
\noindent
setgamma(w, gamma)


Set the context's gamma correction factor.


\bigskip\hrule\vspace{0.1cm}
\noindent
setgeometry(w, s)


Set the window's size and/or position.


\bigskip\hrule\vspace{0.1cm}
\noindent
setheight(w, i)


Set window height to \textsf{i}, whether or not window is open yet.


\bigskip\hrule\vspace{0.1cm}
\noindent
seticonicstate(w, s)


Set window iconic state to \textsf{s}, it could be
\textsf{{\textquotedbl}iconify{\textquotedbl}} or whatever. Obsolete;
\textsf{setcanvas()} is more important.


\bigskip\hrule\vspace{0.1cm}
\noindent
seticonimage(w, dptr d)


Set window icon to \textsf{d}. Could be string filename or existing
pixmap (i.e. another window's contents). Pixmap assignment no longer
possible, so one could simplify this to just take a string parameter.


\bigskip\hrule\vspace{0.1cm}
\noindent
seticonlabel(w, s)


Set icon's string title to \textsf{s}.


\bigskip\hrule\vspace{0.1cm}
\noindent
seticonpos(w, s)


Move icon's position to \textsf{s}, an encoded
{\textquotedbl}x,y{\textquotedbl} format string.


\bigskip\hrule\vspace{0.1cm}
\noindent
setimage(w, s)


Set an initial image for the window from file \textsf{s}. Only valid
during \textsf{open()}.


\bigskip\hrule\vspace{0.1cm}
\noindent
setleading(w, i)


Set line spacing to \textsf{i} pixels from line to line. This includes
font height and external leading, so \textsf{i {\textless} fontheight}
means lines draw partly over preceding lines, \textsf{i {\textgreater}
fontheight} means extra spacing.


\bigskip\hrule\vspace{0.1cm}
\noindent
setlinestyle(w, s)


Set line style to solid, dashed, or striped.


\bigskip\hrule\vspace{0.1cm}
\noindent
setlinewidth(w, i)


Set line width to \textsf{i}.


\bigskip\hrule\vspace{0.1cm}
\noindent
set\_mutable(w, i, s)


Set mutable color index \textsf{i} to color \textsf{s}.


\bigskip\hrule\vspace{0.1cm}
\noindent
SetPattern(w, s, s\_len)


Set fill pattern to bits given in \textsf{s}. Fill pattern is not used
unless fillstyle attribute is changed to
\textsf{{\textquotedbl}patterned{\textquotedbl}} or
\textsf{{\textquotedbl}opaquepatterned{\textquotedbl}}.


\bigskip\hrule\vspace{0.1cm}
\noindent
SetPatternBits(w, width, bits, nbits)


Set fill pattern to bits given in the array of integers named
\textsf{bits}. Fill pattern is not used unless fillstyle attribute is
changed to \textsf{{\textquotedbl}patterned{\textquotedbl}} or
\textsf{{\textquotedbl}opaquepatterned{\textquotedbl}}.


\bigskip\hrule\vspace{0.1cm}
\noindent
setpointer(w, s)


Set mouse pointer appearance to shape named \textsf{s}.


\bigskip\hrule\vspace{0.1cm}
\noindent
setpos(w, s)


Move window to \textsf{s}, a string encoded
{\textquotedbl}(x,y){\textquotedbl} thing.


\bigskip\hrule\vspace{0.1cm}
\noindent
setwidth(w, i)


Set window width to \textsf{i}, whether or not window is open yet.


\bigskip\hrule\vspace{0.1cm}
\noindent
setwindowlabel(w, s)


Set window's string title to \textsf{s}.


\bigskip\hrule\vspace{0.1cm}
\noindent
ShowCursor(wsp ws)


Show the text cursor on window state \textsf{ws}.


\bigskip\hrule\vspace{0.1cm}
\noindent
int strimage(w, x, y, width, height, e, s, len)


Draws a character-per-pixel image, used in \textsf{DrawImage()}. See
\textsf{blimage()}.


\bigskip\hrule\vspace{0.1cm}
\noindent
SysColor


Define this type to be the window system's RGB color structure.


\bigskip\hrule\vspace{0.1cm}
\noindent
TEXTWIDTH(w, s, s\_len)


Returns the integer text width of \textsf{s} using \textsf{w}{}'s current font.


\bigskip\hrule\vspace{0.1cm}
\noindent
toggle\_fgbg(w)


Swap the foreground and background on \textsf{w}.


\bigskip\hrule\vspace{0.1cm}
\noindent
unsetclip(w)


Disable clipping on \textsf{w} from its context.


\bigskip\hrule\vspace{0.1cm}
\noindent
UpdateCursorPos(wsp ws, wcp wc)


Move the text cursor on window state \textsf{ws} and context \textsf{wc}.


\bigskip\hrule\vspace{0.1cm}
\noindent
walert(w, i)


Sounds an alert (beep). \textsf{i} is a volume; it can range between
-100 and 100; 0 is normal.


\bigskip\hrule\vspace{0.1cm}
\noindent
warpPointer(w, x, y)


Warp the mouse location to (x,y).


\bigskip\hrule\vspace{0.1cm}
\noindent
wclose(w)


Closes window \textsf{w}. If there are other bindings that refer to
the window, they are converted into pixmaps, i.e.  the window
disappears but the canvas is still there and can be written on and
copied from.


\bigskip\hrule\vspace{0.1cm}
\noindent
wflush(w)


Flush output to window w; a no-op on some systems.


\bigskip\hrule\vspace{0.1cm}
\noindent
wgetq(w, dptr result)


Get an event from \textsf{w}{}'s pending queue, put results in
descriptor \textsf{*res}. Returns -1 for an error, 1 for success
(should fix this).


\bigskip\hrule\vspace{0.1cm}
\noindent
WINDOWLABEL(w)


Produce \textsf{char *} for window's title if there is one.

\bigskip\hrule\vspace{0.1cm}
\noindent



FILE *wopen(s, struct b\_list *lp, dptr attrs, i, int *err\_index, is\_3d)


Open window named s, with various attributes. This ought to be merged
from various window system dependent files, but presently each one
defines its own. Copy and modify from \textsf{rxwin.ri} or
\textsf{rmswin.ri}. The return value is really a \textsf{wbp}, cast to
a \textsf{FILE *}.


\bigskip\hrule\vspace{0.1cm}
\noindent
wputc(c, w)


Draw character \textsf{c} on window \textsf{w}, interpret newlines,
carriage returns, tabs, deletes, backspaces, and the bell.


\bigskip\hrule\vspace{0.1cm}
\noindent
wsync(w)


Synchronize server and client (a no-op on some systems).


\bigskip\hrule\vspace{0.1cm}
\noindent
xdis(w, s, s\_len)


Draw string s on window \textsf{w}, low-level.


\bigskip\hrule\vspace{0.1cm}
\noindent
XTOCOL(w, i)


Return integer conversion from a 0-based pixel coordinate to text column.


\bigskip\hrule\vspace{0.1cm}
\noindent
YTOROW(w, i)


Return integer conversion from a 0-based pixel coordinate to text row.

\section[27.8 The X Implementation]{27.8 The X Implementation}

The reference implementation of Unicon's graphics facilities is
written in terms of Xlib, the lower-level X Window C interface
[Nye88]. It does not use the X resource manager. The end result of
these two facts is that the implementation is relatively visible: the
semantics are expressed fairly directly in the source code. Although
it is necessary to understand the semantics of the underlying X
routines, hidden behavior has been minimized.

Unicon does not rely on the X Toolkit Intrinsics (Xt) or any higher
level widget set such as Motif. This guarantees that Unicon will
compile and run on any X11 platform. Unicon programs implement their
own look and feel, which may or may not be consistent with the other
applications on a given X workstation. The Unicon Program Library
includes routines that implement user interface components with an
appearance that is similar to Motif.

The X implementation employs the XPM X pixmap library if it is
available; XPM is a proposed extension to Xlib for storing color
images in external files [LeHors91]. XPM provides color facilities
analogous to the built-in X black-and-white bitmap routines. In
addition to the image formats native to each platform, Unicon also
supports GIF and JPEG as portable image file formats.

\section[27.9 The MS Windows Implementation]{27.9 The MS Windows Implementation}

The Microsoft Windows implementation of Unicon is written using Win32,
the lower-level 32-bit Windows API. It does not use the Microsoft
Foundation Classes. This makes it easier to build with different C
compilers, and easier to port to different Windows implementations,
such as Windows CE.

\subsection[27.9.1 Installing, Configuring, and Compiling the Source Code]{27.9.1 Installing, Configuring, and Compiling the Source Code}

Building Unicon for Windows requires Mingw32 GCC. We hope to add
Cygwin GCC support in the future. The sources may also build with
modest revision under MS Visual C++. You are encouraged to try
building using other compilers, and send Unicon Project your
configuration files. You will need a robust Win32 platform to compile
these sources; the build scripts and ``make'' process tend to fail on
older versions of Windows.

{\sffamily 1. Unpack the sources.}

Unpack uni.zip in such a way that it preserves its subdirectory
structure. Unzip.exe is recommended rather than WinZip.  See Icon
Project Document 243 [ipd243] for a picture of the directory
hierarchy. In particular, there should be a BIN directory along with
the SRC directory under the unicon/ directory.

{\sffamily
2. Configure the sources.}


Run {\textquotedbl}make W-Configure-GCC{\textquotedbl} (or
{\textquotedbl}make W-Configure{\textquotedbl} under MSVC) to
configure your sources to build wiconx and wicont, the Unicon virtual
machine interpreter, and the Unicon bytecode compiler, with graphics
facilities enabled.

{\sffamily
3. Compile to make executables.}


Run {\textquotedbl}make Unicon{\textquotedbl} to build the
currently-configured binary set. It is worth discussing why I provide
makefiles instead of a project file for use in the Visual C++ IDE.
The reason is that the source files for the Unicon virtual machine
interpreter (generically called iconx; wiconx.exe in this case) are
written in an extended dialect of ANSI C called RTL [ipd261]. Files in
this language have the extension .r instead of .c and .ri instead of
.h. During compilation, a program called rtt (the run time translator)
translates .r* files into .c files. If someone wants to show me how to
insert this step into the Visual C++ IDE build process, I would be
happy to use their IDE. You can write project files for the other C
programs that make up the Unicon system, but most modifications to the
language are changes to the interpreter.

{\sffamily
Notes on the MS Windows internal functions}


The functions documented here are those most likely to be involved in
projects to add features to Windows Unicon.

{\sffamily\bfseries
\bigskip\hrule\vspace{0.1cm}
\noindent
handle\_child(w, UINT msg, WPARAM wp, LPARAM lp)}


This procedure handles messages from child window controls such as
buttons. In many cases, this enqueues an event on the Unicon window.


\bigskip\hrule\vspace{0.1cm}
\noindent
int playmedia(w, char *s)


This crude function will call one of several multimedia functions
depending on whether s is the name of a multimedia file (.wav, .mid,
.rmi are supported) or an MCI command string.


\bigskip\hrule\vspace{0.1cm}
\noindent
int getselection(w, char *s)


Return the current contents of the clipboard text. The design of this
and \textsf{setselection()} need to be broadened a bit to support
images.


\bigskip\hrule\vspace{0.1cm}
\noindent
int setselection(w, char *s)


Set the clipboard text to \textsf{s}.

