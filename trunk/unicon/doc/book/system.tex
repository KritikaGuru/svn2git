\clearpage\section{Chapter 5: The System Interface}

The \index{system interface}system interface is
Unicon{\textquotesingle}s connection to the outside world. It defines
\index{input}input/\index{output}output interactions with the host
operating system. In this chapter you will learn how to

\begin{itemize}
\item Manipulate \index{file}files, \index{directories}directories, and
access \index{permissions, file access}permissions
\item Launch and interact with other programs
\item Handle abnormal events that would otherwise terminate your program
\item Write \index{Internet}Internet \index{client}client and
\index{server}server applications
\end{itemize}

\subsection{The Role of the System Interface}

Unicon{\textquotesingle}s predecessor Icon is highly portable; it runs
on everything from mainframes to Unix machines to Amigas and Macs. This
platform independence is both a virtue and a limitation. Icon takes a
greatest common denominator approach to the system interface. Icon
programs run with no source modifications across platforms, but with
little access to the underlying system. Icon historically could not be
used easily for many tasks such as system administration or
client/server programming. Both the Icon graphics facilities, and now
the Unicon system interface, {\textquotedbl}raise the
bar{\textquotedbl} of what portable facilities programmers can expect
to be provided by their programming language, at the cost of making it
more difficult to port the language to new platforms.

The functionality described in this chapter relies on underlying
standards including ANSI C{\textquotesingle}s standard input/output
library, and the IEEE Portable Application Standards
Committee{\textquotesingle}s \index{POSIX}POSIX operating system
standard (http://www.pasc.org). Unicon relies on these standards, but
is simpler and higher level. It is also less platform-specific than the
POSIX standard. Our goal was to define facilities that can be
implemented to a great extent on all modern operating systems. Icon is
fairly easily ported to all systems for which ANSI C is available.
Non-POSIX Unicon implementations may provide a subset of the
functionality described in this chapter, but important facilities such
as TCP/IP Internet communications have emerged as de facto standards
and warrant inclusion in the language definition. So far we have
implemented the complete Unicon system interface for Linux, Solaris,
and Windows; the challenge to port these facilities to all platforms on
which they are relevant and useful now rests in the hands of
Unicon{\textquotesingle}s user community.

\subsection{Files and Directories}

The file data type is used for any connection between a program and an
external piece of hardware. This model is directly supported by most
modern operating systems. In reality, a file is a
\index{reference!file}reference to one or more resources allocated by
the operating system for the purpose of input or output. Different
kinds of connections support different operations, although most kinds
of files support the basic functions given in this section.

Files are most commonly used to manipulate named repositories of data on
a storage device. The contents of files exist independently from the
program that creates them, and persist after that program completes its
execution. To read data from a file or save data to a file, the
functions \index{read()}\textsf{read()} and
\index{write()}\textsf{write()} are often used. These functions by
default use special files denoted by the keywords \index{input,
standard \&input}\textsf{\&input} and \index{output, standard
\&output}\textsf{\&output}, respectively. There is a third file
keyword, \index{error!standard, \&errout}\textsf{\&errout}, that refers
to the location to which the program should write any error messages.
Unless the files were redirected, they refer to the
\index{keyboard}keyboard and the \index{display}display. If you pass
\textsf{read()} or \textsf{write()} a value of type \textit{file} as an
argument, the operation is performed on that file. The function
\textsf{open()}\textsf{ }creates a value of type file:

\iconcode{
f := open({\textquotedbl}myfile.txt{\textquotedbl},
		{\textquotedbl}w{\textquotedbl}) \\
write(f, {\textquotedbl}This is my text file.{\textquotedbl})
}

The \index{open()}\textsf{open()} function takes two parameters: a file
name and a mode. The default mode is
\textsf{{\textquotedbl}r{\textquotedbl}} for reading; the example above
opens the file in mode \textsf{{\textquotedbl}w{\textquotedbl}} for
writing. Several other modes denote other kinds of system interfaces.
They are described in later sections.

The \textsf{read()} function reads an entire line, removing the line
termination character(s) before returning it. The \textsf{write()}
function similarly adds a line terminator(s) after the strings that it
writes. Another way to read lines is via the generate operator, unary
\textsf{!}. The expression \textsf{!f} generates all the lines of file
\textsf{f}, so \textsf{every put(L, !f)} puts all the lines of
\textsf{f} into a list named \textsf{L}.

On systems whose line terminators are multiple characters, appending an
extra letter to the mode parameter of \textsf{open()} indicates whether
newlines are to be translated (mode
\textsf{{\textquotedbl}t{\textquotedbl}}) or untranslated (mode
\textsf{{\textquotedbl}u{\textquotedbl}}). Text files generally need to
be translated, while binary files do not. The default is to translate
newlines to and from the operating system format.

Besides \textsf{read()} and \textsf{write()}, which always process a
single line of text, the functions \textsf{reads(f, i)} and
\textsf{writes(f, s, ...)} read (up to \textsf{i} characters) and write
strings to a file. These functions are not line-oriented and do no
newline processing of their own, although they still observe the
translation mode on systems that use one.

When operations on a file are complete, close the file by calling
\index{close()}\textsf{close(f)}. The only exceptions are the standard
files, \textsf{\&input}, \textsf{\&output}, and \textsf{\&errout};
since you didn{\textquotesingle}t open them, don{\textquotesingle}t
close them. For the rest, most operating systems have a limit on the
number of files that they can have open at any one time, so not closing
your files can cause your program to fail in strange ways if you use a
lot of files.

\subsubsection{Directories}

A \index{directory}directory is a special file that contains a
collection of named files. Directories can contain other directories to
form a hierarchical structure. The \index{chdir()}\textsf{chdir()}
function returns the current working directory as an absolute path
name. Called with a string argument, the
\textsf{chdir(}\textsf{\textit{dirname}}\textsf{)} function sets the
current working directory to \textsf{dirname}. The call
\textsf{open(}\textsf{\textit{dirname}}\textsf{)} opens a directory to
read its contents. Directories can only be opened for reading in this
way, not for writing. Every \textsf{read()} from a directory returns
the name of one file. Directory entries are not guaranteed to be in any
specific order. The expression \textsf{every
write(!open({\textquotedbl}.{\textquotedbl}))} writes the names of the
files in the current directory, one per line. It is not good practice
to call an \textsf{open()} that you don{\textquotesingle}t
\textsf{close()}.

The \index{mkdir()}\textsf{mkdir(s)} function creates a directory. An
optional second parameter can be used to specify access permissions for
the directory; the section on controlling file ownership and access,
below. Files or directories can be renamed with \textsf{rename(s1,s2)}.
Renaming does not physically move the file, so if \textsf{s1} and
\textsf{s2} denote locations on different hardware devices or file
systems then \index{rename()}\textsf{rename()} will fail, and you will
need to do the old {\textquotedbl}copy and then delete{\textquotedbl}
routine. Individual files or directories are removed with
\index{remove(s)}\textsf{remove(s)}. Only empty directories may be
removed. To remove an entire directory including its contents:

\iconcode{
procedure deldir(s) \\
\>   f := open(s) \\
\>   every remove( s {\textbar}{\textbar}
{\textquotedbl}/{\textquotedbl} {\textbar}{\textbar}
({\textquotedbl}.{\textquotedbl} \~{}==
({\textquotedbl}..{\textquotedbl} \~{}== !f))) \\
\>   close(f) \\
\>   remove(s) \\
end
}

How would you change this function to delete subdirectories? You might
be able to devise a brute force approach using what you know, but what
you really need is more information about a file, such as whether it is
a directory or not.

\subsubsection[Obtaining File Information]{Obtaining File Information}
\index{file!information}\textit{Metadata} is information about the file
itself, as opposed to information stored in the file. Metadata includes
the owner of the file, its size, the access rights that are granted to
users, and so forth. This information is obtained with the
\index{stat(f)}\textsf{stat()} system call. Its argument is the name of
a file or (on UNIX systems only) an open file. The \textsf{stat()}
function returns a record with the information about the file. Here is
a subset of \textsf{ls}, a UNIX program that reads a directory and
prints out information about the files in it. Keyword \index{errortext,
keyword}\textsf{\&errortext} contains information associated with the
most recent error that resulted in an expression
\index{fail!expression}failure; it is written if opening the directory
fails. This version of \textsf{ls} only works correctly if its
arguments are the names of directories. How would you modify it, using
\textsf{stat()}, to take either ordinary file names or directory names
as command line arguments?

\iconcode{
link printf \\
procedure main(args) \\
\>   every name := !args do \{ \\
\>   \ \ \ f := open(name) {\textbar} stop(\&errortext, name) \\
\>   \ \ \ L := list() \\
\>   \ \ \ while line := read(f) do \\
\>   \ \ \ \ \ \ push(L, line) \\
\>   \ \ \ every write(format(stat(n := !sort(L)), n)) \\
\>   \ \ \ \} \\
end \\
procedure format(p, name) \\
\ \ \ s := sprintf({\textquotedbl}\%-7d \%-5d \%s \%-4d \%-9d \%-9d
\%-8d \%s \%s{\textquotedbl},  \\

\ \ \ \ \ \ \ \ \ \ p.ino, p.blocks, p.mode, p.nlink, p.uid, p.gid,
p.size, \\

\ \ \ \ \ \ \ \ \ \ ctime(p.mtime)[5:17], name) \\
\>   if p.mode[1] == {\textquotedbl}l{\textquotedbl} then \\
\>   \ \ \ s {\textbar}{\textbar}:= {\textquotedbl} -{\textgreater}
{\textquotedbl} {\textbar}{\textbar} {\textbackslash}(p.symlink) \\
\>   return s \\
end
}

The record returned by \textsf{stat()} contains many fields. Not all
file systems support all of these fields. Two of the most important
portable fields are \textsf{size}, the \index{file size}file size in
bytes, and \textsf{mtime}, the file{\textquotesingle}s last
\index{file!modified time}modified time, an integer that is converted
into a human readable string format by \textsf{ctime(i)}. Another
important field is \textsf{mode}, a string that indicates the
file{\textquotesingle}s type and \index{access, file}access
permissions. Its first letter (\textsf{mode[1]}) is
\textsf{{\textquotedbl}-{\textquotedbl}} for normal files,
\textsf{{\textquotedbl}d{\textquotedbl}} for directories, and some file
systems support additional types. The other characters of the mode
string are platform dependent. On UNIX there are nine letters to encode
read, write, and execute permissions for user, group, and world, in the
format: \textsf{{\textquotedbl}rwxrwxrwx{\textquotedbl}}. On a classic
Windows FAT file system, there is only
\textsf{{\textquotedbl}rwa{\textquotedbl}} to indicate the status of
hidden, read-only, and archive bits (if it is set, the system bit is
indicated in \textsf{mode[1]}).

Some file systems support duplicate directory entries called
\textit{links} that refer to the same file. In the record returned by
\textsf{stat()}, a \index{link, file system}link is indicated by a
\textsf{mode[1]} value of \textsf{{\textquotedbl}l{\textquotedbl}}. In
addition, field \textsf{nlinks} ({\textquotedbl}number of
links{\textquotedbl}) will be \textsf{{\textgreater} 1} and/or field
\textsf{symlink} may be the string filename of which this file is an
alias. Appendix E includes information on each
platform{\textquotesingle}s support for the \textsf{mode} field, as
well as \textsf{stat()}{\textquotesingle}s other fields.

\subsubsection[Controlling File Ownership and Access]{Controlling File
Ownership and Access}

\index{file ownership}The previous section shows how different
platforms{\textquotesingle} file systems vary widely in their support
for the concepts of file ownership and access. If the system supports
ownership, the user and group that own a file are changed by calling
\textsf{chown(fname, user, group)}. The \index{chown()}\textsf{chown()}
function will only succeed for certain users, such as the super user.
User and group may be string names or integer user identity codes; this
is platform dependent.

File access rights are changed with \textsf{chmod(fname, mode)}. The
\index{chmod()}\textsf{chmod()} function only succeeds the owner of a
given file. The \textsf{mode} is a nine-letter string similar to
\textsf{stat()}{\textquotesingle}s mode field, or an octal integer
encoding that information (see Appendix E for details).

Another piece of information about files is called the
\index{umask}\textit{umask}. This is a variable that tells the system
what access rights any newly created files or directories should have.
The function call
\textsf{umask({\textquotedbl}rwxr-xr-x{\textquotedbl})} tells the
system that newly created directories should have a permission of
\textsf{{\textquotedbl}rwxr-xr-x{\textquotedbl}} and files should have
permissions of \textsf{{\textquotedbl}rw-r-{}-r-{}-{\textquotedbl}}.
The \textsf{mkdir(s, mode)} function takes an optional mode parameter,
which can override the umask for for newly created directories.
Ordinary files are never given execute permission by the system, it
must be set explicitly with \textsf{chmod()}.

\subsubsection{File Locks}

Files can be \index{file!lock}locked while a program is in the middle of
updating some information. If the contents of the file are in an
inconsistent state, other programs may be prevented from reading (or
especially writing) the file. Programs can cooperate by using file
locks:

\iconcode{
flock(filename, {\textquotedbl}x{\textquotedbl})}

The first call to \textsf{flock()} will create a lock, and subsequent
calls by other programs will cause them to block, waiting till the
writing program releases its lock. The flag
\textsf{{\textquotedbl}x{\textquotedbl}} represents an
\textit{exclusive} lock, which should be used while writing; this means
no other process can be granted a lock. For reading,
\textsf{{\textquotedbl}s{\textquotedbl}} should be used to create a
shared lock so that other programs that are also just reading can do
so. In this way you can enforce the behavior that only one process may
open the file for writing, and all others will be locked out; but many
processes can concurrently open the file for reading.

\subsection{Programs and Process Control}

Unicon{\textquotesingle}s system interface is similar but simpler and
higher level than the POSIX C interface. An include file
\textsf{posix.icn} defines constants used by some functions. Include
files are special code, consisting mainly of defined symbols, intended
to be textually copied into other code files. They are handled by the
preprocessor, described in Appendix A. To include \textsf{posix.icn} in
a program, add this line at the top of your program:

\iconcode{
\$include {\textquotedbl}posix.icn{\textquotedbl}}

When a system call \index{fail!system call}fails, the integer keyword
\textsf{\&errno} indicates the error that occurred. As seen earlier, a
human-readable string is also available in \index{errortext,
keyword}\textsf{\&errortext}. Error codes (such as \textsf{EPERM}, or
\textsf{EPIPE}) are defined in \textsf{posix.icn}; \index{errno,
keyword}\textsf{\&errno} can be compared against constants like
\textsf{ENOENT}. In general, however, human readers will prefer to
decipher \textsf{\&errortext}.

In the discussion to follow, a \textit{program} is the code that is
executed on the computer; a \index{process}\textit{process}\textit{ }is
a program in execution. This distinction is not usually important, but
for network applications it is important to understand the difference,
since the same program can run in multiple processes, and a process can
change the program that it{\textquotesingle}s running.

\subsubsection{Signals}

A \index{signal}signal is an asynchronous message sent to a process
either by the system (usually as a result of an illegal operation like
a \index{error!floating point}floating point error) or by another
process. A program has two options to deal with a signal: it can allow
the system to handle it in the default manner (which may include
termination of the process) or it can register a function, called a
signal handler, to be run when that signal is delivered.

Signals are trapped or ignored with the \textsf{trap(s, p)} function.
Argument \textsf{s} is the string name of the signal. The signal names
vary by platform; see Appendix E. You can trap any signal on any
machine; if it is not defined it will be ignored. For example, Linux
systems don{\textquotesingle}t have a \textsf{SIGLOST.} Trapping that
signal has no effect when a program runs on Linux. The \textsf{trap()}
function{\textquotesingle}s second argument is the procedure to call
when the signal is received. The previous signal handler is returned
from \index{trap()}\textsf{trap()} so it can be restored by a
subsequent call to \textsf{trap()}. The signal handler defaults to the
default provided by the system. For instance, \textsf{SIGHUP} is
ignored by default but \textsf{SIGFPE} will cause the program to
terminate.

Here is an example that handles a \textsf{SIGFPE} (floating point
exception) by printing out a message and then runs the system default
handler:

\iconcode{
global oldhandler \\
\>   ... \\
\>   trap({\textquotedbl}SIGFPE{\textquotedbl}, sig\_ignore) \\
\>   oldhandler := signal({\textquotedbl}SIGSEGV{\textquotedbl},
handler) \\
\>   ... \\
\ \ \ \# restore the old handler \\
\>   trap({\textquotedbl}SIGSEGV{\textquotedbl}, oldhandler) \\
end \\
\ \\
procedure sig\_ignore(s); end
\ \\
procedure handler(s) \\
\>   write(\&errout, {\textquotedbl}Got signal {\textquotedbl}, s) \\
\>   ({\textbackslash}oldhandler)(s) \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \# propagate the signal \\
end
}

\subsubsection[Launching Programs]{Launching Programs}

Many applications operate by executing other programs and combining
their results. In many cases, you can accomplish what you need by
calling \textsf{open()} with mode
\textsf{{\textquotedbl}p{\textquotedbl}} (for \index{pipe}pipe) to
launch a command. In this case the string argument to \textsf{open()}
is not a filename but is an entire command string. Piped commands
opened for reading (mode \textsf{{\textquotedbl}p{\textquotedbl}} or
\textsf{{\textquotedbl}pr{\textquotedbl}}) allow your program to read
the command{\textquotesingle}s standard output, while piped commands
open for writing (mode \textsf{{\textquotedbl}pw{\textquotedbl}}) allow
your program to write the command{\textquotesingle}s standard output.

A more general function for launching programs is
\textsf{system(x,f1,f2,f3,mode)}, which runs an external command on a
set of arguments given in the command argument \textsf{x}. If
\textsf{x} is a list, \textsf{x[1]} is the command to execute and the
remaining list elements are its command line arguments. If \textsf{x}
is a string, it is parsed into arguments separated by spaces. Arguments
with spaces in them may be escaped using double quotes. A program that
calls \index{system()}\textsf{system()} normally waits for the launched
program to complete before continuing, and \textsf{system()} returns
the integer status of the completed command. If \textsf{s} ends in an
ampersand (\textsf{\&}) or the optional \textsf{mode} argument is
\textsf{1} or \textsf{{\textquotedbl}nowait{\textquotedbl}},
\textsf{system()} does not wait for the command to complete, but
instead launches the command in the background and returns an integer
process id. The \textsf{system()} function takes three optional file
arguments that specify redirected standard input, output, and error
files for the launched program.

\subsubsection[Using File Redirection and Pipes]{Using File Redirection
and Pipes}

\index{file!redirection}One common scenario is for a program to run
another program but with the input and output redirected to files. On
command-line systems like the Unix shells or the MS-DOS command prompt,
you may have used redirection:

\iconcode{
\ \ \ prog {\textless} file1
}

File redirection characters and other platform-dependent operations are
supported in the command string passed to \textsf{system()}, as
illustrated by the following \textsf{system()} call:

\iconcode{
\>   system({\textquotedbl}prog {\textless} file1{\textquotedbl})
}

Pipes to and from the current program are nicely handled by the
\textsf{open()} function, but sometimes the input of one program needs
to be connected to the output of another program. You may have seen
uses like this:

\iconcode{
prog1 {\textbar} prog2
}

The \textsf{pipe()} function returns a pair of open files in a list,
with the property that anything written to the second file will appear
on the first. Here{\textquotesingle}s how to hook up a pipe between two
programs:

\iconcode{
\>   L := pipe() {\textbar}
stop({\textquotedbl}Couldn{\textquotesingle}t get pipe:
{\textquotedbl}, \&errortext) \\
\>   system({\textquotedbl}prog1 \&{\textquotedbl}, , L[2]) \\
\>   system({\textquotedbl}prog2 \&{\textquotedbl}, L[1]) \\
\>   close(L[1]) \\
\>   close(L[2])
}

\subsubsection{Process Information}

The integer process identity can be obtained with
\index{getpid()}\textsf{getpid()}. The user id of the process can be
obtained with \index{getuid()}\textsf{getuid()} if the platform
supports it. Calls to obtain additional information such as group
identity on some platforms are described in Appendix E.

A parent process may want to be notified when any of its children quit
(or change status). This status can be obtained with the function
\index{wait()}\textsf{wait()}. When a child process changes state from
{\textquotedbl}running{\textquotedbl} to either
{\textquotedbl}exited{\textquotedbl} or
{\textquotedbl}terminated{\textquotedbl} (and optionally
{\textquotedbl}stopped{\textquotedbl}), \textsf{wait()} returns a
string of the form

\iconcode{
pid:status:arg:core}

The \textsf{{\textquotedbl}:core{\textquotedbl}} will only be present if
the system created a core file for the process. The status can be any
of \textsf{{\textquotedbl}exited{\textquotedbl}},
\textsf{{\textquotedbl}terminated{\textquotedbl}} or
\textsf{{\textquotedbl}stopped{\textquotedbl}}. The \textsf{arg} field
is either: a) the exit status of the program if it exited; or b) the
signal name if it was terminated. Typically \textsf{wait()} will be
used in the handler for the \textsf{SIGCHLD} signal which is sent to a
process when any of its children changes state.

The arguments to \textsf{wait()} are the pid of the process to wait for
and any options. The default for pid is to wait for all children. The
options may be either \textsf{{\textquotedbl}n{\textquotedbl}}, meaning
\textsf{wait()} should not wait for children to block but should return
immediately with any status that{\textquotesingle}s available, or
\textsf{{\textquotedbl}u{\textquotedbl}}, meaning that any processes
that stopped should also be reported. These options may be combined by
using \textsf{{\textquotedbl}nu{\textquotedbl}}.

\subsubsection[The select() System Call]{The select() System Call}
Some programs need to be able to read data from more than one source.
For example, a program may have to handle network traffic and also
respond to the \index{keyboard}keyboard. The problem with using
\textsf{read()} is that if no input is available, the program will
block and will not be able to handle the other stream that may in fact
have input waiting on it. To handle this situation, you can use the
function \textsf{select(x1,x2,...i)}. The
\index{select()}\textsf{select()} function tells the system which files
you are interested in reading from, and when input becomes available on
any of those sources, the program will be notified. The
\textsf{select()} function takes files or lists of files as its
arguments, and returns a list of all files on which input is waiting.
If an integer argument is supplied, it is a timeout that gives the
maximum milliseconds to wait before input is available. If the timeout
expires, an empty list is returned. If no timeout is given, the program
waits indefinitely for input on one of the files.

\iconcode{
while *(L := select(f1, f2, f3, timeout)) = 0 do \\
\ \ \ \ \ \ handle\_timeout() \\
\>   (\&errno = 0) {\textbar} \\
\>   \ \ \ stop({\textquotedbl}Select \index{expression failure}failed:
{\textquotedbl}, \&errortext) \\
\ \ \ every f := !L do \{ \\
\ \ \ \ \ \ \# Dispatch reads pending on f \\
\ \ \ \ \ \ ... \\
\ \ \ \ \ \ \}
}

When using \textsf{select()} to process input from multiple files, you
may need to pay some attention to avoid blocking on any one of your
files. For example the function \textsf{read()} waits until an entire
line has been typed and then returns the whole line. Consider this
code, which waits for input from either a file (or network connection)
or a window designated by keyword \textsf{\&window}:

\iconcode{
\ \ \ while L := select(f, \&window) do \\
\ \ \ \ \ \ if !L === f then \\
\ \ \ \ \ \ \ \ \ c := read(f)
}

Just because \textsf{select()} has returned doesn{\textquotesingle}t
mean an entire line is available; \textsf{select()} only guarantees
that at least one character is available. The command shell log
application in Chapter 14 shows the usage of \textsf{select()}. Another
primary application area for \textsf{select()} is network programming,
described later in this chapter. For network connections, the function
\textsf{reads(f, i)} will return as soon as it has some input
characters available, rather than waiting for its maximum string size
of \textsf{i}. But if no input is available, reads() blocks.

\subsubsection[Non{}-blocking Input and the ready()
Function]{Non-blocking Input and the \textrm{ready()} Function}
The function \textsf{ready(f, i)} is like \textsf{reads(f, i)} except
that it is non-blocking, that is, it returns immediately with up to
\textsf{i} bytes if they are available, but it does not wait around. It
is ideal for use with \textsf{select()} and in situations where a
server or client needs to interact with multiple remote connections.

\subsection[Networking]{Networking}
\index{networking}Unicon provides a very high-level interface to
\index{Internet}Internet communications. For applications that wish to
use their own protocols, we will discuss both the major Internet
applications protocols, \index{TCP}TCP and UDP. An even higher level
interface to many popular Internet protocols such as HTTP and POP is
provided by means of Unicon{\textquotesingle}s messaging facilities.

\subsubsection{TCP}

A TCP connection is a lot like a phone call: to make a connection you
need to know the address of the other end, just like a phone number.
For TCP, you need to know the name of the machine to connect to, and an
address on that machine, called a \textit{port}. A server listens for
connections to a port; a client sends requests to a port. Also, there
are two kinds of ports, called {\textquotedbl}Internet
Domain{\textquotedbl} and {\textquotedbl}Unix Domain.{\textquotedbl}
The distinction is beyond the scope of this book; we will just mention
that Internet Domain ports are numbers, and Unix Domain ports look like
files. Also, a connection to a Unix domain port can only be made from
the same machine, so we will not consider the Unix domain further here.

A call to \textsf{open()} with mode
\textsf{{\textquotedbl}n{\textquotedbl}} (network) requests a network
connection. The first argument to \textsf{open()} is the network
address, a host:port pair for Internet domain connections, and a
filename for Unix domain sockets. If the address contains no host name
and therefore starts with \textsf{{\textquotedbl}:{\textquotedbl}}, the
socket is opened on the same machine. The value returned by
\textsf{open()} is a file that can be used in \textsf{select()} and
related system functions, as well as normal reading and writing. 

A \index{client}client uses mode
\textsf{{\textquotedbl}n{\textquotedbl}} with \textsf{open()} to open a
connection to a TCP server. Here is a simple version of the Internet
{\textquotedbl}finger{\textquotedbl} program:

\iconcode{
procedure main(argv) \\
\>   local fserv := getserv({\textquotedbl}finger{\textquotedbl})
{\textbar} \\
\>   \ \ \ stop({\textquotedbl}Couldn{\textquotesingle}t get service:
{\textquotedbl}, \&errortext) \\
\>   name := argv[1] \\
\>   host := {\textquotedbl}{\textquotedbl} \\
\>   argv[1] ? \{ \\
\>   \ \ \ name := tab(upto({\textquotesingle}@{\textquotesingle})) \&
={\textquotedbl}@{\textquotedbl} \& host := tab(0) \\
\>   \ \ \ \} \\
\>   if *host {\textgreater} 0 then
write({\textquotedbl}[{\textquotedbl}, host,
{\textquotedbl}]{\textquotedbl}) \\
\>   f := open(host {\textbar}{\textbar}
{\textquotedbl}:{\textquotedbl} {\textbar}{\textbar} fserv.port,
{\textquotedbl}n{\textquotedbl}) {\textbar} \\
\>   \ \ \ stop({\textquotedbl}Couldn{\textquotesingle}t open
connection: {\textquotedbl}, \&errortext) \\
\ \\
\>   write(f, name) {\textbar}
stop({\textquotedbl}Couldn{\textquotesingle}t write: {\textquotedbl},
\&errortext) \\
\>   while line := read(f) do \\
\>   \ \ \ write(line) \\
end
}

Notice the use of \index{getserv()}\textsf{getserv()}. The
\textsf{posix\_servent} record it returns includes fields for the name,
aliases, port, and protocol used by the Internet service indicated in
\textsf{getserv()}{\textquotesingle}s argument. The Internet protocols
specify the ports to be used for various services; for instance, email
uses port 25. Instead of having to remember port numbers or hard-coding
them in our program, we can just use the name of the service and have
\textsf{getserv()} translate that into the port number and protocol we
need to use.

To write a \index{server}server, all we need to do is add
\textsf{{\textquotedbl}a{\textquotedbl}} (accept) to the mode after the
\textsf{{\textquotedbl}n{\textquotedbl}} in \textsf{open()}. Here is a
simple TCP server that listens on port 1888:

\iconcode{
procedure main() \\
\>   while f := open({\textquotedbl}:1888{\textquotedbl},
{\textquotedbl}na{\textquotedbl}) do \{ \\
\>   \ \ \ system({\textquotedbl}myserverd -servicerequest
\&{\textquotedbl}, f, f) \\
\>   \ \ \ close(f) \\
\>   \ \ \ \} \\
\>   (\&errno = 0) {\textbar} stop({\textquotedbl}Open failed:
{\textquotedbl}, \&errortext) \\
end
}

The call to \textsf{open({\textquotedbl}:1888{\textquotedbl},
{\textquotedbl}na{\textquotedbl})} blocks until a client accesses that
port. The returned value is a file that represents the network
connection. The function \index{image()}\index{image()}\textsf{image()}
will show the IP address and port of the client machine (this is
sometimes called the \index{peername}\textit{peername}). \ This server
responds to requests by launching a separate process to handle each
request. The network connection is passed to \textsf{myserverd} as its
standard input and output, so that process had better be expecting a
socket as its standard I/O files, and must handle it appropriately.
This works on UNIX; on other platforms a different approach is needed.

Launching a separate process to handle requests is standard operating
procedure for many Internet servers, but besides the portability
concerns, it uses a lot of memory and CPU time. Many servers can be
implemented in a single process. Chapter 15 includes an example of such
a server. \ Mode \textsf{{\textquotedbl}na{\textquotedbl}} is less than
ideal for one-process servers: it only supports one connection at a
time. When waiting for a new connection, the process is not doing any
computation, and when servicing a connection, the program is not
listening for any other connection requests. Unless each connection is
of short duration, the server will appear to be down, or appear to be
unacceptably slow, to anyone trying to connect while an existing
request is being processed.

\subsubsection[Non{}-blocking Network Opens]{\sffamily Non-blocking
Network Opens}
Servers need to never block. The call
\textsf{open({\textquotedblleft}:port{\textquotedblright},{\textquotedbl}nl{\textquotedbl})}
\ creates a \textit{listener} on the specified port, without waiting
around for someone to actually connect to it. The network file returned
from \textsf{open()} is not open for reading or writing, so it is not
good for much...yet. About the only thing you can do with such a file
is include it (along with any other network connections you have going)
as an argument in a call to \textsf{select()}. If a listener matches a
current connection request, \textsf{select()} converts it into a
regular network connection as per mode
\textsf{{\textquotedbl}na{\textquotedbl}}.

In addition to non-blocking server connections, in the real-world
clients need a way to do an almost non-blocking connection as well.
TCP{\textquotesingle}s connecting over long distances

\subsubsection{UDP}

\index{UDP}UDP is another protocol used on the Internet. TCP is like a
phone call: all messages you send on the connection are guaranteed to
arrive in the same order they were sent. UDP on the other hand is more
like the postal service, where messages are not guaranteed to reach
their destination and may not arrive in the same order they were sent
in. Messages sent via UDP are called \textit{datagrams}.
It{\textquotesingle}s a lot cheaper (faster) to send UDP messages than
TCP, though, especially if you are sending them across the Internet
rather than to a local machine. Sending a postcard is usually cheaper
than a long distance phone call!

UDP datagrams can be sent in two ways: with an \textsf{open()/writes()}
pair, or with \textsf{send()}. Typically a server sends/receives on the
same socket so it will use \textsf{open()} with \textsf{read()} and
\textsf{write()}. A client that only sends one or two datagrams might
use
\index{send()}\textsf{send()}\textsf{/}\index{receive()}\textsf{receive()}.

The following example provides a service called
{\textquotedbl}rdate{\textquotedbl} that allows a program to ask a
remote host what time it has. The server waits for request datagrams
and replies with the date and time. The
\textsf{{\textquotedbl}u{\textquotedbl}} flag added to the mode in the
call to \textsf{open()} signifies that a UDP connection should be used.
The function \textsf{receive()} waits for a datagram to arrive, and
then it constructs a record having the address the message came from
and the message in it. The server uses the address to send the reply.

\iconcode{
\ \ \ f := open({\textquotedbl}:1025{\textquotedbl},
{\textquotedbl}nua{\textquotedbl}) \\
 \ \ while r := receive(f) do \{ \\
\ \ \ \ \ \ \# Process the request in r.msg \\
\ \ \ \ \ \ ... \\
\ \ \ \ \ \ send(r.addr, reply) \\
\ \ \ \ \ \ \}
}

The record returned by \textsf{receive()} has two fields: the
\textsf{addr} field contains the address of the sender in
\textsf{{\textquotedbl}}\textsf{\textit{host}}\textsf{:}\textsf{\textit{port}}\textsf{{\textquotedbl}}
form, and the \textsf{msg} field contains the message.

To write a UDP client, you use mode
\textsf{{\textquotedbl}nu{\textquotedbl}}, illustrated in the following
example. Since UDP is not reliable, the \textsf{receive()} is guarded
with a \textsf{select()}; otherwise, the program might hang forever if
the reply is lost. The timeout of five seconds in the call to
\textsf{select()} is arbitrary and might not be long enough on a
congested network or to access a very remote host. Notice the second
argument to \textsf{getserv()}; it restricts the search for Internet
service information to a particular network protocol, in this case UDP.

\iconcode{
procedure main(args) \\
\>   (*args = 1) {\textbar} stop({\textquotedbl}Usage: rdate
host{\textquotedbl}) \\
\>   host := args[1] \\
\>   s := getserv({\textquotedbl}daytime{\textquotedbl},
{\textquotedbl}udp{\textquotedbl}) \\
\>   f :=
open(host{\textbar}{\textbar}{\textquotedbl}:{\textquotedbl}{\textbar}{\textbar}s.port,
{\textquotedbl}nu{\textquotedbl}) {\textbar} \\
\>   \ \ \ stop({\textquotedbl}Open failed: {\textquotedbl},
\&errortext) \\
\>   writes(f, {\textquotedbl} {\textquotedbl}) \\
\>   if *select(f, 5000) = 0 then \\
\>   \ \ \ stop({\textquotedbl}Connection timed out.{\textquotedbl}) \\
\>   r := receive(f) \\
\>   write({\textquotedbl}Time on {\textquotedbl}, host,
{\textquotedbl} is {\textquotedbl}, r.msg) \\
end
}

From these examples you can see that it is relatively easy to write
programs that use Internet communication. But TCP and UDP are very
general, somewhat low-level protocols; most programs employ a
higher-level communication protocol, either by defining their own, or
using a standard protocol. If you need to define your own Internet
protocol, you can do it on top of TCP or UDP; if your program needs to
use a standard Internet protocol, you should check first to see if the
protocol is built-in to the language as part of the messaging
facilities, described in the next section.

\subsection{Messaging Facilities}

Unicon{\textquotesingle}s \index{messaging}messaging facilities provide
higher level access to many popular Internet protocols. A call to
\textsf{open()} using mode \textsf{{\textquotedbl}m{\textquotedbl}}
establishes a messaging connection. The filename argument to a
messaging connection is a URI (Uniform Resource Indicator) that
specifies the protocol, host machine, and resource to read or write.
The protocols implemented thusfar are HTTP, Finger, SMTP, and POP.
Extra arguments to open() are used to send headers defined by the
protocol. For example, the call

\iconcode{
open({\textquotedbl}mailto:unicon-group{\textquotedbl}, {\textquotedbl}m{\textquotedbl}, {\textquotedbl}Reply To: jeffery@cs.uidaho.edu{\textquotedbl})}

\noindent
supplies a Reply To field as a third parameter to \textsf{open()} on an
SMTP connection.

Header fields from the server{\textquotesingle}s response to a
connection can be read by subscripting the value returned from
\textsf{open()} with a string header name; an example is in the next
section.

\subsubsection{HTTP}

\index{HTTP}HTTP is used to read or write to Web servers; the content
read or written typically consists of \index{HTML}HTML text. The
following program, \textsf{httpget.icn}, fetches a remote file
specified by a URI on the command line, and saves it as a local file.
The Icon Program Library module \textsf{basename} is used to extract
the filename from the URI.

\iconcode{
link basename}

\iconcode{
procedure main(argv) \\
\>   f1 := open(argv[1],{\textquotedbl}m{\textquotedbl}) \\
\>   f2 := open(basename(argv[1]),{\textquotedbl}w{\textquotedbl}) \\
\>   while write(f2, read(f1)) \\
end
}

This example retrieves the actual data for a successful HTTP request;
for a failed request the connection returns no data, appearing to be an
empty file. Programs can check the HTTP status code in order to
determine the nature of the problem. Status codes and other metadata
from HTTP header lines are inspected by subscripting the connection
with the desired header. For example, in the previous program, checking
\textsf{f1[{\textquotedbl}Status-Code{\textquotedbl}]} would allow us
to detect HTTP errors, and
\textsf{f1[{\textquotedbl}Location{\textquotedbl}]} would allow us to
find the new location of the file, if the HTTP server had informed us
that the file had moved. You can retrieve this status information on a
remote file without retrieving the file itself. If you open a URI with
mode \textsf{{\textquotedbl}ms{\textquotedbl}} instead of
\textsf{{\textquotedbl}m{\textquotedbl}}, an HTTP request for header
information is made, but no data is retrieved.

\subsubsection{SMTP and POP}

\index{SMTP}SMTP is used to send a mail message. Mail is delivered via
an SMTP server machine on which the user must have a valid account.
These default to the current user on the current host machine. Two
environment variables UNICON\_SMTPSERVER and UNICON\_USERADDRESS can be
set to override the default behavior.

\index{POP}POP is used to read mail messages. POP is the least file-like
of these protocols. A POP connection feels like a list of strings, each
string containing an entire mail message, rather than a simple sequence
of bytes. Function \textsf{read()} and operator \textsf{!} produce
entire messages which in general contain many newline characters. POP
messages may be removed by either \index{delete()!from POP
mail}\textsf{delete()} or \index{pop()!from POP mail}\textsf{pop()};
messages are buffered in such a way that message removal on the server
occurs when the connection is explicitly and successfully closed.

Here{\textquotesingle}s a simple program that illustrates the use of
msesaging to get email from a POP server. It gets messages from the
server without deleting them and, for every message, prints out who the
message is from as well as the subject line.

\iconcode{
procedure main(argv) \\
\>   user := argv[1] {\textbar}
getenv({\textquotedblleft}USER{\textquotedblright}) {\textbar}
stop({\textquotedblleft}no user{\textquotedblright}) \\
\>   passwd := argv[2] {\textbar}
getenv({\textquotedblleft}PASSWD{\textquotedblright}) {\textbar}
stop({\textquotedblleft}no password{\textquotedblright}) \\
\>   server := argv[3] {\textbar}
getenv({\textquotedblleft}MAILHOST{\textquotedblright}) {\textbar}
{\textquotedblleft}mailhost{\textquotedblright} \\
\>   conn :=
open({\textquotedblleft}pop://{\textquotedblright}{\textbar}{\textbar}user{\textbar}{\textbar}{\textquotedblright}:{\textquotedblright}{\textbar}{\textbar}passwd{\textbar}{\textbar}{\textquotedblright}@{\textquotedblright}{\textbar}{\textbar}server,
{\textquotedblleft}m{\textquotedblright}) {\textbar} \\
\>   \ \ \ stop({\textquotedblleft}couldn{\textquotesingle}t connect to
the POP server {\textquotedblleft}, server) \\
\>   every msg := !conn do msg ? \\
\>   \ \ \ while line :=
tab(find({\textquotedblleft}{\textbackslash}n{\textquotedblright})) do \\
\>   \ \ \ \ \ \ if =({\textquotedblleft}From: {\textquotedblleft}
{\textbar} {\textquotedblleft}Subject: {\textquotedblleft}) then
write(line) \\
\>   close(conn) \\
end
}

You should improve the password handling in this program if you use it!
Chapter 14 includes another useful example use of
Unicon{\textquotesingle}s POP messaging facilities: a spam filter.

\subsection{Tasks}

Unicon{\textquotesingle}s tasking facilities are a refinement of work
done originally as a specialized Icon virtual machine called MT Icon. A
task is the virtual machine execution state of a program. The tasking
facilities allow Unicon programs to load, execute, communicate with,
and control one another, all within a single instantiation of the
Unicon interpreter. 

Although Unicon programs can use the tasking facilities to load and
execute any number of other programs within the same interpreter space,
the tasking facilities do not introduce a concurrent programming
construct nor do they include special support for multiprocessor
hardware. Their domain is that of high-level language support for
programs that benefit from or require a tighter coupling than that
provided by inter-process communication; that is, programs that access
each other{\textquotesingle}s state extensively.

Co-expressions provide the tasking facilities{\textquotesingle} program
execution model, and co-expression activation serves as the
communication mechanism. The extensions are general enough to be useful
in a wide variety of contexts. For example, programs that use the
multi-tasking interface can communicate directly without resorting to
external files or pipes.

At the language level, the tasking facilities are comprised of several
built-in functions and keywords, but no new types, declarations, or
control structures. Several existing functions have been extended to
offer additional support for the multi-tasking environment. The
interpreter creates separate memory allocation regions for each task. 

\subsubsection[Preliminary Terminology]{Preliminary Terminology}

Before describing the task model, a few definitions are needed. These
definitions pertain to regions of memory referenced by programs during
execution. 

A \textit{name space} is a mapping from a set of program source-code
identifiers to a set of associated memory locations [Abelson85]. Icon
programs have a global name space shared across the entire program and
various name spaces associated with procedures. Procedures each have a
static name space consisting of memory locations shared by all
invocations of the procedure and local name spaces private to each
individual invocation of the procedure.\newline
\newline
When a co-expression is created, a new local name space is allocated for
the currently executing procedure, and the current values of the local
variables are copied into the new name space for subsequent use by the
co-expression. 

An Icon program has an associated \textit{program state} consisting of
the memory associated with global and static name spaces, keywords, and
dynamic memory regions. Similarly, a co-expression has an associated
\textit{co-expression state} consisting of an evaluation stack that
contains the memory used to implement one or more local name spaces.
Co-expressions in an Icon program share access to the program state and
can use it to communicate. 

\subsubsection{Tasks: an extended co-expression model}

A task is the execution state of a program within the virtual machine
[Griswold86]. A single task called the root is created when the
interpreter starts execution. Additional tasks can be created
dynamically as needed.

A task consists of a main co-expression and zero or more child
co-expressions that share a program state. At the source-language
level, tasks are loaded, referenced, and activated solely in terms of
one of their member co-expressions; the task itself is
implicit.

This definition of tasks is related to the concept of the same name
commonly used in operating systems and concurrent programming
languages. It differs, however, in certain fundamental respects. Icon
is a sequential language; co-expressions in Icon provide a synchronous
coroutine execution model, not a concurrent execution model with
implicit task switching and scheduling. Another way to view this is
that unlike other languages such as Ada, Unicon provides the task model
as a mechanism for multi-tasking, but does not predefine the policy;
matters such as the scheduling algorithm used and whether multi-tasking
is co-operative or pre-emptive are programmable at the user
level.

Another useful comparison can be made between Icon tasks and Smalltalk
processes. Both provide pseudo-concurrency within the context of a
sequential virtual machine. Since Unicon tasks have their own dynamic
memory regions, their presence affects each other less than Smalltalk
processes affect each other. For example, if one task is exhibiting
thrashing heap behavior in which garbage collections are frequent, the
other tasks in the system can execute at full speed during the portion
of time in which they are running, since they do not allocate memory
out of the thrashing task{\textquotesingle}s (full) heap. This minimal
effect of tasks on each others{\textquotesingle} behavior is especially
important in the domain of execution monitoring. 

\subsubsection{Task creation}

A task can create other tasks. The function 

\iconcode{
load(s, L, f1, f2, f3, i1, i2, i3)}

\noindent loads an icode file [Griswold86] specified by the file name
\textstyleSourceText{\textrm{s}}, creates a task for it and returns a
co-expression corresponding to the invocation of the procedure
\textstyleSourceText{\textrm{main(L)}} in the loaded icode file.
\textstyleSourceText{\textrm{L}}\textstyleSourceText{ }defaults to the
empty list. Unlike conventional Icon command-line argument lists, the
argument list passed to\textstyleSourceText{
}\textstyleSourceText{\textrm{load()}} can contain values of any type,
such as procedures, lists, and tables in the calling task.

The task being loaded is termed the child task, while the task calling
\textstyleSourceText{\textrm{load()}} is termed the parent. The
collection of all tasks forms a tree of parent-child
relationships.

\textstyleSourceText{\textsf{f1}}, \textstyleSourceText{\textsf{f2}},
and \textstyleSourceText{\textsf{f3}}\textstyleSourceText{ }are file
arguments to use as \textstyleSourceText{\textsf{\&input}},
\textstyleSourceText{\textsf{\&output}}, and
\textstyleSourceText{\textsf{\&error}} in the loaded task;
\textstyleSourceText{\textsf{\&input}},
\textstyleSourceText{\textsf{\&output}}, and
\textstyleSourceText{\textsf{\&error}}\textstyleSourceText{\textrm{
}}default to those of the loading task.\textstyleSourceText{\textrm{
}}\textstyleSourceText{\textsf{i1,}} \textstyleSourceText{\textsf{i2}},
and \textstyleSourceText{\textsf{i3}} are three integer arguments that
supply initial region sizes for the task{\textquotesingle}s block,
string, and stack memory areas, respectively.
\textstyleSourceText{\textsf{i1}} and \textstyleSourceText{\textsf{i2}}
default to 65000, while \textstyleSourceText{\textsf{i3 }}defaults to
20000 (the defaults may be changed by the environment variables
\textstyleSourceText{\textsf{BLKSIZE}},
\textstyleSourceText{\textsf{STRSIZ}}\textsf{E}, and
\textstyleSourceText{\textsf{MSTKSIZE}}). 

\subsubsection{Running other programs}

A co-expression created by \textstyleSourceText{\textsf{load()}} is
activated like any other co-expression. When activated with the
\textstyleSourceText{\textsf{@}} operator, the child task begins
executing its main procedure. Unless it suspends or activates
\textstyleSourceText{\textsf{\&source}}, the child task runs to
completion, after which control is returned to the parent. Chapter 5
presents an alternative means of executing a child with which the
parent retains control over the child as it executes. 

This default behavior is illustrated by the program
\textstyleSourceText{\textsf{seqload}}, which loads and executes each
of its arguments (string names of executable Icon programs) in turn. In
this program the variable arguments is a list of strings passed into
the Icon program from the operating system. Each of these strings
(extracted from the list using the element-generation operator,
\textstyleSourceText{\textsf{!}}) is passed in turn to
\textstyleSourceText{\textsf{load()}}\textsf{.
}\textstyleSourceText{\textsf{load()}} reads the code for each argument
and creates a task in which to execute the loaded program; the tasks
are then executed one-by-one by the co-expression activation operator,
\textstyleSourceText{\textsf{@}}. This is ordinary Icon code; there is
nothing special about this example except the semantics of the
\textstyleSourceText{\textsf{load()}} function and the independent
execution environment (separate global variables, heaps, and so forth),
that \textstyleSourceText{\textsf{load()}}\textstyleSourceText{
}provides to each task. 

\iconcode{
\# seqload.icn \\
procedure main(arguments) \\
\>   every @load(!arguments) \\
end
}

For example, if three Icon programs whose executable files are named
translate, assemble, and link are to be run in succession, the command 

\iconcode{
\textstyleSourceText{\textsf{seqload translate assemble link}}}

\noindent
executes the three programs without reloading the interpreter for each
program. 

\subsubsection{Data access}

Although tasks have separate program states, they reside in the same
address space and can share data; values can be transmitted from task
to task through
\textstyleSourceText{\textsf{main()}}{\textquotesingle}s argument list,
through co-expression activation, or by use of event monitoring
facilities described in [Griswold92b]. In the following pair of
programs, the parent receives a list value from the child and writes
its elements out in reverse order. 

\iconcode{
\# parent.icn \\
procedure main() \\
\>   L := @ load({\textquotedbl}child{\textquotedbl}) \\
\>   while write(pull(L)) \\
end \\
\ \\
\# child.icn \\
procedure main() \\
\>   L := [ ] \\
\>   while put(L, read()) \\
\>   return L \\
end
}

This data access applies to all first-class data objects in Icon, such
as procedures and co-expressions. 

\subsubsection{Shared icode libraries}

Programs that are written to take advantage of the multi-tasking
environment gain in space efficiency and modularity. Code sharing is
one natural way to achieve space efficiency in a collection of
programs. Since procedures are first-class data values in Icon, code
sharing can be implemented via data sharing. Programs executing in a
single invocation of the interpreter can share code easily if the code
is not required to produce side effects on global variables in the
calling task{\textquotesingle}s program state. If side-effects to the
calling task{\textquotesingle}s program state are required, the shared
code must generally be written with care to explicitly reference the
calling task{\textquotesingle}s state. Side effects in the client task
can also be achieved through the parameters passed in and results
obtained by calling the shared procedure. 

\subsubsection{Loading shared code}

Consider a collection of applications that make extensive use of
procedures found in the Icon program library (IPL) [Griswold90c]. If
those applications are run using MT Icon, the IPL routines need be
loaded only once, after which they may be shared.

In order to reference shared code from a loaded task, two additional
considerations must be satisfied: the shared code must be loaded, and
the client tasks must be able to dynamically link shared routines into
their generated code.

Both of these problems can be solved entirely at the source level: In
order to introduce a shared Icon procedure into the name space, a
global variable of the same name must be declared. Managing the loading
of shared libraries is itself a natural task to assign to an Icon
procedure that uses a table to map strings to the pointers to the
procedures in question. 

\subsubsection{Code sharing example}

The following collection of three programs illustrate one schema that
allows code sharing. Other conventions can certainly be devised, and
much of the sharing infrastructure presented here can be automatically
generated. Program calc.icn consists of a shared library procedure
named \textstyleSourceText{\textsf{calc()}} and a main procedure that
exports a reference to \textstyleSourceText{\textsf{calc()}} for
sharing: 

\iconcode{
\# calc.icn \\
procedure calc(args...) \\
\>   \# code for calc \\
\>   \# (may call other routines in calc.icn if there are any) \\
end \\
\ \\
procedure main() \\
\>   \# initialization code, if any \\
\>   return calc \\
end
}

Note that a module exporting shared procedures can also have global
variables (possibly initialized from other command-line arguments).
Shared modules can export other values besides procedures using the
same mechanism.

The parent task that loads the various shared library clients implements
a procedural encapsulation (\textstyleSourceText{\textsf{loadlib()}} in
this example) of an Icon table to store references to shared routines.
The parent passes this procedure to clients. Each client calls the
procedure for each shared routine. Routines that are already loaded are
returned to requesting tasks after a simple Icon table lookup. Whenever
a routine is requested that has not been loaded, the
\textstyleSourceText{\textsf{load()}} function is called and the shared
library activated. 

\iconcode{
procedure main(arguments) \\
\>   @load({\textquotedbl}client{\textquotedbl},put(arguments,loadlib)) \\
end \\
\ \\
procedure loadlib(s, C) \\
\>   static sharedlib \\
\>   initial sharedlib := table() \\
\>   sharedlib[s] := @load(s) \\
\>   variable(s, C) := sharedlib[s] \\
end
}

A client of \textstyleSourceText{\textsf{calc}} declares a global
variable named \textstyleSourceText{\textrm{calc}}, and assigns its
value after inspecting its argument list to find the shared library
loader: 

\iconcode{
global loadlib \\
global calc \\
procedure main(arguments) \\
\>   if /loadlib then stop({\textquotedbl}no shared libraries
present{\textquotedbl}) \\
\>   loadlib({\textquotedbl}calc{\textquotedbl}, \&current) \\
\>   \# ... remainder of program may call shared calc \\
end
}

\subsubsection{Sharing procedure collections}

The primary deficiency of the previous example is that it requires one
shared library procedure per Icon module, that is, separate
compilation. In practice it is more convenient to have a collection of
related procedures in a given Icon compilation unit. Shared libraries
can employ such a mechanism by resorting to a simple database that maps
procedure names to load modules. 

\subsection{Monitoring Facilities}

Unicon{\textquotesingle}s execution monitoring facilities were developed
for Clint Jeffery{\textquotesingle}s dissertation and are presented in
detail in {\textquotedblleft}Program Monitoring and Visualization: an
Exploratory Approach{\textquotedblright}. This section provides a
summary. Unlike in MT Icon, Unicon{\textquotesingle}s monitoring
facilities impose no noticeable performance cost when they are not in
use, so they are incorporated as a standard feature of the language and
always available.

Generally, a program monitors another program by loading it as a task,
and requesting program execution behavior \textit{events} from it when
it activates it as a co-expression. An event is a unit of program
execution behavior, consisting of an \textit{event code}, which is a
one letter string that indicates what the program is doing, and an
\textit{event value}, an associated piece of data that is being read,
written, or manipulated at the time of the event. There are
approximately 120 kinds of events with different codes. Observing all
of them is a compute-intensive task, resulting in many co-expression
switches per executing line of source code in the program being
monitored.

A program calls \textsf{EvGet(c, C)} to request events when activating a
program denoted by co-expression \textsf{C}, instead of using the usual
activate (\textsf{@}) operator. Cset \textsf{c} is an \textit{event
mask} that provides a filter to select the event codes of interest. As
the program executes and events occur, their codes are checked and for
those that are in the event mask, a co-expression switch reports the
event back by returning from \textsf{EvGet()} in the monitor.

There is a strong, if implicit distinction between activating a program
in order to monitor it, and activating a program normally. When a
program requests events using \textsf{EvGet()} it is playing an
observer role, not a peer role, with the task it is monitoring. The
program being observed is generally not aware of the monitoring that is
going on. It does not usually activate the monitor task explicitly or
communicate with it directly. Instead, it is the language virtual
machine and runtime system that is reporting what is going on by
activating the monitoring task.

At present, the only program to which a monitored program will report
events is the program that loaded it -- its parent. The parent,
however, may \textit{forward} program execution events to other tasks,
allowing them to observe the same behavior that it sees. The function
\textsf{EvSend(code, value, C)} transmits an event to co-expression
\textsf{C}.

Some types of events are very frequent, frequent enough that processing
all of them may be unacceptably slow, if a monitor only needs a tiny
subset of those events in order to do its job. \ Good examples are
virtual machine instruction events, and source code line number change
events. If a monitor only needs to observe specific VM instructions, or
be informed when a program reaches certain line numbers, it requires an
additional means of filtering events of interest.

\section*{Summary}

Unicon{\textquotesingle}s system facilities provide a high-level
interface to the most common features of modern operating systems, such
as directories and network connections. This interface is vital to most
applications, and it also presents the main portability challenges,
since Unicon has a design goal that most applications should require no
\index{source code}source code changes and no conditional code needed
to run on most operating systems. Of course some application domains
such as system administration are inevitably platform dependent.

There are two major areas of the system interface that are whole
application domains extensive enough to warrant an entire chapter of
their own: \index{database}databases and graphics. Databases can be
viewed as a hybrid of the file and directory system interface with some
of the data structures described in Chapter 2. Since many databases are
implemented using a client/server architecture, the database interface
also includes aspects of networking. Databases are presented in the
Chapter 6.

Graphics is another crucial component of the system interface, rich
enough to warrant special features built-in to the language, and deep
enough to warrant an entire book. Like databases, graphics can be
viewed as an extension of the file data type described in this chapter.
Unicon{\textquotesingle}s powerful 2D and 3D graphics facilities are
discussed in Chapter 7.

