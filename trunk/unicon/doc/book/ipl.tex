\clearpage\section{Appendix B: The Icon Program Library}

The \index{Icon Program Library}Icon Program Library (IPL) includes
literally hundreds of complete programs ranging from simple
demonstrations to complex applications. More importantly, it offers
hundreds of library modules with over a thousand procedures that can
save you a lot of effort. To use these procedures in your own programs,
you add \index{link}link declarations. The IPL is generally unpacked in
its own directory hierarchy. Unicon knows the location of the IPL
hierarchy relative to the Unicon binaries. If you move these binaries
or wish to add your own directories of reusable code modules, you must
set your \index{environment variable!IPATH}IPATH (and often your LPATH)
\index{environment variable!LPATH}environment variables so they know
where to find the IPL directories, in addition to any of your own you
wish to add. Both IPATH and LPATH are space-separated lists of
directories. The names IPATH and LPATH may be misleading; IPATH
directories are searched for precompiled u-code modules with .u
extensions, while LPATH directories are searched for
\$include{\textquotesingle}d \index{source code}source code files with
the .icn extension.

The Icon Program Library consists of approximately 20
directories of code, data, and supporting documentation. This material
is included in its entirety in the Unicon distributions. Documenting
the entire library would require many hundreds of pages.
This appendix serves as a reference summary. It presents details for
the most useful, general,
and portable components of the IPL, a sort of
{\textquotedbl}Best of the Icon Program
Library{\textquotedbl} collection of potential value to other programmers.
Many modules were written by Icon creator Ralph Griswold; if he was not
the author of a given module,
the initials of authors are included in the module description. A list of
authors{\textquotesingle} names appears at the end of the appendix. This
appendix no doubt overlooks some excellent library modules and programs.
The entries in this appendix loosely follow this template:

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filename}}

Each module has one or more paragraphs of general description, ending
with the authors{\textquotesingle} initials in parentheses. After the
description, if the module consisted of more than a single procedure,
the external interface of the module is summarized. The external
interface consists of procedures, record types and global variables.
The number and type of each procedure{\textquotesingle}s parameters and
return values are given. Library procedures can be expected to return a
null value unless otherwise noted. The filename at the beginning is
what you \index{link}link in order to use these procedures in your
programs. After the external interface is summarized, related modules
are listed.

record types(fields) with summary descriptions\\
functions(parameters) : return types with summary descriptions

Links: other library modules (author{\textquotesingle}s initials)

\subsection{Procedure Library Modules}

These files appear in the \texttt{ipl/procs/} directory. Each library
module in this directory is a collection of one or more procedures.
Some modules also introduce record types or use global variables that
are of interest to programmers that use the module.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{adlutils}}

This module is for programs that process address lists: Addresses are
represented using a record type \texttt{label}. Procedures for
extracting the city, state, and ZIP code work for U.S. addresses only.

\textsf{record label(header, text, comments)} holds one address\\
\textsf{nextadd() : label} produces the next address from standard
input\\
\textsf{writeadd(label)} writes an address to standard output\\
\textsf{get\_country(label) : string} produces the country from an
address\\
\textsf{get\_state(label) : string} produces the state from an address,
or \textsf{{\textquotedbl}XX{\textquotedbl}} if no state \\
\ \ \ \ \ \ \ \ \ \ is found\\
\textsf{get\_city(label) : string} produces the city from an address\\
\textsf{get\_zipcode(label) : string} produces the city from an address\\
\textsf{get\_lastname(label) : string} get last name\\
\textsf{get\_namepfx(label) : string} get name prefix\\
\textsf{get\_title(label) : string} get name title\\
\textsf{format\_country(string) : string} format country name using
initial capital letters.

Links: lastname, io, namepfx, title 

% {\sffamily\bfseries ansi }
% 
% This module implements a subset of the \index{ANSI terminal}ANSI
% terminal control sequences. The procedures{\textquotesingle} names are
% taken directly from the ANSI names. To use these routines with non-ANSI
% devices, link in \textsf{iolib} and (optionally) \textsf{iscreen}. Not
% all ANSI terminals support even the limited subset of control sequences
% included in this file. (REG, RLG)
% 
% \textsf{CUB(i:integer)} moves the cursor left i columns\\
% \textsf{CUD(i:integer)} moves the cursor down i rows\\
% \textsf{CUF(i:integer)}\ \ moves the cursor right i columns\\
% \textsf{CUP(i:integer,j:integer)} moves the cursor to row i, column
% j\\
% \textsf{CUU(i:integer)} moves the cursor up i rows\\
% \textsf{ED(i:integer:2)} erases \index{screen}screen: i = 0: \ to end; i
% = 1: from beginning; i = 2, all\\
% \textsf{EL(i:integer:0)} erases current row: i = 0: to end; i = 1: from
% beginning; i = 2, all\\
% \textsf{SGR(i:integer:0)} sets \index{attribute!video}video attributes:
% 0:off; 1:bold; 4:underline; 5:blink; 7:reverse 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{apply}}

\index{apply()}\textsf{apply(L:list, argument):any} applies a list of
functions to an argument. An example is
\textsf{apply([integer,log],10)} which is equivalent to
\textsf{integer(log(10))}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{argparse}}

\textsf{argparse(s:string):list} parses \textsf{s} as if it was a
command line and puts the components in a list, which is returned. At
present, it does not accept any escape conventions. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{array}}

This module provides a \index{multidimensional array}multidimensional
array abstraction with programmer-supplied base indices.

\textsf{create\_array(lbs:list, ubs:list, value):array} creates an
n-dimensional array with specified lower bounds, upper bounds, and with
each array element having the given initial value.

\textsf{ref\_array(A, i1, i2, ...)} references the i1-th i2-th ...
element of A. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{asciinam}}

\texttt{asciiname(s:string):string} returns the mnemonic name of the
single unprintable ASCII character \texttt{s}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{base64}}

This module provides base64 encodings for \index{MIME}MIME (RFC 2045).
Among other things, this facilitates the writing of programs that read
e-mail messages.

\texttt{base64encode(string) : string} returns the base64 encoding of
its argument.\\
\texttt{base64decode(string) : string?} returns a base64 decoding of its
argument. It fails if the string is not base64 encoded. (DAG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{basename}}

\index{basename}\textsf{basename}\textsf{(name, suffix) : string} strips
off any path information and removes the specified suffix, if present.
If no suffix is provided, the portion of the name up to the first
{\textquotedbl}.{\textquotedbl} is returned. It works under at least
UNIX, MS-DOS, and the Macintosh. (REG, CAS)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{binary}}

These procedures support conversion of Icon data elements
to and from binary data formats. The control procedures \textsf{pack()}
and \textsf{unpack()} take a format string that controls conversions of
several values, similar to the \textsf{printf()} C library function.

\textsf{pack(template,
}\textsf{\textit{value}}\textsf{\textit{\textsubscript{1}}}\textsf{,
...) : packed\_binary\_string}\texttt{ }packs the \textit{value}
arguments into a binary structure, returning a string containing the
structure. The elements of any lists in the \textit{value} parameters
are processed individually as if they were spliced into the
\textit{value} parameter list. The \textsf{template} characters give
the order and type of values, as follows:

a\ \ ASCII string, null padded (unstripped for
\textsf{unpack()}).\\
A \ \ ASCII string, space padded (trailing nulls and spaces are stripped
for \textsf{unpack()}).\\
b\ \ bit string, low-to-high order.\\
B\ \ bit string, high-to-low order.\\
h\ \ hexadecimal string, low-nibble-first.\\
H\ \ hexadecimal string, high-nibble-first.\\
c\ \ signed char value.\\
C\ \ unsigned char value.\\
s\ \ signed short value.\\
S\ \ unsigned short value.\\
i\ \ signed integer value.\\
I\ \ unsigned integer value.\\
l\ \ signed long value.\\
L\ \ unsigned long value.\\
n\ \ short in {\textquotedbl}network{\textquotedbl} order
(big-endian).\\
N\ \ long in {\textquotedbl}network{\textquotedbl} order
(big-endian).\\
v\ \ short in VAX order (little endian).\\
V\ \ long in VAX order (little endian).\\
f \ \ single-precision float in IEEE Motorola format.\\
d \ \ double precision floats in IEEE Motorola format.\\
e \ \ extended-precision float in IEEE Motorola format 80-bit.\\
E \ \ extended-precision float in IEEE Motorola format 96-bit.\\
x\ \ Skip forward a byte (null-fill for pack()).\\
X\ \ Back up a byte.\\
@\ \ Go to absolute position (null-fill if necessary for
pack()).\\
u\ \ A uuencoded/uudecoded string.

Each letter may optionally be followed by a number that gives a count.
Together the letter and the count make a field specifier. Letters and
numbers can be separated by white space that will be ignored. Types A,
a, B, b, H, and h consume one value from the
{\textquotedbl}value{\textquotedbl} list and produce a string of the
length given as the field-specifier-count. The other types consume
{\textquotedbl}field-specifier-count{\textquotedbl} values from the
{\textquotedbl}value{\textquotedbl} list and append the appropriate
data to the packed string.

\texttt{unpack(template, string) : value\_list} does the reverse of
\texttt{pack()}: it takes a string representing a structure and expands
it out into a list of values. The template has mostly the same format
as for \texttt{pack()}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bincvt}}

These procedures are for processing of \index{binary data}binary data
read from a file.

\textsf{unsigned(s:string) : integer} converts a binary byte string into
an unsigned integer.

\texttt{raw(s:string) : integer} puts raw bits of characters of string
\texttt{s} into an integer. If the size of \texttt{s} is less than the
size of an integer, the bytes are put into the low order part of the
integer, with the remaining high order bytes filled with zero. If the
string is too large, the most significant bytes will be lost -{}- no
overflow detection.

\texttt{rawstring(i:integer, size) : string} creates a string consisting
of the raw bits in the low order \texttt{size} bytes of integer
\texttt{i}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bitint}}

\texttt{int2bit(i) : string} produces a string with the bit
representation of \texttt{i}.

\textsf{bit2int(s) : integer} produces an integer corresponding to the
bit representation \texttt{i}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bitstr,bitstrm}}

These two modules operate on numeric values represented by strings of an
arbitrary number of bits, stored without regard to character
boundaries. In conjunction with arbitrary precision integers, this
facility can deal with bit strings of arbitrary size.

record \index{BitString}BitString(s, buffer, bufferBits) represents bit
strings internally.

See the header comments atop the source code for the public API and examples
for these modules.

% \texttt{BitStringPut(bitString, nbits, value:0)} is called with three
% arguments to put bits into a \texttt{BitString}, and called with a
% single argument to obtain the resulting string value. An example
% illustrates how \texttt{BitStringPut()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% bitString := BitString({\textquotedbl}{\textquotedbl}) \\
% while value := get\_new\_value() do \# loop to append to string \\
% \>   BitStringPut(bitString, value.nbits, value.value) \\
% resultString := BitStringPut(bitString) \# output any buffered bits
% }

% \texttt{BitStringPut(bitString)}, as well as producing the complete
% string, pads the buffered string to an even character boundary. This
% can be done during construction of a bit string if the effect is
% desired. The {\textquotedbl}value{\textquotedbl} argument defaults to
% zero.

% \textsf{BitStringGet(bitString, n:integer):integer} extracts n bits from
% a BitString and returns them as an integer. An example is the best way
% to show how \textsf{BitStringGet()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% bitString := BitString(string\_of\_bits) \\
% while value := BitStringGet(bitString, nbits) do \\
% \>   \# do something with value
% }

% \texttt{BitStringGet()} fails when too few bits remain to satisfy a
% request. However, if bits remain in the string, subsequent calls with
% fewer bits requested may succeed. A negative \textit{nbits} value gets
% the value of the entire remainder of the string, to the byte boundary
% at its end.

% Module \texttt{bitstrm} provides procedures for reading and writing
% integer values made up of an arbitrary number of bits, stored without
% regard to character boundaries. An example is the best way to show how
% \texttt{BitStreamWrite()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% BitStreamWrite() \#initialize \\
% while value := get\_new\_value() do \# loop to output values \\
% BitStreamWrite(outfile, value.nbits, value.value) \\
% BitStreamWrite(outfile) \# output any buffered bits
% }

% \texttt{BitStreamWrite(outproc)} outputs the complete string and pads
% the output to an even character boundary. This can be done during
% construction of a bit string if the effect is desired. The
% \textit{value} argument defaults to zero. \texttt{BitStreamRead()} is
% illustrated by the following example:

% \iconcode{
% BitStreamRead() \\
% while value := BitStreamRead(infile, nbits) do \\
% \>   \# do something with value
% }

% \texttt{BitStringRead()} fails when too few bits remain to satisfy a
% request. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bufread}}

These procedures provide lookahead within an open file. The procedures
\texttt{bufopen()}, \texttt{bufread()}, and \texttt{bufclose()} mirror
the built-in \texttt{open()}, \texttt{read()}, and \texttt{close()}.

\texttt{bufopen(s:\&input): file?} opens a file name \texttt{s} for
buffered read and lookahead.

\texttt{bufread(f:\&input): string} reads the next line from file
\texttt{f}. You cannot \texttt{bufread()} \texttt{\&input} unless you
have previously called \texttt{bufopen()} on it.

\texttt{bufnext(f:\&input, n:1): string} returns the next \texttt{n}th
line from file \texttt{f} without changing the next record to be read
by \texttt{bufread()}.

\texttt{bufclose(f:\&input): file} close file f.

In addition to processing the current line, one may process subsequent
lines \textbf{before} they are logically read: Example:

\iconcode{
file := bufopen({\textquotedbl}name{\textquotedbl},
{\textquotedbl}r{\textquotedbl}) {\textbar} stop({\textquotedbl}open
failed{\textquotedbl})}

\iconcode{
while line := bufread(file) do \{ \\
\>   ...process current line... \\
\>   line := bufnext(file,1) \# return next line \\
\>   ...process next line... \\
\>   line := bufnext(file,2) \# return 2nd next line \\
\>   ...process 2nd next line... ...etc...  \\
\>   \} \\
bufclose(file)
}

In the code above, calls to \texttt{bufnext()} do not affect subsequent
\texttt{bufread()}{\textquotesingle}s. (CAS)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{calls}}

These procedures deal with \index{procedure invocation}procedure
invocations that are encapsulated in records.

\textsf{record call(proc, args)} encapsulates a procedure to be called
and its argument list.\\
\textsf{invoke(call) : any*} invokes a procedure with an argument from a
call record.\\
\textsf{call\_image(call) : string} produces a string image of a
call.\\
\textsf{make\_call(string) : call} makes a call record from a string
that looks like an invocation.\\
\textsf{make\_args(string) : list} makes an argument list from a
comma-separated string.\\
\textsf{call\_code(string) : string} produces a string of Icon code to
construct a call record.\\
\textsf{write\_calltable(T:table, p:procedure, f:file):null} writes a
table of calls (all to procedure p) out to a file. The format is
\textsf{name=proc:arg1,arg2,?,argn,}\\
\textsf{read\_calltable(f:file) : table} reads a call table file into a
table.

Links: \texttt{ivalue}, \texttt{procname}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{capture}}

\texttt{capture(f:file)} replaces \texttt{write()}, \texttt{writes()},
and \texttt{stop()} with procedures that echo those elements that are
sent to \texttt{\&output} to the file \texttt{f}.

\texttt{uncaptured\_write(s:string...)},
\texttt{uncaptured\_writes(s:string...)} and \linebreak
\texttt{uncaptured\_stop(s:string...)} allow output to be directed to
\texttt{\&output} without echoing to the capture file. These are handy
for placing progress messages and other comforting information on the
screen. (DAG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{caseless}}

These procedures are analogous to the standard string-analysis functions
except that uppercase letters are considered equivalent to lowercase
letters. They observe the string scanning function conventions for
defaulting of the last three parameters. (NJL)

\texttt{anycl(c, s, i1, i2)} succeeds and produces \texttt{i1 + 1},
provided \texttt{map(s[i1])} is in \texttt{cset(map(c))} and
\texttt{i2} is greater than \texttt{i1}. It fails otherwise.

\textsf{balcl(c1, c2:{\textquotesingle}({\textquotesingle},
c3:{\textquotesingle}){\textquotesingle}, s, i1, i2)} generates the
sequence of integer positions in \texttt{s} preceding a character of
\textsf{cset(map(c1))} in \textsf{map(s[i1:i2])} that is balanced with
respect to characters in \textsf{cset(map(c2))} and
\textsf{cset(map(c3))}, but fails if there is no such position.

\textsf{findcl(s1, s2, i1, i2)} generates the sequence of integer
positions in \textsf{s2} at which \textsf{map(s1)} occurs as a
substring in \textsf{map(s2[i1:i2])}, but fails if there is no such
position.

\textsf{manycl(c,s,i1,i2)} produces the position in \textsf{s} after the
longest initial sequence of characters in \textsf{cset(map(c))} within
\textsf{map(s[i1:i2])}. It fails if \textsf{map(s[i1])} is not in
\textsf{cset(map(c))}.

\textsf{matchcl(s1, s2, i1, i2) : integer?} produces i1 + *s1 if map(s1)
== map(s2[i1+:=*s1]).

\textsf{uptocl(c, s, i1, i2)} generates the sequence of integer
positions in \texttt{s} preceding a character of \textsf{cset(map(c))}
in \textsf{map(s[i1:i2])}. It fails if there is no such position.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cgi}}

The cgi library provides support for development of Common Gateway
Interface server side web based applications, commonly called
\index{CGI}CGI scripts. (JvM, CLJ)

\textsf{global cgi : table} is a library global variable. Its keys are
the names of input fields in the invoking HTML page{\textquotesingle}s
form, and values are whatever the user typed in those input fields. 

\textsf{cgiInput(type, name, values)} writes \index{HTML}HTML INPUT tags
of a particular type with a certain name for each element of a list of
values. The first value{\textquotesingle}s input tag is CHECKED. 

\textsf{cgiSelect(name, values)} writes an HTML SELECT tag with a
certain name and embedded OPTION tags for each element of a list of
values. The first value{\textquotesingle}s OPTION tag is SELECTED. 

\textsf{cgiXYCoord(hlst) : string} is used with an ISMAP to check the x
and y coordinates. If they are between certain boundaries, it returns
the value of the list element that was entered. 

\textsf{cgiMyURL() : string} returns the URL for the current script, as
obtained from the SERVER\_NAME and SCRIPT\_NAME environment variables. 

\textsf{cgiPrintVariables(T)} prints the keys and values in a table
using simple HTML formatting. 

\textsf{cgiError(L)} generates an error message consisting of the
strings in list \texttt{L}, with \texttt{L[1]} as the title and
subsequent list elements as paragraphs.

\textsf{cgiHexVal(c)} produces a value from 0 to 15 corresponding to a
hex char from 0 to F. 

\textsf{cgiHexChar(c1,c2)} produces an 8-bit char value corresponding to
two hex digits encoded as chars. 

\textsf{cgiColorToHex(s) : string} produces a 24-bit hex color value
corresponding to a string color name. At present, only the colors
black, gray, white, pink, violet, brown, red, orange, yellow, green,
cyan, blue, purple, and magenta are supported. 

\textsf{cgiPrePro(filename, def)} selectively copies out parts of a
named (HTML) file, writing out either anything between ALL and the
value that are passed into the procedure. 

\texttt{cgiRndImg(L, s)} writes an HTML IMG tag for a random element of
L, which should be a list of image filenames. The tag has ALT text
given in string s. 

\texttt{cgiOptwindow(opts, args...) : window?} attempts to open an Icon
window, either on the X server or else on display :0 of the
client{\textquotesingle}s machine (as defined by the IP address in
REMOTE\_ADDR). The Icon window is typically used to generate a .GIF
image to which a \index{link!HTML}link is embedded in the CGI
program{\textquotesingle}s output. 

\texttt{main(args)} is included in the CGI library; you do not write
your own. The CGI \texttt{main()} procedure generates an HTML header,
parses the CGI input fields into a global table cgi, generates a
background by calling the user{\textquotesingle}s
\texttt{cgiBBuilder()} function, if any, and calls the
user{\textquotesingle}s \texttt{cgimain()} function. 

\texttt{cgiBBuilder(args...) : table} is an optional procedure that a
CGI program can include to define the general appearance of its
generated web page output. If the user application defines this
function, it should return a table which contains keys
{\textquotedbl}background{\textquotedbl},
{\textquotedbl}bgcolor{\textquotedbl},
{\textquotedbl}text{\textquotedbl}, {\textquotedbl}link{\textquotedbl},
{\textquotedbl}vlink{\textquotedbl},
{\textquotedbl}bgproperties{\textquotedbl} with appropriate values to
go into the BODY tag and define background color and texture for the
CGI page. 

\texttt{cgimain(args)} is the entry point for CGI programs. \ When you
use the CGI library, its \texttt{main()} initializes things and then
calls your \texttt{cgimain()} to generate the HTML content body for the
client{\textquotesingle}s web page. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{codeobj}}

This module provides a way of storing Icon values as strings and
retrieving them.

\texttt{encode(x:any) : string} converts x to a string s.\\
\texttt{decode(s:string): any} converts a string in \texttt{encode()}
format back to x.

These procedures handle all kinds of values, including structures of
arbitrary complexity and even loops. For scalar types -{}- null,
integer, real, cset, and string -{}- \texttt{decode(encode(x)) === x}.
For structure types -{}- list, set, table, and record types -{}-
\texttt{decode(encode(x))} is not identical to \texttt{x}, but it has
the same {\textquotedbl}shape{\textquotedbl} and its elements bear the
same relation to the original as if they were encoded and decode
individually. Not much can be done with files, functions and
procedures, and co-expressions except to preserve type and
identification. The encoding of strings and csets handles all
characters in a way that is safe to write to a file and read it back.

Links: \textsf{escape}, \textsf{gener}, \textsf{procname},
\textsf{typecode}. Requires: co-expressions. See also:
\texttt{object.icn}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{colmize}}

\texttt{colmize(L:list,mx:80,sp:2,mi:0,tag,tagsp:2,tagmi:0,roww,dist) :
string*} arranges a number of data items (from list of strings
\texttt{L}) into multiple columns. \texttt{mx} is the maximum width of
output lines. \texttt{sp} is the minimum number of spaces between
columns. \texttt{mi} is the minimum column width. \texttt{tag} is a
label to be placed on the first line of output. Items are arranged in
column-wise order unless roww is nonnull; by default the sequence runs
down the first column, then down the second, etc. \texttt{colmize()}
goes to great lengths to print the items in as few vertical lines as
possible. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{complete}}

\index{complete()}\texttt{complete(s:string,st) : string*} lets you
supply a partial string, \texttt{s}, and get back those strings in
\texttt{st} that begin with \texttt{s}. \ \texttt{st} must be a list or
set of strings. (RLG)

Example:

\iconcode{
commands :=
[{\textquotedbl}run{\textquotedbl},{\textquotedbl}stop{\textquotedbl},{\textquotedbl}quit{\textquotedbl},{\textquotedbl}save{\textquotedbl},{\textquotedbl}load{\textquotedbl},{\textquotedbl}continue{\textquotedbl}] \\
while line := read(\&input) do \{ \\
\>   cmds := [ ] \\
\>   every put(cmds, complete(line, commands)) \\
\>   case *cmds of \{ \\
\>   \ \ \ 0 : input\_error(line) \\
\>   \ \ \ 1 : do\_command(cmds[1]) \\
\>   \ \ \ default : display\_possible\_completions(cmds) \\
\>   \ \ \ \} \\
\>   \}
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{complex}}

The following procedures perform operations on \index{complex
numbers}complex numbers. 

\noindent \textsf{record complex(r,i)} creates a complex number with real part r
and imaginary part i\\
\texttt{cpxadd(x1,x2) : complex} add complex numbers \texttt{x1} and
\texttt{x2}\\
\texttt{cpxdiv(x1,x2) : complex} divide complex number \texttt{x1} by
complex number \texttt{x2}\\
\texttt{cpxmul(x1,x2) : complex} multiply complex number \texttt{x1} by
complex number \texttt{x2}\\
\texttt{cpxsub(x1,x2) : complex} subtract complex numbers \texttt{x2}
from \ \texttt{x1}\\
\texttt{cpxstr(x) : complex} convert complex number \texttt{x} to string
representation\\
\texttt{strcpx(s) : complex} convert string to complex number 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{conffile}}

This module parses configuration files into Icon
structures for easy access. The service is similar to 
command-line option handling, except that configuration files can
contain structured data such as lists or tables. A configuration file
supplies values for a set of named \textit{directives}. The directives
and their values are read in to a table, usually during program
initialization. The types of all allowed directives are specified as
follows, before the configuration file is accessed.

\texttt{Directive(classproc,editproc,minargs,maxargs):DirectivesRec}
produces records (whose field names match the parameter names) that
populate a table used to control configuration file processing.
\texttt{classproc} is a procedure that indicates what kind of value is
associated with a given directive in the configuration file:.
\texttt{editproc} is an optional type conversion procedure to apply to
values. \texttt{minargs} and \texttt{maxargs} are the minimum and
maximum number of arguments to a directive; their defaults depend on
the \texttt{classproc}.

classproc\ \ \ \ \ \ min, max (defaults)\\
Directive\_value\ \ \ \ 1, 1\\
Directive\_list\ \ \ \ \ \ 1, inf\ \ \ \ \\
Directive\_table\ \ \ \ 2, inf\\
Directive\_set\ \ \ \ \ \ 1, inf\\
Directive\_table\_of\_sets\ \ 2, inf\\
Directive\_ignore\ \ \ \ 0, inf\\
Directive\_warning\ \ \ \ 0, inf

The following code creates a table of specifications for a
case-insensitive label and a list of exactly three color components.
The default value for tables passed into \textsf{ReadDirectives()}
should be a \textsf{Directive} for \textsf{Directive\_ignore} or
\textsf{Directive\_warning}.

\iconcode{
tos := table(Directive(Directive\_ignore)) \\
tos[{\textquotedbl}mylabel{\textquotedbl}] :=
Directive(Directive\_value, map) \\
tos[{\textquotedbl}fgrgb{\textquotedbl}] := Directive(Directive\_list,
3, 3)
}

\textsf{ReadDirectives(L:list,T:table,s1:{\textquotedbl}\#{\textquotedbl},s2:{\textquotedbl}-{\textquotedbl},c1:{\textquotesingle}{\textbackslash}{\textbackslash}{\textquotesingle},
c2:{\textquotesingle}
{\textbackslash}b{\textbackslash}t{\textbackslash}v{\textbackslash}f{\textbackslash}r{\textquotesingle},p)
: table} returns a table containing directives parsed and extracted
from a file. \texttt{L} is a list of string filenames or open files;
the procedure uses the first one that it is able to read. \texttt{T} is
a table of specifications for parsing and handling directives.
\texttt{s1} is the comment character. \texttt{s2} is the continuation
character. \texttt{c1} are escape characters. \texttt{c2} are white
space. The following code reads directives using the previously-defined
specification table, and creates a window whose title is taken from the
specified \texttt{mylabel} directive if it is present.

\iconcode{
cfg := ReadDirectives([{\textquotedbl}.mycfg{\textquotedbl},
{\textquotedbl}my.cfg{\textquotedbl}, \&input], tos) \\
WOpen({\textquotedbl}label={\textquotedbl} {\textbar}{\textbar} (
{\textbackslash} (cfg[{\textquotedbl}mylabel{\textquotedbl}])
{\textbar} {\textquotedbl}untitled{\textquotedbl}))
}

Links: lastc. (DAG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{convert}}

This module contains numeric conversions between
\index{convert!base}bases. There are several other procedures related
to conversion that are not yet part of this module. 

\texttt{exbase10(i, j) : string} converts base-10 integer i to base
j.\\
\texttt{inbase10(s, i) : integer} converts base-i integer s to base
10.\\
\texttt{radcon(s, i, j) : integer} converts base-i integer s to base j.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{created}}

\textsf{created(string) : integer} returns the number of structures of a
given type that have been created. It artificially increments the
count, and allocates garbage. Links: \textsf{serial}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{currency}}

\textsf{currency(amt, wid:0, neg:{\textquotedbl}-{\textquotedbl},
frac:2, whole:1, sign:{\textquotedbl}\${\textquotedbl},
decimal:{\textquotedbl}.{\textquotedbl},
comma:{\textquotedbl},{\textquotedbl}) : string} formats \texttt{amt}
in a currency format that defaults to U.S. currency. \texttt{amt} can
be a real, integer, or numeric string. \texttt{wid} is the output field
width, in which the amount is right adjusted. The returned string will
be longer than \texttt{width} if necessary to preserve significance.
\texttt{neg} is the character string to be used for negative amounts,
and is placed to the right of the amount. \texttt{frac} and
\texttt{whole} are the exact number of digits to use right of the
decimal, and the minimum number of digits to appear left of the
decimal, respectively. The currency \texttt{sign} prefixes the returned
string. The characters used for decimal point and comma may also be
supplied. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datecomp}}

These procedures do simple \index{date comparison}date comparisons. The
parameters are strings of the form mm/dd/yyyy or
\texttt{\&date}{}-compatible yyyy/mm/dd. (CSM)

dgt(date1:string, date2:string) : ?\ \ succeeds if date1 is later than
date2.\\
dlt(date1:string, date2:string) : ?\ \ succeeds if date1 is earlier than
date2.\\
deq(date1:string, date2:string) : ?\ \ succeeds if date1 is equal to
date2.\\
futuredate(date:string) : ?\ \ \ \ succeeds if date is in the
future.\\
pastdate(date:string) : ?\ \ \ \ succeeds if date is in the
past.\\
getmonth(date:string) : string\ \ \ \ returns the month portion of a
date.\\
getday(date:string) : string\ \ \ \ returns the day portion of a
date.\\
getyear(date:string) : string\ \ \ \ returns the year portion of a date.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datefns}}

These date and calendar procedures represent dates using the record type
defined below. They are adaptations of C functions from
{\textquotedbl}The C Programming Language{\textquotedbl} (Kernighan and
Ritchie, Prentice-Hall) and {\textquotedbl}Numerical Recipes in
C{\textquotedbl} (Press et al, Cambridge). (CH)

\textsf{record date\_rec(year, month, day, yearday, monthname,
dayname)}\\
\textsf{initdate()} initializes the global data before using the other
functions.\\
\textsf{today() : date\_rec} produces a computationally useful value for
today{\textquotesingle}s date\\
\index{julian}\textsf{julian}\textsf{(date) : integer} converts a
date\_rec to a Julian day number\\
\textsf{unjulian(julianday) : date\_rec} produces a date from the Julian
day number\\
\textsf{doy(year, month, day) : integer} returns the day-of-year from
(year, month, day)\\
\textsf{wrdate(leadin, date)} writes a line to \textsf{\&output} with a
basic date string preceded by a leadin 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datetime}}

These procedures provide miscellaneous date and time operations. See
also: \textsf{datefns.icn}. (RJA, REG)

\textsf{global DateBaseYear : 1970} is a time origin for several
functions. If an \index{environment variable!DateBaseYear}environment
variable by the same name is present, its value is used instead of the
default value.

\textsf{ClockToSec(string) : integer} converts a time in the format of
\texttt{\&clock} into a number of seconds past midnight.

\textsf{DateLineToSec(dateline,hoursFromGmt) : integer} converts a date
in \&dateline format to seconds since start of DateBaseYear.

\textsf{DateToSec(string) : integer} converts a date string in Icon
\texttt{\&date} format (yyyy/mm/dd) to seconds past
\texttt{DateBaseYear}.

\texttt{SecToClock(integer) : string} converts a number of seconds past
midnight to a string in the format of \texttt{\&clock}.

\texttt{SecToDate(integer) : string} converts a number of seconds past
\texttt{DateBaseYear} to a string in Icon \texttt{\&date} format
(yyyy/mm/dd).

\textsf{SecToDateLine(sec,hoursFromGmt) : string} produces a date in the
format of \textsf{\&dateline}.

\texttt{SecToUnixDate(sec,hoursFromGmt) : string} returns a date and
time in typical UNIX format: Jan 14 10:24 1991.

\texttt{calendat(j) : date1} returns a record with the month, day, and
year corresponding to the Julian Date Number \texttt{j}.

\texttt{date() : string} produces the natural date in English.

\textsf{dayoweek(day, month, year) : string} produces the day of the
week for the given date.

\texttt{full13th(year1, year2)} generates records giving the days on
which a full moon occurs on Friday the 13th in the range from
\texttt{year1} through \texttt{year2}.

\textsf{julian(m,d,y)} returns the Julian Day Number for the specified
month, day, and year.

\texttt{pom(n, phase)} returns record with the Julian Day number of
fractional part of the day for which the nth such phase since January,
1900. Phases are encoded as:\\
\ \ 0 = new moon \ \ \ \ 1 = first quarter \ \ \ \ 2 = full moon
\ \ \ \ 3 = last quarter\\
GMT is assumed.

\texttt{saytime()} computes the time in natural English. If an argument
is supplied it is used as a test value to check the operation the
program.

\texttt{walltime() : integer} produces the number of seconds since
midnight. Beware wrap-around when used in programs that span midnight.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{db}}

These procedures provide an interface to the ODBC database facilities
that does not require knowledge of SQL. It also provides compatibility
procedures for an earlier version of the ODBC interface.

dbdelete(db, filter...):integer deletes rows from db that satisfy
filters. Warning: if the filter criteria are omitted, the
\index{database}database will be emptied by this operation!

dbinsert(db, row:record) inserts a record as a tuple (row) into db.

dbselect(db,columns,condition,ordering):integer selects columns from db.
columns defaults to {\textquotedbl}all{\textquotedbl}, condition
defaults to unconditionally, and ordering defaults to unordered.

\textsf{dbupdate(db:database,row:record)} updates the database tuple
corresponding to row.

dbopen(dsn, table, user, password):f is like
open(dsn,{\textquotedbl}o{\textquotedbl},...)\\
dbclose(db) is an alias for close()\\
dbfetch(db) is an alias for fetch()\\
dbsql(db, query) is an alias for sql()

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{dif}}

\texttt{dif(strm:list,compare:{\textquotedbl}==={\textquotedbl},eof,group:groupfactor):list*}
generates \index{diff}differences between input streams. Results are
returned as a list of records, one for each input stream, with each
record containing a list of items that differ and their positions in
the input stream. The record type is declared as: \texttt{record
diff\_rec(pos,diffs)}. \texttt{dif()} fails if there are no
differences.

\texttt{strm} is a list of input streams from which \texttt{dif()} will
extract its input {\textquotedbl}records{\textquotedbl}. The elements
can be any of the following types, with corresponding actions:

Type\ \ \ \  \ Action

file\ \ \ \  \ file is {\textquotedbl}read{\textquotedbl} to get
records\\
co-expression \ co-expression is activated to get records\\
list\ \ \ \  \ records are {\textquotedbl}gotten{\textquotedbl}
(\texttt{get()}) from the list\\
diff\_proc\ \  \ a record type defined in \texttt{dif} to allow
procedures supplied by \texttt{dif}{\textquotesingle}s\\
 \ \ \ \  \ caller to be called to get records. Diff\_proc has two
fields, the procedure\\
 \ \ \ \  \ to call and the argument to pass to it. Its definition looks
like this:\\
 \ \ \ \  \ \texttt{record diff\_proc(proc,arg)}

\texttt{compare} is a procedure that succeeds if two records are
{\textquotedbl}equal{\textquotedbl}, and fails otherwise. The
comparison must allow for the fact that the EOF object might be an
argument, and a pair of EOFs must compare equal.

\texttt{eof} is an object that is distinguishable from other objects in
the stream.

\texttt{group} is a procedure that is called with the current number of
unmatched items as its argument. It must return the number of matching
items required for file synchronization to occur. The default
(procedure \texttt{groupfactor()}) is the formula Trunc((2.0 * Log(M))
+ 2.0) where M is the number of unmatched items. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{digitcnt}}

\texttt{digitcnt(file:\&input) : list} counts the number of each digit
in a file and returns a ten-element list with the counts. 

% \vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ebcdic}}

% These procedures assist in use of the \index{ASCII}ASCII and
% \index{EBCDIC}EBCDIC character sets, regardless of the native character
% set of the host. For example, \texttt{Ascii128()} returns a 128-byte
% string of ASCII characters in numerical order, replacing
% \texttt{\&ascii} for applications which might run on an EBCDIC host.
% (AB)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{equiv}}

\texttt{equiv(x,y) : any?} tests the equivalence of two values. For
non-structures, it returns \texttt{x1 === x2}. For structures, the test
is for \index{shape equivalence}\textit{shape}. For example,
\texttt{equiv([],[])} succeeds. It handles loops, but does not
recognize them as such. The concept of equivalence for tables and sets
is not quite right if their elements are themselves structures. There
is no concept of order for tables and sets, yet it is impractical to
test for equivalence of their elements without imposing an order. Since
structures sort by {\textquotedbl}age{\textquotedbl}, there may be a
mismatch between equivalent structures in two tables or sets. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{escapesq}}

These procedures manipulate \index{escape sequence}escape sequences in
Icon (or C) character string representations. (RJA)

\textsf{escapeseq() : string} is a matching procedure for Icon string
escape sequences\\
\textsf{escchar(string) : string} produces the character value of an
Icon string escape sequence\\
\textsf{escape()} converts a string with escape sequences (as in Icon
string representation) to the string it represents. For example,
\textsf{escape({\textquotedbl}{\textbackslash}{\textbackslash}143{\textbackslash}{\textbackslash}141{\textbackslash}{\textbackslash}164{\textquotedbl})}
produces the string \textsf{{\textquotedbl}cat{\textquotedbl}}.\\
\textsf{quotedstring()} matches a complete quoted string.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{eval}}

\index{eval()}\texttt{eval(string) : any*} analyzes a string
representing an Icon function or procedure call and evaluates the
result. Operators can be used in functional form, as in
\texttt{{\textquotedbl}*(2,3){\textquotedbl}}. This procedure cannot
handle nested expressions or control structures. It assumes the string
is well formed. The arguments can only be Icon literals. Escapes,
commas, and parentheses in string literals are not handled. In the case
of operators that are both unary and binary, the binary form is used.
Links: \texttt{ivalue}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{evallist}}

\textsf{evallist(expr, n, ucode, ...) : list} takes an expression,
produces a program encapsulating it, and puts the results written by
the program in a list. \textsf{expr} is an expression (normally a
generator); \texttt{n} is the maximum size of the list, and the
trailing arguments are ucode files to link with the expression.
Requires: \texttt{system()}, \texttt{/tmp}, pipes. Links:
\texttt{exprfile}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{everycat}}

\textsf{everycat(x1, x2, ...) : string*} generates the concatenation of
every string from !x1, !x2, ... For example, if first :=
[{\textquotedbl}Mary{\textquotedbl}, {\textquotedbl}Joe{\textquotedbl},
{\textquotedbl}Sandra{\textquotedbl}] and last :=
[{\textquotedbl}Smith{\textquotedbl},
{\textquotedbl}Roberts{\textquotedbl}] then \ \ every
write(everycat(first, {\textquotedbl} {\textquotedbl}, last)) writes
Mary Smith, Mary Roberts, Joe Smith, Joe Roberts, Sandra Smith, Sandra
Roberts. x1, x2, ... can be any values for which !x1, !x2, ... produce
values convertible to strings. In the example above, the second
argument is a one-character string \texttt{{\textquotedbl}
{\textquotedbl}}, so that \texttt{!{\textquotedbl} {\textquotedbl}}
generates a single blank. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{exprfile}}

\texttt{exprfile(exp, link, ...) : file} produces a pipe to a program
that writes all the results generated by \texttt{exp}. The trailing
arguments name link files needed for the expression.
\texttt{exprfile()} closes any previous pipe it opened and deletes its
temporary file. Therefore, \texttt{exprfile()} cannot be used for
multiple expression pipes. If the expression fails to compile, the
global \texttt{expr\_error} is set to 1; otherwise 0. 

\texttt{exec\_expr(expr\_list, links[]) : string*} generates the results
of executing the expression contained in the lists \texttt{expr\_list}
with the specified links.

Requires: \texttt{system()}, pipes, \texttt{/tmp}. Links: \texttt{io}.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{factors}}

This file contains procedures related to factorization and prime
numbers.

\index{factorial(n)}\texttt{factorial(n)} returns n!. It fails if n is
less than 0.\\
\texttt{factors(i, j)} returns a list containing the factors of i, up to
maximum j; by default\\
 \ \ \ \ \ there is no limit.\\
\texttt{gfactorial(n, i)} generalized factorial; n x (n - i) x (n - 2i)
x ...\\
\texttt{ispower(i, j)} succeeds and returns root if i is k\^{}j\\
\texttt{is}\index{prime number}\texttt{prime(n)} succeeds if n is a
prime.\\
\texttt{nxtprime(n)} returns the next prime number beyond n.\\
\texttt{pfactors(i)} returns a list containing the primes that divide
i.\\
\texttt{prdecomp(i)} returns a list of exponents for the prime
decomposition of i.\\
\texttt{prime()} generates the primes.\\
\texttt{primel()} generates the primes from a precompiled list.\\
\texttt{primorial(i,j)} product of primes j {\textless}= i; j defaults
to 1.\\
\texttt{sfactors(i, j)} is the same as \texttt{factors(i, j)}, except
output is in string form\\
 \ \ \ \ \ with exponents for repeated factors

Requires: Large-integer arithmetic and prime.lst for
\texttt{primel()}.\\
Links: \texttt{io}, \texttt{numbers}. (REG, GMT)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fastfncs}}

These procedures implement integer-values using a best known method.

\texttt{acker(i, j)}\ \ Ackermann{\textquotesingle}s function\\
\texttt{fib(i)}\ \ \ \ Fibonacci sequence\\
\texttt{g(k, i)}\ \ \ \ Generalized Hofstader nested recurrence\\
\texttt{q(i)}\ \ \ \ \ \ {\textquotedbl}Chaotic{\textquotedbl}
sequence\\
\texttt{robbins(i)}\ \ Robbins numbers

See also: iterfncs.icn, memrfncs.icn, recrfncs.icn. Links: factors,
memrfncs. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filedim}}

\texttt{filedim(s, p) : textdim} computes the number of rows and maximum
column width of the file named \texttt{s}. The procedure \texttt{p},
which defaults to \texttt{detab}, is applied to each line. For example,
to have lines left as is, use \texttt{filedim(s, 1)}. The return value
is a record that uses the declaration \texttt{record textdim(cols,
rows)}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filenseq}}

\texttt{nextseqfilename(dir, pre, ext) : string?} is useful when you
need to create the next file in a series of files (such as successive
log files). Usage: \texttt{fn :=
nextseqfilename({\textquotedbl}.{\textquotedbl},
{\textquotedbl}.{\textquotedbl}, {\textquotedbl}log{\textquotedbl})}
returns the (non-existent) filename next in the sequence
\texttt{.{\textbackslash}.*.log} (where the * represents 1, 2, 3, ...)
or fails Requires: MS-DOS or a more congenial operating system. \ (DAG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findre}}

\textsf{findre(s1,s2,i,j) : integer*} is like the built-in function
\textsf{find()}, except its first argument is a \index{regular
expression}regular expression similar to the ones the Unix
e\index{grep}grep command uses. A no argument invocation wipes out all
static structures utilized by \index{findre()}\textsf{findre()}, and
then forces a \index{garbage collection}garbage collection.
\textsf{findre()} offers a simple and compact wildcard-based search
system. If you do many searches through text files, or write programs
which do searches based on user input, then \textsf{findre()} is a
utility you might want to look over. \textsf{findre()} leaves the user
with no easy way to tab past a matched substring, as with \textsf{s ?
write(tab(find({\textquotedbl}hello{\textquotedbl})+5))}. In order to
remedy this intrinsic deficiency, \textsf{findre()} sets the global
variable \textsf{\_\_endpoint} to the first position after any given
match occurs. \textsf{findre()} utilizes the same basic language as
egrep, but uses intrinsic Icon data structures and escaping conventions
rather than those of any particular Unix variant. \textsf{findre()}
takes a shortest-possible-match approach to regular expressions. In
other words, if you look for \textsf{{\textquotedbl}a*{\textquotedbl}},
\textsf{findre()} will not even bother looking for an
\textsf{{\textquotedbl}a{\textquotedbl}}\texttt{.} It will just match
the empty string. (RLG)

\texttt{\^{}} - matches if the following pattern is at the beginning of
a line (i.e. \texttt{\^{}\#} matches lines \ \\
 \ \ \ \ beginning with
\texttt{{\textquotedbl}\#{\textquotedbl}})\\
\texttt{\$} - matches if the preceding pattern is at the end of a
line\\
\texttt{.} - matches any single character\\
\texttt{+} - matches from 1 to any number of occurrences of the previous
expression (i.e. A\\
 \ \ \ \ \ character, or set of parenthesized/bracketed
characters)\\
\texttt{*} - matches from 0 to any number of occurrences of the previous
expression\\
{\textbackslash} \ {}- removes the special meaning of any special
characters recognized by this program\\
 \ \ \ \ (i.e. if you want to match lines beginning with a
\texttt{{\textquotedbl}[{\textquotedbl}}, write
\texttt{\^{}{\textbackslash}[}, and not \texttt{\^{}[})\\
\texttt{{\textbar}} - matches either the pattern before it, or the one
after it (i.e. \texttt{abc{\textbar}cde} matches either\\
 \ \ \ \ \ \texttt{abc} or \texttt{cde})\\
\texttt{[]} - matches any member of the enclosed character set, or, if
\texttt{\^{}} is the first character, any\\
 \ \ \ \ \ \ \ nonmember of the enclosed character set (i.e.
\texttt{[\^{}ab]} matches any character \textit{except\\
 \ \ \ \ \ \ }\ \texttt{a} and \texttt{b}).\\
\texttt{()} - used for grouping (e.g. \^{}(abc{\textbar}cde). matches
lines consisting of either \textsf{{\textquotedbl}abc{\textquotedbl}}
or \textsf{{\textquotedbl}cde{\textquotedbl},}\\
 \ \ \ \ \ \ while \textsf{\^{}abc{\textbar}cde}. matches lines either
beginning with \textsf{{\textquotedbl}abc{\textquotedbl}} or ending in
\textsf{{\textquotedbl}cde{\textquotedbl}})

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gauss}}

\textsf{gauss\_random(x, f)} produces a \index{Gaussian
distribution}Gaussian distribution about the value \texttt{x}.
Parameter \texttt{f} can be used to alter the shape of the Gaussian
distribution (larger values flatten the curve...) Produce a random
value within a Gaussian distribution about 0.0. (Sum 12 random numbers
between 0 and 1, (expected mean is 6.0) and subtract 6 to center on 0.0
\ (SBW)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gdl, gdl2}}

\texttt{gdl(dir:string) : list} returns a list containing everything in
a directory. You\\
 \ \ \ \ can use this file as a template, modifying the procedures
according to the needs of the\\
 \ \ \ \ program in which they are used.\\
\texttt{gdlrec(dir, findflag) : list} does same thing as gdl except it
recursively\\
 \ \ \ \ descends through subdirectories. If \texttt{findflag} is
nonnull, the UNIX {\textquotedbl}find{\textquotedbl} program\\
 \ \ \ \ is used; otherwise the {\textquotedbl}ls{\textquotedbl} program
is used. Requires: UNIX or MS-DOS. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gener}}

These procedures generate sequences of results. 

\texttt{days() : string*} produces the \index{days of the week}days of
the week, starting with
\texttt{{\textquotedbl}Sunday{\textquotedbl}}.\\
\texttt{hex() : string*} is the sequence of
\index{hexadecimal}hexadecimal codes for numbers from 0 to 255\\
\texttt{label(s,i) : string*} produces labels with prefix \texttt{s}
starting at \texttt{i}\\
\texttt{multii(i, j) : integer*} produces \texttt{i * j}
\texttt{i}{\textquotesingle}s\\
\texttt{months() : string*} produces the \index{months of the
year}months of the year\\
\texttt{octal() : string*} produces the \index{octal}octal codes for
numbers from 0 to 255\\
\texttt{star(s) : string*} produces the \index{closure,
star(s)}\index{string!closure}closure of \texttt{s} starting with the
empty string and\\
 \ \ \ \ continuing in lexical order as given in \texttt{s} 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{genrfncs}}

These procedures generate various mathematical
\index{sequences}sequences of results. Too many are included to list
them all here; consult the source code for a complete listing.

\texttt{arithseq(i, j) : string*} arithmetic sequence starting at i with
increment j.\\
\texttt{chaosseq()} chaotic sequence\\
\texttt{factseq()} factorial sequence\\
\texttt{fibseq(i, j, k)} generalized Fibonacci (Lucas) sequence with
additive constant k\\
\texttt{figurseq(i)} series of i{\textquotesingle}th figurate
number\\
\texttt{fileseq(s, i)} generate lines (if i is null) or characters
(except line terminators)\\
 \ \ \ \ from file s.\\
\texttt{geomseq(i, j)} geometric sequence starting at i with multiplier
j\\
\texttt{irepl(i, j)} j instances of i\\
\texttt{multiseq(i, j, k)} sequence of (i * j + k)
i{\textquotesingle}s\\
\texttt{ngonalseq(i)} sequence of the i polygonal number\\
\texttt{primeseq()} the sequence of prime numbers\\
\texttt{powerseq(i, j)} sequence i \^{} j, starting at j = 0\\
\texttt{spectseq(r)} spectral sequence integer(i * r), i - 1, 2, 3,
...\\
\texttt{starseq(s)} sequence consisting of the closure of s starting
with the empty string and\\
 \ \ \ \ continuing in lexical order as given in s

Requires: co-expressions. Links: \texttt{io}, \texttt{fastfncs},
\texttt{partit}, \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{getmail}}

\textsf{getmail(x):message\_rec*} reads an Internet \index{mail folder,
read}mail folder and generates a sequence of records, one per message,
failing when end-of-file is reached. Each record contains the message
header and message text components parsed into fields. The argument x
is either the name or the file handle. If getmail() is resumed after
the last message is generated, it closes the mail folder and returns
failure. If \texttt{getmail()} generates an incomplete sequence (does
not close the folder and return failure) and is then restarted (not
resumed) on the same or a different mail folder, the previous folder
file handle remains open and inaccessible. If message\_records are
stored in a list, the records may be sorted by individual components
(like sender, \_date, \_subject) using the \texttt{sortf()} function.
(CS)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{getpaths}}

\texttt{getpaths(args[]) : string*} generates the paths supplied as
arguments followed by those paths in the PATH \index{environment
variable!PATH}environment variable, if one is available. A typical
invocation might look like:

\ \texttt{open(getpaths({\textquotedbl}/usr/local/lib/icon/procs{\textquotedbl})
{\textbar}{\textbar} filename)}

\texttt{getpaths()} will be resumed in the above context until open
succeeds in finding an existing, readable file.

Requires: UNIX or MS-DOS. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{graphpak}}

The procedures here use sets to represent directed \index{graph}graphs.
See {\textquotedbl}The Icon Programming Language{\textquotedbl}, third
edition, pp. 233-236. A graph has two components: a list of nodes and a
two-way lookup table. The nodes in turn are sets of
\index{pointer}pointers to other nodes. The two-way table maps a node
to its name and vice-versa. Graph specifications are given in files in
which the first line is a white-space separated list of node names and
subsequent lines give the arcs, as in

Tucson Phoenix Bisbee Douglas Flagstaff\\
Tucson-{\textgreater}Phoenix\\
Tucson-{\textgreater}Bisbee\\
Bisbee-{\textgreater}Bisbee\\
Bisbee-{\textgreater}Douglas\\
Douglas-{\textgreater}Phoenix\\
Douglas-{\textgreater}Tucson

record graph(nodes:list, lookup:table) represents a graph\\
read\_graph(f:file) : graph reads a graph from a file\\
write\_graph(g:graph, f:file) : null writes a graph to a file\\
closure(node) : set computes the transitive closure of a node.
\ \ \ \ \ \ 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hexcvt}}

\texttt{hex(s) : integer} converts a string of hex digits into an
integer.\\
\texttt{hexstring(i,n,lc) : string} produces the
\index{hexadecimal}hexadecimal representation of the argument. If n is
supplied, a minimum of n digits appears in the result; otherwise there
is no minimum, and negative values are indicated by a minus sign. If lc
is non-null, lowercase characters are used instead of uppercase. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{html}}

These procedures assist in processing HTML files:

\textsf{htchunks(file) : string*} generates \index{HTML}HTML chunks in a
file. Results beginning with {\textless}!-{}- are unclosed comments
(legal comments are deleted); {\textless} begins tags; others are
untagged text.\\
\texttt{htrefs(f) : string*} generates the tagname/keyword/value
combinations that \index{reference!HTML}reference other files. Tags and
keywords are returned in upper case.\\
\textsf{httag(string) : string} produces the name of a tag contained
within a tag string.\\
\texttt{htvals(s) : string*} generates the keyword/value pairs from a
tag.\\
\textsf{urlmerge(base,new) : string} interprets a new URL in the context
of a base URL. (GMT)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ichartp}}

\texttt{ichartp} implements a simple \index{chart parser}chart
\index{parse}parser - a slow but easy-to-implement strategy for parsing
context free grammars (it has a cubic worst-case time factor). Chart
parsers are flexible enough to handle a variety of natural language
constructs, and lack many of the troubles associated with empty and
left-recursive derivations. To obtain a parse, create a \index{BNF}BNF
file, obtain a line of input, and then invoke parse\_sentence(sentence,
bnf\_filename, start-symbol). Parse\_sentence() suspends successive
edge structures corresponding to possible parses of the input sentence.
BNF grammars are specified using the same notation used in Griswold \&
Griswold, and as described in the IPL program
{\textquotedbl}pargen.icn{\textquotedbl} later in this appendix with
the following difference: All metacharacters (space, tab, vertical
slash, right/left parentheses, brackets and angle brackets) are
converted to literals by prepending a backslash. Comments can be
included along with BNF rules using the same notation as for Icon code
(i.e. \#-sign).

Links: \textsf{trees, rewrap, scan, strip, stripcom, strings}. Requires:
co-expressions. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iftrace}}

These procedures \index{trace}trace Icon functions by using procedure
wrappers to call the functions. iftrace(fncs[]) sets tracing for a list
of function names. Links: \texttt{ifncs}. (SBW, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{image}}

\texttt{Image(x, style:1) : string} generalizes the function
\texttt{image(x)}, providing detailed information about structures. The
value of \texttt{style} determines the formatting and order of
processing. Style 1 is indented, with ] and ) at end of last item.
Style 2 is also indented, with ] and ) on new line. Style 3 puts the
whole image on one line. Style 4 is like style 3, with structures
expanded breadthfirst instead of depthfirst as for other styles.

Structures are identified by a letter identifying the type followed by
an integer. The tag letters are {\textquotedbl}L{\textquotedbl} for
lists, {\textquotedbl}R{\textquotedbl} for records,
{\textquotedbl}S{\textquotedbl} for sets, and
{\textquotedbl}T{\textquotedbl} for tables. The first time a structure
is encountered, it is imaged as the tag followed by a colon, followed
by a representation of the structure. If the same structure is
encountered again, only the tag is given. (MG, REG, DY)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inbits}}

\texttt{inbits(file,len:integer) : integer} re-imports data converted
into writable form by \texttt{outbits()}. See also:
\texttt{outbits.icn}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{indices}}

\texttt{indices(spec:list, last) : list} produces a list of the integers
given by the specification \texttt{spec}, which is a comma separated
list of positive integers or integer spans, as in
\texttt{{\textquotedbl}1,3-10,...{\textquotedbl}} If \texttt{last} is
specified, it is used for a span of the form
\texttt{{\textquotedbl}10-{\textquotedbl}}. In a span, the low and high
values need not be in order. For example,
\texttt{{\textquotedbl}1-10{\textquotedbl}} and
\texttt{{\textquotedbl}10-1{\textquotedbl}} are equivalent. Similarly,
indices need not be in order, as in \texttt{{\textquotedbl}3-10,
1,...{\textquotedbl}}. Empty values, as in
\texttt{{\textquotedbl}10,,12{\textquotedbl}} are ignored.
\texttt{indices()} fails if the specification is syntactically
erroneous or if it contains a value less than 1. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inserts}}

\texttt{inserts(table,key,value) : table} inserts values into a table in
which the same key can have more than one value (i.e.,
\index{key!duplicate}duplicate keys). The value of each element is a
list of inserted values. The table must be created with default value
\texttt{\&null}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{intstr}}

\textsf{intstr(i:integer,size:integer) : string} produces a string
consisting of the raw bits in the low order \texttt{size} bytes of
integer \texttt{i}. This procedure is used for processing of
\index{binary data}binary data to be written to a file. Note that if
large integers are supported, this procedure still will not work for
integers larger than the implementation defined word size due to the
shifting in of zero-bits from the left in the right shift operation.
(RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{io}}

These procedures provide facilities for handling \index{input}input,
\index{output}output, and \index{file}files. Some require
\texttt{loadfunc()}. Links: \texttt{random}, \texttt{strings}. (many)

\texttt{fcopy(fn1:string,fn2:string)} copies a file named \texttt{fn1}
to file named \texttt{fn2}.

\textsf{exists(name:string) : file?} succeeds if \texttt{name} exists as
a file but fails otherwise.

\texttt{filelist(s,x) : list} returns a list of the file names that
match the specification \texttt{s}. If \texttt{x} is nonnull, any
directory is stripped off. At present it only works for UNIX.

\texttt{filetext(f) : list} reads the lines of f into a list and returns
that list

\texttt{readline(file) : string?} assembles backslash-continued lines
from the specified file into a single line. If the last line in a file
ends in a backslash, that character is included in the last line read.

\texttt{splitline(file, line, limit)} splits \texttt{line} into pieces
at first blank after the limit, appending a backslash to identify split
lines (if a line ends in a backslash already, that{\textquotesingle}s
too bad). The pieces are written to the specified file.

\paragraph{Buffered input and output:}
\texttt{ClearOut()} remove contents of output buffer without
writing\\
\texttt{Flush()} flush output buffer\\
\texttt{GetBack()} get back line written\\
\texttt{LookAhead()} look ahead at next line\\
\texttt{PutBack(s)} put back a line\\
\texttt{Read()} read a line\\
\texttt{ReadAhead(n)} read ahead n lines\\
\texttt{Write(s)} write a line

See also module \texttt{bufread} for a multi-file implementation of
buffered input.

\paragraph{Path searching:}
\texttt{dopen(s) : file?} opens and returns the file \texttt{s} on
DPATH.

\texttt{dpath(s) : string?} returns the path to \texttt{s} on DPATH.

\texttt{pathfind(fname,
path:getenv({\textquotedbl}DPATH{\textquotedbl})) : string?} returns
the full path of fname if found along the space-separated list of
directories {\textquotedbl}path{\textquotedbl}. As is customary in Icon
path searching, {\textquotedbl}.{\textquotedbl} is prepended to the
path.

\texttt{pathload(fname,entry)} calls \texttt{loadfunc()} to load
\texttt{entry} from the file \texttt{fname} found on the function path.
If the file or entry point cannot be found, the program is aborted. The
function path consists of the current directory, then
\texttt{getenv({\textquotedbl}FPATH{\textquotedbl})}, and finally any
additional directories configured in the code.

\paragraph[Parsing file names:]{Parsing file names:}
\texttt{suffix() : list} parses a hierarchical file name, returning a
2-element list: [prefix,suffix]. For example,
\texttt{suffix({\textquotedbl}/a/b/c.d{\textquotedbl})} produces
\texttt{[{\textquotedbl}/a/b/c{\textquotedbl},{\textquotedbl}d{\textquotedbl}]}

\texttt{tail() : list} parses a hierarchical file name, returning a
2-element list: [head,tail]. For example,
\texttt{tail({\textquotedbl}/a/b/c.d{\textquotedbl})} produces
\texttt{[{\textquotedbl}/a/b{\textquotedbl},{\textquotedbl}c.d{\textquotedbl}]}.

\texttt{components() : list} parses a hierarchical file name, returning
a list of all directory names in the file path, with the file name
(tail) as the last element. For example,
\texttt{components({\textquotedbl}/a/b/c.d{\textquotedbl})} produces
\texttt{[{\textquotedbl}/{\textquotedbl},{\textquotedbl}a{\textquotedbl},{\textquotedbl}b{\textquotedbl},{\textquotedbl}c.d{\textquotedbl}]}.

\paragraph{Temporary files:}
\texttt{tempfile(prefix:{\textquotedbl}{\textquotedbl},suffix:{\textquotedbl}{\textquotedbl},path:{\textquotedbl}.{\textquotedbl},len:8)}
produces a temporary file that can be written. The name is chosen so as
not to overwrite an existing file. The \texttt{prefix} and
\texttt{suffix} are prepended and appended, respectively, to a randomly
chosen number. The \texttt{path} is prepended to the file name. The
randomly chosen number is fit into a field of \texttt{len} characters
by truncation or right filling with zeros as necessary. It is the
user{\textquotesingle}s responsibility to remove the file when it is no
longer needed.

\textsf{tempname(prefix:{\textquotedbl}{\textquotedbl},
suffix:{\textquotedbl}{\textquotedbl},
path:{\textquotedbl}.{\textquotedbl}, len:8)} produces the name of a
temporary file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iolib}}

This library provides control functions for text terminals, primarily
ANSI and VT-100 devices under UNIX and MS-DOS. MS-DOS users must add
{\textquotedbl}device=ansi.sys{\textquotedbl} (or a similar driver) to
the config.sys file. The TERM and TERMCAP \index{environment
variable!TERMCAP}environment variables must also be set in order to use
this library. The TERM variable tells iolib what driver you are using,
e.g. TERM=ansi-color for a typical MS-DOS user. The TERMCAP variable
gives the location of the termcap database file, as provided on your
UNIX system or given in the included file termcap.dos for MS-DOS.

Some useful termcap codes are {\textquotedbl}cl{\textquotedbl} (clear
screen), {\textquotedbl}ce{\textquotedbl} (clear to end of line),
{\textquotedbl}ho{\textquotedbl} (go to the top left square on the
screen), {\textquotedbl}so{\textquotedbl} (begin standout mode), and
{\textquotedbl}se{\textquotedbl} (end standout mode). The termcap
database holds not only string-valued sequences, but numeric ones as
well. The value of {\textquotedbl}li{\textquotedbl} tells you how many
lines the terminal has ({\textquotedbl}co{\textquotedbl} tells you how
many columns). To go to the beginning of the second-to-last line on the
screen: iputs(igoto(getval({\textquotedbl}cm{\textquotedbl}), 1,
getval({\textquotedbl}li{\textquotedbl})-1)). The
{\textquotedbl}cm{\textquotedbl} capability is a special capability,
and needs to be output via igoto(cm,x,y), where cm is the sequence
telling your computer to move the cursor to a specified spot, x is the
column, and y is the row.

\textsf{setname(term)} initializes the terminal as a term. Overrides
TERM environment variable.

\textsf{getval(id)} returns the terminal code for the capability named
id. Integer valued capabilities are returned as integers, strings as
strings, and flags as records (if a flag is set, then
\textsf{type(flag)} will return
\textsf{{\textquotedbl}true{\textquotedbl}}). Absence of a capability
is signaled by failure.

\texttt{igoto(cm,column,row)} returns a terminal code string that causes
the cursor to move to the designated column and row. cm is the cursor
movement command for the current terminal, as obtained via
getval({\textquotedbl}cm{\textquotedbl}). column and row count down and
to the right starting from the location (1,1).

\textsf{puts(s)} sends s out to the console. For example, to clear the
screen, \textsf{iputs(getval({\textquotedbl}cl{\textquotedbl}))}

Requires: UNIX or MS-DOS, co-expressions. See also: iscreen.icn. (RLG,
NA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iscreen}}

This file contains some rudimentary screen functions for use with
\texttt{iolib.icn}.

\texttt{clear()} clears the screen (tries several methods)\\
\texttt{clear\_emphasize()} clears the screen to all-emphasize
mode.\\
\texttt{emphasize()} initiates emphasized (usually reverse video dark on
light) mode\\
\texttt{boldface()} initiates bold mode\\
\texttt{blink()} initiates blinking mode\\
\texttt{normal()} resets to normal mode\\
\texttt{message(s)} displays message \texttt{s} on 2nd-to-last
line\\
\texttt{underline()} initiates underline mode\\
\texttt{status\_line(s,s2,p)} draws status line \texttt{s} on the
3rd-to-last screen line; if \texttt{s} is too short for the terminal,
\texttt{s2} is used; if \texttt{p} is nonnull then it either centers,
left-, or right-justifies, depending on the value,
\texttt{{\textquotedbl}c{\textquotedbl}},
\texttt{{\textquotedbl}l{\textquotedbl}}, or
\texttt{{\textquotedbl}r{\textquotedbl}}.

Requires: UNIX or MS-DOS. Links: \texttt{iolib}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{isort}}

\textsf{i}\index{sort}\textsf{sort}\textsf{(x,keyproc,y) : list} is a
customizable sort procedure. \texttt{x} can be any Icon data type that
supports the unary element generation (!) operator. The result is a
sorted list of objects. If \texttt{keyproc} is omitted, sorting occurs
in the standard Icon order; otherwise, sort keys are obtained from
within elements, instead of using the element itself as the key.
\texttt{keyproc} can be a procedure, in which case the first argument
to the key procedure is the item for which the key is to be computed,
and the second argument is isort{\textquotesingle}s argument
\texttt{y}, passed unchanged. The \texttt{keyproc} must produce the
extracted key. Alternatively, \texttt{keyproc} can be an integer, in
which case it specifies a subscript to be applied to each item to
produce a key. \texttt{keyproc} will be called once for each element of
structure \texttt{x}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itokens}}

\textsf{itokens(file, nostrip) : TOK*} breaks Icon source files up into
tokens for use in things like pretty printers, preprocessors, code
obfuscators, and so forth. itokens() suspends values of type
\textsf{record TOK(sym:string, str:string). sym} contains the name of
the next token, such as \textsf{{\textquotedbl}CSET{\textquotedbl}}, or
\textsf{{\textquotedbl}STRING{\textquotedbl}. str} gives that
token{\textquotesingle}s literal value. For example, the \textsf{TOK}
for a literal semicolon is
\textsf{TOK({\textquotedbl}SEMICOL{\textquotedbl},
{\textquotedbl};{\textquotedbl})}. For a mandatory newline,
\textsf{itokens()} would suspend
\textsf{TOK({\textquotedbl}SEMICOL{\textquotedbl},
{\textquotedbl}{\textbackslash}n{\textquotedbl}). itokens()} fails on
end-of-file. It returns syntactically meaningless newlines if the
second argument is nonnull. These meaningless newlines are returned as
TOK records with a null sym field (i.e. \textsf{TOK(\&null,
{\textquotedbl}{\textbackslash}n{\textquotedbl})}). If new reserved
words or operators are added to a given implementation, the tables in
this module have to be altered. Note: keywords are implemented at the
syntactic level; they are not tokens. A keyword like
\textsf{\&features} is suspended as an \textsf{\&} token followed by an
identifier token.

Links: \texttt{scan}. Requires: co-expressions. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ivalue}}

\textsf{ivalue(s):any} turns a string from \textsf{image()} into the
corresponding Icon value. It can handle integers, real numbers,
strings, csets, keywords, structures, and procedures. For the image of
a structure, it produces a result of the correct type and size, but
values in the structure are not correct, since they are not encoded in
the image. For procedures, the procedure must be present in the
environment in which \textsf{ivalue()} is evaluated. This generally is
true for built-in procedures (functions). All keywords are supported.
The values produced for non-constant keywords are, of course, the
values they have in the environment in which \textsf{ivalue()} is
evaluated. \textsf{ivalue()} handles non-local variables
(\textsf{image()} does not produce these), but they must be present in
the environment in which \textsf{ivalue()} is evaluated. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{jumpque}}

\textsf{jumpque(}\index{queue}\textsf{queue}\textsf{:list,y):list} moves
\textsf{y} to the head if it is in the queue; otherwise it adds
\texttt{y} to the head of the queue. A copy of the queue is returned.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kmap}}

\textsf{kmap(string) : string} maps uppercase letters and the control
modifier key in combination with letters into the corresponding
lowercase letters. It is for graphic applications in which the modifier
keys for shift and control are encoded in \index{keyboard}keyboard
events. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lastc}}

These string scanning functions follow standard conventions for
defaulting the last three parameters to the current scanning
environment. (DAG)

\textsf{lastc(c:cset, s:string, i1:integer, i2:integer) : integer}
succeeds and produces \textsf{i1}, provided either that \textsf{i1} is
\textsf{1}, or that \textsf{s[i1 - 1]} is in \textsf{c} and \textsf{i2}
is greater than \textsf{i1}.

\textsf{findp(c:cset, s1:string, s2:string, i1:integer, i2:integer) :
integer*} generates the sequence of positions in \textsf{s2} at which
\textsf{s1} occurs provided that \textsf{s2} is preceded by a character
in \textsf{c}, or is found at the beginning of the string.

\textsf{findw(c1:cset, s1:string, c2:cset, s2:string, i1:integer,
i2:integer) : integer*} generates the sequence of positions in
\textsf{s2} at which \textsf{s1} occurs provided that \textsf{s2} is
preceded and followed by the empty string or a member of \textsf{c1}
and \textsf{c2, respectively}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lastname}}

\textsf{lastname(s:string) : string} produces the last name in string
\textsf{s}, which must be a name in conventional form. Obviously, it
doesn{\textquotesingle}t work for every possibility. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{list2tab}}

\textsf{list2tab(list) : null} writes a list as a tab-separated string
to \textsf{\&output}. Carriage returns in files are converted to
vertical tabs.

See also: tab2list.icn, tab2rec.icn, rec2tab.icn. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lists}}

Many of these procedures implement \index{list functions}list functions
similar to string functions, including an implementation of
\index{scanning!list}list scanning, similar to Icon{\textquotesingle}s
string scanning functions.

\texttt{lcomb(L,i):L*} produces all sublist combinations of \texttt{L}
that have \texttt{i} elements.\\
\texttt{ldelete(L,spec:string):L} deletes values of \texttt{L} at
indices given\\
 \ \ \ \ in \texttt{spec}; see \texttt{indices}.\\
\texttt{lequiv(L1,L2):L?} tests if \texttt{L1} and \texttt{L2} are
structurally equivalent.\\
 \ \ \ \ lequiv() does not detect cycles.\\
\texttt{lextend(L,i,x):L} extends \texttt{L} to at least size
\texttt{i}, using initial value \texttt{x}.\\
\texttt{limage(L):string} list image function that shows
elements{\textquotesingle} images, one level deep.\\
\texttt{linterl(L1,L2):L} interleaves elements of \texttt{L1} and
\texttt{L2}. If \texttt{L1} and \texttt{L2} are not the\\
 \ \ \ \ same size, the shorter list is extended with null values to the
size of the larger list.\\
\texttt{llpad(L,i,x):L} produces a new list that extends \texttt{L} on
its front (left) side.\\
\texttt{lltrim(L,S):L} produces a copy of \texttt{L} with elements of
\texttt{S} trimmed on the left.\\
\textsf{lmap(L1,L2,L3):L} maps elements of \textsf{L1} according to
\textsf{L2} and \textsf{L3}, similar to the string-\\
 \ \ \ \ mapping function \textsf{map(s1, s2,s3)}. Elements in
\textsf{L1} that are the same as elements in \textsf{L2}\\
 \ \ \ \ are mapped into the corresponding elements of \texttt{L3}. For
example, given the lists\\
 \ \texttt{\ \ \ }\textsf{L1 := [1,2,3,4]; L2 := [4,3,2,1]; L3 :=
[{\textquotedbl}a{\textquotedbl},{\textquotedbl}b{\textquotedbl},{\textquotedbl}c{\textquotedbl},{\textquotedbl}d{\textquotedbl}]}\\
 \ \ \ \ then \textsf{lmap(L1, L2,L3)} produces a new list
\textsf{[{\textquotedbl}d{\textquotedbl},{\textquotedbl}c{\textquotedbl},{\textquotedbl}b{\textquotedbl},{\textquotedbl}a{\textquotedbl}]}.
The lists can have any kinds\\
 \ \ \ \ of elements. The operation \textsf{x === y} is used to
determine if elements \texttt{x} and \texttt{y} are\\
 \ \ \ \ equivalent. No defaults are provided for omitted arguments. As
with \textsf{map(), lmap()},\\
 \ \ \ \ can be used for transposition as well as substitution.
\textbf{Warning: }If \textsf{lmap()} is called with\\
 \ \ \ \ the same lists \textsf{L2} and \textsf{L3} as in the
immediately preceding call, the same mapping is\\
 \ \ \ \ performed, even if the values in \textsf{L2} and \textsf{L3}
have been changed. This improves\\
 \ \ \ \ performance, but it may cause unexpected effects. This
{\textquotedbl}caching{\textquotedbl} of the mapping\\
 \ \ \ \ table based on \textsf{L2} and \textsf{L3} can be easily
removed to avoid this potential problem.\\
\texttt{lpalin(L):L} produces a list palindrome of \texttt{L}
concatenated with its reverse.\\
\texttt{lpermute(L):L*} produces all the permutations of list
\texttt{L}.\\
\texttt{lreflect(L,i:0):L} returns \texttt{L} concatenated with its
reversal to produce a\\
 \ \ \ \ palindrome. The values of \texttt{i} determine
{\textquotedbl}end conditions{\textquotedbl} for the reversal:\\
 \ \ \ \ 0 = omit first and last elements. 1 = omit first element, 2 =
omit last element,\\
 \ \ \ \ 3 = don{\textquotesingle}t omit element.\\
\texttt{lremvals(L, x1, x2, ...) : list} produces a copy of L, without
those\\
 \ \ \ \ elements that are === x1, x2?\\
lrepl(L,i):L \index{replicate list}\index{replicate list}replicates L i
times.\\
lrotate(L,i):L produces a list with the elements of L, rotated i
positions.\\
lrpad(L,i,x):L is like lextend(), but produces a new list instead of
changing L.\\
lrtrim(L,S:set):L produces a copy of L with elements of S trimmed on the
left.\\
lswap(L):L produces a copy of L with odd elements swapped with even
elements.\\
lunique(L):L produces a list containing only unique list elements.

\paragraph{List Scanning}
\texttt{global l\_POS, l\_SUBJ} are the current list scanning
environment\\
\textsf{record l\_ScanEnvir(subject,pos)} represents (nested) list
scanning environments\\
\texttt{l\_Bscan(e1) : l\_ScanEnvir} enter (possibly nested) list
scanning environment\\
\texttt{l\_Escan(l\_OuterEnvir, e2) : any} exit list scanning
environment

List Scanning Function\ \ \ \ \ \ \ \ String Scanning Equivalent

l\_any(l1, l2,i,j) : integer?\ \ \ \ any()\\
l\_bal(l1,l2,l3,l,i,j) : integer*\ \ bal()\\
l\_find(l1,l2,i,j) : integer*\ \ \ \ find()\\
l\_many(l1,l2,i,j) : integer?\ \ \ \ many()\\
l\_match(l1,l2,i,j) : integer?\ \ \ \ match()\\
l\_move(i) : list\ \ \ \ \ \ \ \ move()\\
l\_pos(i) : integer\ \ \ \ \ \ \ \ pos()\\
l\_tab(i)\ \ : list\ \ \ \ \ \ \ \ tab()\\
l\_upto(l1,l2,i,j) : integer?\ \ \ \ upto()

This set of functions implements operations for analyzing lists of
tokens similar to string scanning. \texttt{l\_find()} and
\texttt{l\_match()} accept lists as their first argument.
\texttt{l\_any()}, \texttt{l\_many()}, and \texttt{l\_upto()} take
either sets of lists or lists of lists. \texttt{l\_bal()} has no
defaults for the first four arguments, since there is no precise list
analogue to \texttt{\&cset}, etc. List scanning environments are not
maintained as elegantly as for string scanning. You must use a set of
nested procedure calls \texttt{l\_Bscan()} and \texttt{l\_Escan()}, as
explained in the \textit{Icon Analyst} 1:6 (June, 1991), p. 1-2. In
particular, you cannot suspend, return, or otherwise break out of the
nested procedure calls; they can only be exited via failure. Here is an
example of how list scanning might be invoked:

\iconcode{
suspend l\_Escan(l\_Bscan(some\_list\_or\_other), \{ \\
\>   l\_tab(10 to *l\_SUBJ) \& \{ \\
\>   if l\_any(l1) {\textbar} l\_match(l2) then old\_l\_POS +
(l\_POS-1) \\
\>   \} \\
\>   \})
}

List scanning environments may be nested, and may be used to generate a
series of results as well. Here{\textquotesingle}s an example of nested
list scanning:

\iconcode{
procedure main() \\
\ \ \ l :=
[{\textquotedbl}h{\textquotedbl},{\textquotedbl}e{\textquotedbl},{\textquotedbl}l{\textquotedbl},{\textquotedbl}l{\textquotedbl},{\textquotedbl}o{\textquotedbl},{\textquotedbl}
{\textquotedbl},{\textquotedbl}t{\textquotedbl},{\textquotedbl}t{\textquotedbl},{\textquotedbl}t{\textquotedbl},{\textquotedbl}h{\textquotedbl},{\textquotedbl}e{\textquotedbl},{\textquotedbl}r{\textquotedbl},{\textquotedbl}e{\textquotedbl}] \\
\>   l\_Escan(l\_Bscan(l), \{ \\
\>   \ \ \ hello\_list :=
l\_tab(l\_match([{\textquotedbl}h{\textquotedbl},{\textquotedbl}e{\textquotedbl},{\textquotedbl}l{\textquotedbl},{\textquotedbl}l{\textquotedbl},{\textquotedbl}o{\textquotedbl}])) \\
\>   \ \ \ every writes(!hello\_list) \\
\>   \ \ \ write() \# Note the nested list-scanning expressions. \\
\>   \ \ \ l\_Escan(l\_Bscan(l\_tab(0)), \{ \\
\>   \ \ \ \ \ \ l\_tab(l\_many([[{\textquotedbl}
{\textquotedbl}],[{\textquotedbl}t{\textquotedbl}]]) - 1) \\
\>   \ \ \ \ \ \ every writes(!l\_tab(0)) \\
\>   \ \ \ \ \ \ write() \\
\>   \ \ \ \ \ \ \}) \\
\>   \ \ \ \}) \\
end
}

The above program writes {\textquotedbl}hello{\textquotedbl} and
{\textquotedbl}there{\textquotedbl} on successive lines to the standard
output.

The functions compare lists, not strings, so
\textsf{l\_find({\textquotedbl}h{\textquotedbl}, l)}, for instance,
will yield an error message: use
\textsf{l\_find([{\textquotedbl}h{\textquotedbl}], l)} instead. This
becomes confusing when looking for lists within lists. Suppose
\textsf{l1 := [{\textquotedbl}junk{\textquotedbl},
[[{\textquotedbl}hello{\textquotedbl}],{\textquotedbl}
{\textquotedbl},[{\textquotedbl}there{\textquotedbl}]],{\textquotedbl}!{\textquotedbl},{\textquotedbl}m{\textquotedbl},{\textquotedbl}o{\textquotedbl},{\textquotedbl}r{\textquotedbl},{\textquotedbl}e{\textquotedbl},{\textquotedbl}junk{\textquotedbl}]}
and you wish to find the position in \textsf{l1} at which the list
\textsf{[[{\textquotedbl}hello{\textquotedbl}],{\textquotedbl}
{\textquotedbl},[{\textquotedbl}there{\textquotedbl}]]} occurs. If you
assign \textsf{L2 :=
[[{\textquotedbl}hello{\textquotedbl}],{\textquotedbl}
{\textquotedbl},[{\textquotedbl}there{\textquotedbl}]]}, then the
\textsf{l\_find()} call needs to look like \textsf{l\_find([l2],l1)}.

Links: \texttt{indices}. See also: \texttt{structs.icn}. (REG, RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{loadfile}}

\texttt{loadfile(exp, link,...)} creates and loads a program that
generates the results of exp. The trailing arguments name link files
needed for the expression. \texttt{loadfile()} returns a procedure that
generates the results.

Requires: MT-Icon, \texttt{system()}, pipes, \texttt{/tmp}. Links:
\texttt{io}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{longstr}}

String scanning function \texttt{longstr(l,s,i,j) : integer?} works like
\texttt{any()}, except that instead of taking a cset as its first
argument, it takes instead a list or set of strings (\texttt{l}).
Returns \texttt{i + *x}, where \texttt{x} is the \index{longest
match}longest string in \texttt{l} for which \texttt{match(x,s,i,j)}
succeeds, if there is such an \texttt{x}. (JN,SBW,KW,RJA,RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lrgapprx}}

\texttt{lrgapprx(i) : string} produces an approximate of an integer
value in the form \texttt{i.jx10\^{}k}. It is primarily useful for
large integers. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lu}}

\texttt{lu\_decomp(M, I) : real?} performs \index{LU decomposition}LU
decomposition on the square matrix \texttt{M} using the vector
\texttt{I}. Both \texttt{M} and \texttt{I} are modified. The value
returned is +1.0 or -1.0 depending on whether the number of row
interchanges is even or odd. \texttt{lu\_decomp()} is used in
combination with \texttt{lu\_back\_sub()} to solve linear equations or
invert matrices. \texttt{lu\_decomp()} fails if the matrix is singular.

\texttt{lu\_back\_sub(M, I, B)} solves the set of linear equations
\textit{M x X = B}. \texttt{M} is the matrix as modified by
\texttt{lu\_decomp()}. \texttt{I} is the index vector produced by
\texttt{lu\_decomp()}. \texttt{B} is the right-hand side vector and
return with the solution vector. \texttt{M} and \texttt{I} are not
modified by \texttt{lu\_back\_sub()} and can be used in successive
calls of \texttt{lu\_back\_sub()} with different \texttt{B}s.
Acknowledgement: These procedures are based on algorithms given in
{\textquotedbl}Numerical Recipes; The Art of Scientific
Computing{\textquotedbl}; William H. Press, Brian P. Flannery, Saul A.
Teukolsky, and William T. Vetterling; Cambridge University Press, 1986.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mapbit}}

\texttt{mapbit(s:string) : string} produces a string of zeros and ones
corresponding to the bit patterns for the characters of s. For example,
\texttt{mapbit({\textquotedbl}Axe{\textquotedbl})} produces
\texttt{{\textquotedbl}010000010111100001100101{\textquotedbl}}. Links:
\texttt{strings}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mapstr}}

\texttt{mapstrs(string, l1:list, l2:list) : string} works like
\texttt{map()}, except that instead of taking ordered character
sequences (strings) as arguments 2 and 3, it takes ordered string
sequences (lists). Suppose, for example, you wanted to
\index{bowdlerize}bowdlerize a string by replacing the words
{\textquotedbl}hell{\textquotedbl} and
{\textquotedbl}shit{\textquotedbl} with
{\textquotedbl}heck{\textquotedbl} and
{\textquotedbl}shoot.{\textquotedbl} You would call mapstrs as
follows:\\
\texttt{mapstrs(s, [{\textquotedbl}hell{\textquotedbl},
{\textquotedbl}shit{\textquotedbl}],
[{\textquotedbl}heck{\textquotedbl},
{\textquotedbl}shoot{\textquotedbl}])}. If you want to replace one
string with another, just use the IPL \texttt{replace()} routine (in
\texttt{strings.icn}). If \texttt{l2} is longer than \texttt{l1}, extra
members in \texttt{l2} are ignored. If \texttt{l1} is longer, however,
strings in \texttt{l1} that have no correspondent in \texttt{l2} are
simply deleted. \texttt{mapstr()} uses a longest-possible-match
approach, so that replacing
\texttt{[{\textquotedbl}hellish{\textquotedbl},
{\textquotedbl}hell{\textquotedbl}]} with
\texttt{[{\textquotedbl}heckish{\textquotedbl},
{\textquotedbl}heck{\textquotedbl}]} will work as one would expect.

Links: \texttt{longstr}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{math}}

\texttt{binocoef(n:integer, k:integer) : integer?} produces the
\index{binomial coefficient}binomial coefficient \texttt{n} over
\texttt{k}. It fails unless 0 {\textless}= \texttt{k} {\textless}=
\texttt{n}.\\
\texttt{cosh(r:real) : real} produces the \index{hyperbolic
functions}hyperbolic cosine of \texttt{r}.\\
\texttt{sinh(r:real) : real} produces the hyperbolic sine of
\texttt{r}.\\
\texttt{tanh(r:real) : real} produces the hyperbolic tangent of
\texttt{r}.

Links: \texttt{factors}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{matrix}}

This file contains procedures for \index{matrix manipulation}matrix
manipulation. Matrices (arguments beginning with M) are represented as
lists of lists.

\texttt{matrix\_width(M) : integer} produces the number of columns in a
\ matrix.\\
\texttt{matrix\_height(M) : integer} produces the number of rows in a
matrix.\\
\texttt{write\_matrix(file, M, x)} outputs a matrix to a file, one row
per line. If \texttt{x} is\\
 \ \ \ \ \ nonnull, elements are comma-separated and rows are enclosed
in square brackets,\\
 \ \ \ \ \ like list literals.\\
\texttt{copy\_matrix(M) : list} produces a copy of a matrix.\\
\texttt{create\_matrix(n,m,x) : list} creates an \texttt{n} by
\texttt{m} matrix with initial value \texttt{x}.\\
\texttt{identity\_matrix(n,m) : list} produces an identity matrix of
size \texttt{n} by \texttt{m}\textsubscript{.}\\
\texttt{add\_matrix(M1,M2) : list} produces the matrix addition of
\texttt{M1} and \texttt{M2.}\\
\texttt{mult\_matrix(M1,M2) : list} produces the matrix multiplication
of \texttt{M1} and \texttt{M2.}\\
\texttt{invert\_matrix(M) : list} produces the matrix inversion of
\texttt{M}.\\
\texttt{determinant(M) : real} produces the determinant of \texttt{M}.

Links: \texttt{lu}. (SBW, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{memlog}}

\texttt{memlog(f:\&output) : integer} writes a message to file
\texttt{f} recording the current memory usage in the string and block
regions. For each, three figures are written: amount in use, amount
reserved, and number of collections. \texttt{memlog()} does not perturb
the figures: it requires no allocation itself. \texttt{memlog()}
returns the total current usage. (GMT)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{morse}}

\texttt{morse(s:string) : string} converts \texttt{s} to its
\index{Morse code}Morse code equivalent. The version used is known both
as International Morse Code and as Continental Code, and is used by
radio amateurs (hams). (REG, RM)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mset}}

\texttt{same\_value(d1,d2) : ? \ }\ \ \ compares \texttt{d1} and
\texttt{d2} for structural equivalence.\\
\texttt{insert2(S:set, el) : set} inserts \texttt{el} into \texttt{S}
\\
\texttt{member2(S:set, el) : ?} \ \ \ \ \ tests whether \texttt{el} (or
its structural equivalent) is in \texttt{S}.\\
\texttt{delete2(S:set, el) : set} deletes \texttt{el} (or its structural
equivalent) from \texttt{S}.

The mset module implements set operations in which no two identical
(structurally equivalent) values can be present in a set. (JPR)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{namepfx}}

\texttt{namepfx(s:string) : string} produces the {\textquotedbl}name
prefix{\textquotedbl} from a name in standard form -{}- omitting any
title, but picking up the first name and any initials.
\texttt{namepfx()} only knows how to omit common titles found in module
\texttt{titleset}. Obviously, it can{\textquotesingle}t always produce
the {\textquotedbl}correct{\textquotedbl} result. Links:
\texttt{lastname}, \texttt{titleset}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ngrams}}

\texttt{ngrams(file,n,c:\&letters,t) : string*} generates a tabulation
of the n-grams in the specified file. If \texttt{c} is non-null, it is
used as the set of characters from which \index{n-grams}n-grams are
taken (other characters break n-grams). If \texttt{t} is non-null, the
tabulation is given in order of frequency; otherwise in alphabetical
order of n-grams. Note: This procedure is unsuitable if there are very
many different n-grams. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{numbers}}

These procedures format numbers in various ways:

\texttt{amean(L) : real} returns arithmetic \index{mean values}mean of
numbers in L.\\
\index{ceil(r)}\texttt{ceil(r) : integer} returns nearest integer to
\texttt{r} away from 0.\\
\texttt{commas(s) : string} inserts commas in s to separate digits into
groups of three.\\
\texttt{decipos(r,i:3,j:5):string?} position decimal point at \texttt{i}
in \texttt{r} in field width \texttt{j}.\\
\texttt{digred(i) : integer} reduces a number by adding digits until one
digit is reached.\\
\texttt{div(i:number,j:number) : real} produces the result of real
\index{division}division of \texttt{i} by \texttt{j}.\\
\texttt{fix(i, j:1, w:8, d:3) : string?} formats \texttt{i / j} as a
real (floating-point)\\
 \ \ \ \ number in a field of width \texttt{w} with \texttt{d} digits to
the right of the decimal point, if possible.\\
 \ \ \ \ If \texttt{w} is less than 3 it is set to 3. If \texttt{d} is
less than 1, it is set to 1. The function fails if \texttt{j}
is\\
 \ \ \ \ 0 or if the number cannot be formatted.\\
\index{floor(r)}\texttt{floor(r)}\texttt{ : integer} nearest integer to
\texttt{r} toward 0\\
\texttt{gcd(i,j):integer?} returns greatest common divisor of i and j.
It fails if both are 0.\\
\texttt{gcdl(L:list): integer} returns the greatest common division of a
list of integers.\\
\texttt{gmean(args?) : real?} returns the geometric mean of
numbers.\\
\texttt{hmean(args?) : real?} returns the harmonic mean of
numbers.\\
\texttt{large(i) : integer?} succeeds if \texttt{i} is a large integer
but fails otherwise.\\
\texttt{lcm(i, j) : integer?} returns the least common multiple of i and
j.\\
\texttt{lcml(L): integer?} returns the least common multiple of the
integers in the list L.\\
\texttt{npalins(n) : string*} generates palindromic n-digit
numbers\\
\texttt{roman(i) : string?} converts \texttt{i} to \index{Roman
numerals}Roman numerals.\\
\texttt{round(r:real) : integer} returns nearest integer to
\texttt{r}.\\
\texttt{sign(r) : integer} returns sign of \texttt{r}.\\
\texttt{spell(i : integer) : string?} spells out \texttt{i} in
English.\\
\texttt{trunc(r:real) : integer} returns nearest integer less than
\texttt{r}.\\
\texttt{unroman(string) : integer} converts Roman numerals to integers.

Links: \texttt{strings}. (REG, RJA, RLG, TK)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{openchk}}

\texttt{OpenCheck()} causes subsequent opens and closes to write
diagnostic information to \texttt{\&errout}. Useful for diagnosing
situations where many files are opened and closed and there is a
possibility that some files are not always being closed. (DAG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{options}}

\texttt{options(args:list, opt:string, err:stop) : table} separates,
interprets, and removes UNIX-style \index{options, command-line}command
options from the argument list of an Icon \texttt{main()} procedure,
returning a table of option values. On the command line, options are
introduced by a \texttt{{\textquotedbl}-{\textquotedbl}} character. An
option name is either a single printable character, as in
\texttt{{\textquotedbl}-n{\textquotedbl}} or
\texttt{{\textquotedbl}-?{\textquotedbl}}, or a string of letters, as
in \texttt{{\textquotedbl}-geometry{\textquotedbl}}. Valueless
single-character options may appear in combination, for example as
\texttt{{\textquotedbl}-qtv{\textquotedbl}}. Some options require
values. Generally, the option name is one argument and the value
appears as the next argument, for example

{\ttfamily
{\textquotedbl}-F file.txt{\textquotedbl}}

However, with a single-character argument name (as in that example), the
value may be concatenated:
\texttt{{\textquotedbl}-Ffile.txt{\textquotedbl}} is accepted as
equivalent. Options may be freely interspersed with non-option
arguments. An argument of \texttt{{\textquotedbl}-{\textquotedbl}} is
treated as a non-option. The special argument
\texttt{{\textquotedbl}-{}-{\textquotedbl}} terminates option
processing. Non-option arguments are returned in the original argument
list for interpretation by the caller. An argument of the form
\texttt{@filename} (a {\textquotedbl}@{\textquotedbl} immediately
followed by a file name) causes \texttt{options()} to replace that
argument with arguments retrieved from the file
{\textquotedbl}filename{\textquotedbl}. Each line of the file is taken
as a separate argument, exactly as it appears in the file. (RJA, GMT)

The options string is a concatenation, with optional spaces between, of
one or more option specs of the form
\texttt{{}-}\texttt{\textit{name}}\texttt{\%} where \texttt{{}-}
introduces the option.

\texttt{\textit{name}} is either a string of letters or any single
printable character

\texttt{\%} is one of the following flag characters:

\texttt{!}\ \ No value is required or allowed\\
\texttt{:}\ \ A string value is required\\
\texttt{+}\ \ An integer value is required\\
\texttt{.}\ \ A real value is required

The leading \texttt{{\textquotedbl}-{\textquotedbl}} may be omitted for
a single-character option. The \texttt{{\textquotedbl}!{\textquotedbl}}
flag may be omitted except when needed to terminate a multi-character
name. Thus, the following optstrings are equivalent:
\texttt{{\textquotedbl}-n+ -t -v -q -F: -geometry:
-silent{\textquotedbl}}
\texttt{{\textquotedbl}n+tvqF:-geometry:-silent{\textquotedbl}}\\
\texttt{{\textquotedbl}-silent!n+tvqF:-geometry{\textquotedbl}}. If the
options string is omitted, any single letter is assumed to be valid and
require no data.

The \texttt{err} procedure will be called if an error is detected in the
command line options. The procedure is called with one argument: a
string describing the error that occurred. After \texttt{err()} is
called, \texttt{options()} immediately returns the outcome of
\texttt{errproc()}, without processing further arguments. Already
processed arguments will have been removed from args.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{outbits}}

\texttt{outbits(i:integer, len:integer) string*} fits variable and/or
non-byte-sized blocks into standard 8-bit bytes. \texttt{outbits()}
will suspend byte-sized chunks of \texttt{i} converted to characters
(most significant bits first) until there is not enough left of
\texttt{i} to fill up an 8-bit character. The remaining portion is
stored in a buffer until \texttt{outbits()} is called again, at which
point the buffer is combined with the new \texttt{i} and then output in
the same manner as before. The buffer is flushed by calling
\texttt{outbits()} with a null \texttt{i} argument. Note that
\texttt{len} gives the number of bits there are in \texttt{i} (or at
least the number of bits you want preserved; those that are discarded
are the most significant ones). A trivial example of how
\texttt{outbits()} might be used:

\iconcode{
outtext :=
open({\textquotedbl}some.file.name{\textquotedbl},{\textquotedbl}w{\textquotedbl}) \\
L := [1,2,3,4] \\
every writes(outtext, outbits(!L,3)) \\
writes(outtext, outbits(\&null,3)) \# flush buffer
}

List L may be reconstructed with \texttt{inbits()}:

\iconcode{
intext := open({\textquotedbl}some.file.name{\textquotedbl}) \\
L := [] \\
while put(L, inbits(intext, 3))
}

Note that \texttt{outbits()} is a \index{generator}generator, while
\texttt{inbits()} is not.

See also: \texttt{inbits.icn}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{packunpk}}

\texttt{pack(num:i,width:i):string} produces a binary-coded decimal
representation\\
 \ \ \ \ of \texttt{num} in which each character contains two decimal
digits stored in four bits each.\\
\texttt{unpack(val:s,width:i):string} converts a binary-coded decimal
back to a\\
 \ \ \ \ string representation \ \texttt{width} characters long of the
original source integer.\\
\texttt{unpack2(val:string) : integer} converts a binary-coded decimal
back into its\\
 \ \ \ \ original source integer.

Links: \texttt{convert.} (CT, RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{partit}}

\texttt{partit(i,min:i,max:i):L*} generates the partitions of
\texttt{i}; that is the ways that \texttt{i\\
} \ \ \ \ can be represented as a sum of positive integers with minimum
and maximum values.\\
partcount(i,min:i,max:i):integer returns the number of
partitions.\\
\texttt{fibpart(i):L} returns a list of Fibonacci numbers that is a
partition of \texttt{i}.

Links: \texttt{fastfncs}, \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patterns}}

This module provides string scanning procedure equivalents for most
\index{SNOBOL4}SNOBOL4 \index{patterns, SNOBOL4}patterns and some
extensions. Procedures and their pattern equivalents are:

Procedure\ \ Equivalent SNOBOL pattern

Any(s)\ \ \ \ ANY(S)\\
Arb()\ \ \ \ ARB\\
Arbno(p)\ \ ARBNO(P)\\
Arbx(i)\ \ ARB(I)\\
Bal()\ \ \ \ BAL\\
Break(s)\ \ BREAK(S)\\
Breakx(s)\ \ BREAKX(S)\\
Cat(p1,p2)\ \ P1 P2\\
Discard(p)\ \ /P\\
Exog(s)\ \ {\textbackslash}S\\
Find(s)\ \ \ \ FIND(S)\\
Len(i)\ \ \ \ LEN(I)\\
Limit(p,i)\ \ P {\textbackslash} I\\
Locate(p)\ \ LOCATE(P)\\
Marb()\ \ \ \ longest-first ARB\\
Notany(s)\ \ NOTANY(S)\\
Pos(i)\ \ \ \ POS(I)\\
Replace(p,s)\ \ P = S\\
Rpos(i)\ \ RPOS(I)\\
Rtab(i)\ \ \ \ RTAB(I)\\
Span(s)\ \ SPAN(S)\\
String(s)\ \ S\\
Succeed()\ \ SUCCEED\\
Tab(i)\ \ \ \ TAB(I)\\
Xform(f,p)\ \ F(P)

The following procedures relate to the application and control of
\index{pattern matching}pattern matching:

Apply(s,p)\ \ S ? P\\
Mode()\ \ anchored or unanchored matching (see Anchor() and
Float())\\
Anchor()\ \ \&ANCHOR = 1 if Mode := Anchor\\
Float()\ \ \ \ \&ANCHOR = 0 if Mode := Float

In addition to the procedures above, the following expressions can be
used:

p1() {\textbar} p2()\ \ P1 {\textbar} P2\\
v {\textless}- p()\ \ P . V (approximate)\\
v := p()\ \ P . V (approximate)\\
fail\ \ \ \ FAIL\\
=s\ \ \ \ S (in place of String(s))\\
p1() {\textbar}{\textbar} p2()\ \ P1 P2 (in place of Cat(p1,p2))

Using this system, most SNOBOL4 patterns can be satisfactorily
transliterated into Icon procedures and expressions. For example, the
pattern

\iconcode{
SPAN({\textquotedbl}0123456789{\textquotedbl}) . N
{\textquotedbl}H{\textquotedbl} LEN(*N) . LIT}

can be transliterated into

\iconcode{
(n {\textless}- Span({\textquotesingle}0123456789{\textquotesingle}))
{\textbar}{\textbar} ={\textquotedbl}H{\textquotedbl}
{\textbar}{\textbar} (lit {\textless}- Len(n))}

Concatenation of components is necessary to preserve the
pattern-matching properties of SNOBOL4. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patword}}

\textsf{patword(s:string) : string} returns a letter pattern in which
each different character in \texttt{s} is assigned a letter. For
example, \textsf{patword({\textquotedbl}structural{\textquotedbl})}
returns \textsf{{\textquotedbl}abcdebdcfg{\textquotedbl}}. (KW)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{phoname}}

\textsf{phoname(telno:string) : string*} generates the letter
combinations corresponding to the digits in a telephone number. The
number of possibilities is very large. This procedure should be used in
a context that limits or filters its output. (TRH)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{plural}}

\texttt{plural(word:string) : string} produces the \index{plural
form}plural form of a singular English noun. The procedure here is
rudimentary and is not correct in all cases. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{polystuf}}

These procedures are for creating and performing operations on
single-variable \index{polynomials}polynomials (like ax\^{}2 + bx + c).
A polynomial is represented as a table in which the keys are exponents
and the values are coefficients. (EE)

\texttt{poly(c1, e1, c2, e2, ...) : poly} creates a polynomial from
the\\
 \ \ \ \ \ parameters given as coefficient-exponent pairs:
\texttt{c1x\^{}e1 + c2x\^{}e2 + ...}\\
\texttt{is\_zero(n) : ?
\ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ determines if n = 0\\
\texttt{is\_zero\_poly(p) : ?} \ \ \ \ \ \ \ \ \ \ determines if a given
polynomial is 0x\^{}0\\
\texttt{poly\_add(p1, p2) : poly} returns the sum of two
polynomials\\
\texttt{poly\_sub(p1, p2) : poly} returns the difference of p1 -
p2\\
\texttt{poly\_mul(p1, p2) : poly} returns the product of two
polynomials\\
\textsf{poly\_eval(p, x) : poly} finds the value of polynomial p when
evaluated at the given x.\\
\textsf{term2string (c, e) : string} converts one coefficient-exponent
pair into a string.\\
\textsf{poly\_string(p) : string} returns the string representation of
an entire polynomial. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{printcol}}

printcol(items, fields, title:{\textquotedbl}{\textquotedbl},
pagelength:30000, linelength:80, auxdata) deals with the problem of
printing tabular data where the total width of items to be printed is
wider than the page. Simply allowing the data to wrap to additional
lines often produces marginally readable output. This procedure
facilitates printing such groups of data as vertical columns down the
page length, instead of as horizontal rows across the page. That way
many, many fields can be printed neatly. The programming of such a
transformation can be a nuisance. This procedure does much of the work
for you, like deciding how many items can fit across the page width and
ensuring that entire items will be printed on the same page without
page breaks (if that service is requested). (RJA)

For example, suppose you have a list of records to print. The record is
defined as:\\
\texttt{record rec(item1,item2,item3,...)} Also suppose that lines such
as

\iconcode{
Field 1 Field 2 Field 3 ... \\
{}-{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}- -{}-{}- \\
Record 1 item1 item2 item3 ... \\
Record 2 item1 item2 item3 ...
}

are too long to print across the page. This procedure will print them
as:

\iconcode{
TITLE \\
===== \\
Record 1 Record 2 ... \\
{}-{}-{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}-{}- -{}-{}- \\
Field 1 item1 item1 ... \\
Field 2 item2 item2 ... \\
Field 3 item3 item3 ...
}

The arguments are:

\texttt{items}: a co-expression that produces a sequence of items
(usually structured data objects, but not necessarily) for which data
is to be printed.

\texttt{fields}: a list of procedures to produce the
field{\textquotesingle}s data. Each procedure takes two arguments. The
procedure{\textquotesingle}s action depends upon what is passed in the
first argument:

\texttt{header} produces the row heading string to be used for that
field (the field name).

\textsf{width} produces the maximum field width (including the column
header).

\texttt{other} produces the field value string for the item passed as
the argument.

The second argument is arbitrary data from the procedures with each
invocation. The data returned by the first function on the list is used
as a column heading (the item name).

\textsf{auxdata}: arbitrary auxiliary data to be passed to the field
procedures -{}- see {\textasciigrave}fields{\textquotesingle}, above.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{printf}}

This module provides Icon versions of the
\index{printf()}\texttt{printf()} family of formatted output functions
from the C language.

\textsf{printf(fmt:string, args[])} formats and writes arguments to
\textsf{\&output}.\\
\textsf{fprintf(f:file,fmt:string,args[])} formats and writes arguments
to \texttt{f}.\\
\textsf{sprintf(fmt:string, args[]) : string} formats arguments and
produces a string result.

These procedures support normal \texttt{d}, \texttt{s}, \texttt{o}, and
\texttt{x} formats. An \texttt{{\textquotedbl}r{\textquotedbl}} format
prints real numbers in a manner similar to that of
printf{\textquotesingle}s \texttt{{\textquotedbl}f{\textquotedbl}}, but
will produce a result in an exponential format if the number is larger
than the largest integer plus one. Left or right justification and
field width control are provided as in \texttt{printf()}. \texttt{\%s}
and \texttt{\%r} handle precision specifications. (WHM, CW, PLT)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{prockind}}

\textsf{prockind(p:procedure) : string?} produces a code for the kind of
the procedure p as follows: \texttt{{\textquotedbl}p{\textquotedbl}}
(declared) procedure \texttt{{\textquotedbl}f{\textquotedbl}}
(built-in) function, \texttt{{\textquotedbl}o{\textquotedbl}} operator,
\texttt{{\textquotedbl}c{\textquotedbl}} record
\index{constructor}constructor. It fails if \texttt{p} is not of type
procedure. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procname}}

\textsf{procname(p:procedure, x) : string?} produces the name of a
procedure (including functions, operators, and record
\index{constructor!record}constructors) value. If \texttt{x} is null,
the result is derived from \textsf{image()} in a relatively
straightforward way. In the case of operators, the number of arguments
is appended to the operator symbol. If \texttt{x} is nonnull, the
result is put in a form that resembles an Icon expression.
\textsf{procname()} fails if \texttt{p} is not of type procedure. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pscript}}

\textsf{epsheader(f, x, y, w, h, flags)} writes an Encapsulated
PostScript file header and initializes the PostScript coordinate
system. This file contains a procedure for writing PostScript output
explicitly, as contrasted with the procedures in psrecord.icn that
write PostScript as a side effect of normal graphics calls. An EPS file
can either be incorporated as part of a larger document or sent
directly to a PostScript printer. \textsf{epsheader()} writes the first
portion of the PostScript output to file \texttt{f}. The calling
program then generates the rest. It is the caller{\textquotesingle}s
responsibility to ensure that the rest of the file conforms to the
requirements for EPS files as documented in the PostScript Reference
Manual, second edition. (x,y,w,h) specify the range of coordinates that
are to be used in the generated PostScript code. \textsf{epsheader()}
generates \index{PostScript}PostScript commands that center this region
on the page and clip anything outside it. If the flags string contains
the letter \texttt{{\textquotedbl}r{\textquotedbl}} and \textsf{abs(w)
{\textgreater} abs(h)}, the coordinate system is rotated to place the
region in {\textquotedbl}landscape{\textquotedbl} mode. The generated
header also defines an {\textquotedbl}inch{\textquotedbl} operator that
can be used for absolute measurements as shown in the example below.
\ (GMT) \ Usage example:

\iconcode{
f := open(filename, {\textquotedbl}w{\textquotedbl}) {\textbar}
stop({\textquotedbl}can{\textquotesingle}t open
{\textquotedbl},filename) \\
epsheader(f, x, y, w, h) \\
write(f, {\textquotedbl}.07 inch setlinewidth{\textquotedbl}) \\
write(f,x1, {\textquotedbl} {\textquotedbl}, y1, {\textquotedbl} moveto
{\textquotedbl}, x2, {\textquotedbl} {\textquotedbl}, y2,
{\textquotedbl} lineto stroke{\textquotedbl}) ... write(f,
{\textquotedbl}showpage{\textquotedbl})
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{random}}

This file contains procedures related to pseudo-random numbers.

\texttt{rand\_num() : integer} is a linear congruential pseudo-random
number \index{generator}generator. Each time it is called, it produces
another number in the sequence and also assigns it to the global
variable \texttt{random}. With no arguments, \texttt{rand\_num()}
produces the same sequence(s) as Icon{\textquotesingle}s built-in
random-number \index{generator, random number}generator. Arguments can
be used to get different sequences. The global variable \texttt{random}
serves the same role that \texttt{\&random} does for
Icon{\textquotesingle}s built-in \index{random!number generator}random
number generator.

\texttt{rand\_int(i) : integer} produces a random integer in the range 1
to i.\\
\index{randomize()}randomize() sets \&random to a
{\textquotedbl}random{\textquotedbl} value, based on the date and time
of day. \\
\textsf{randrange(min, max) : integer} produces random number in the
range \textsf{min {\textless}= i {\textless}= max}.\\
\textsf{randrangeseq(i, j) : integer*} generates the integers from
\texttt{i} to \texttt{j} in random order.\\
\texttt{randseq(seed) : integer*} generates the values of \&random,
starting at \texttt{seed},\\
 \ \ \ \ \ that occur as the result of using \texttt{?x}.

\texttt{shuffle(x):x} shuffles the elements of string, list, or record
\texttt{x}. \ If \texttt{x} is a list or record\\
 \ \ \ \ \ it is altered in place, instead of allocating a new structure
to hold the shuffled result.

Links: \texttt{factors}. (REG, GMT)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rational}}

These procedures perform arithmetic on \index{rational numbers}rational
numbers (\index{fractions}fractions):

\texttt{record rational(numer, denom, sign)} is used to represent
rational values.\\
\textsf{str2rat(string):rational?} converts a string such as
\texttt{{\textquotedbl}3/2{\textquotedbl}} to a rational
number.\\
\textsf{rat2str(r:rational):string} converts rational number \texttt{r}
to its string representation.\\
\textsf{addrat(r1:rational,r2:rational) : rational} adds rational
numbers \texttt{r1} and \texttt{r2}.\\
\textsf{subrat(r1:rational,r2:rational) : rational} subtracts rational
numbers \texttt{r1} and \texttt{r2}.\\
\textsf{mpyrat(r1:rational,r2:rational) : rational} multiplies rational
numbers \texttt{r1} and \texttt{r2}.\\
\textsf{divrat(r1:rational,r2:rational) : rational} divides rational
number \texttt{r1} by \texttt{r2}.\\
\textsf{negrat(r) : rational} produces the negative of rational number
\texttt{r}.\\
\textsf{reciprat(r:rational) : rational} produces the reciprocal of
rational number \texttt{r}.

Links: \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{readtbl}}

\texttt{readtbl(f:file) : table} reads \index{SGML}SGML mapping
information from a file. This module is part of the \texttt{strpsgml}
package. The file specifies how each SGML tag in a given input text
should be translated. Each line has the form:

\ \ \ SGML-designator\ \ start\_code\ \ end\_code

where the SGML designator is something like
{\textquotedbl}quote{\textquotedbl} (without the quotation marks), and
the start and end codes are the way in which you want the beginning and
end of a
\texttt{{\textless}quote{\textgreater}...{\textless}/quote{\textgreater}}
sequence to be translated. Presumably, in this instance, your codes
would indicate some set level of indentation, and perhaps a font
change. If you don{\textquotesingle}t have an end code for a particular
SGML designator, just leave it blank.

Links: \texttt{stripunb.} \ (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rec2tab}}

\texttt{rec2tab(x) : null} writes fields of a record as tab-separated
string. Carriage returns in files are converted to vertical tabs.
(Works for lists too.) \ 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{records}}

\texttt{field(R, i) : string?} returns the name of the \texttt{i}th
field of \texttt{R}. Other record processing procedures may be added to
this module in future editions. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{recurmap}}

\texttt{recurmap(recur:list) : string} maps a recurrence declaration of
the form\\
 \ \ \texttt{\ f(i):\\
 \ \ if expr11 then expr12\\
 \ \ if expr21 then expr22\\
}\texttt{ \ \ \ \ \ \ \ \ \ \ ...\\
 \ \ else expr \\
}The declaration is a list of strings. The result string is a
declaration for an Icon procedure that computes corresponding values.
At present there is no error checking and the most naive form of code
is generated. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{reduce}}

\index{reduce()}\texttt{reduce(op, init, args[])} applies the binary
operation \texttt{op} to all the values in \texttt{args}, using
\texttt{init} as the initial value. For example,
\texttt{reduce({\textquotedbl}+{\textquotedbl}, 1, args[])} produces
the sum of the values in args. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{regexp}}

This module implements UNIX-like \index{regular expression}regular
expression patterns. These procedures are interesting partly because of
the {\textquotedbl}recursive suspension{\textquotedbl} (or
{\textquotedbl}suspensive \index{recursion}recursion{\textquotedbl}:)
technique used to simulate conjunction of an arbitrary number of
computed expressions (see notes, below). String scanning function
default conventions are followed. \ (RJA)

\texttt{ReMatch(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} past a substring starting at \texttt{i1} that
matches \texttt{pattern}, but fails if there is no such position.
Similar to \texttt{match()}, but is capable of generating multiple
positions.

\textsf{ReFind(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} where substrings begin that match
\textsf{pattern}, but fails if there is no such position. Similar to
\textsf{find()}. Each position is produced only once, even if several
possible matches are possible at that position. \texttt{pattern} can be
either a string or a pattern list -{}- see \texttt{RePat()}, below.

\texttt{RePat(s) : list?} creates a pattern element list from pattern
string \texttt{s}, but fails if the pattern string is not syntactically
correct. \texttt{ReMatch()} and \texttt{ReFind()} will automatically
convert a pattern string to a pattern list, but it is faster to do the
conversion explicitly if multiple operations are done using the same
pattern. An additional advantage to compiling the pattern separately is
avoiding ambiguity of failure caused by an incorrect pattern and
failure to match a correct pattern.

\textsf{ReCaseIndependent() : null, ReCaseDependent() : null} set the
mode for case-independent or case-dependent matching. The initial mode
is case-dependent.

\paragraph{Accessible Global Variables}
After a match, the strings matched by parenthesized regular expressions
are left in list \texttt{Re\_ParenGroups}, and can be accessed by
subscripting it using the same number as the {\textbackslash}N
construct. If it is desired that regular expression format be similar
to UNIX filename generation patterns but still retain the power of full
regular expressions, make the following assignments prior to compiling
the pattern string:

\iconcode{
\>   Re\_ArbString := {\textquotedbl}*{\textquotedbl} \# Defaults to
{\textquotedbl}.*{\textquotedbl} }

The sets of characters (csets) that define a word, digits, and white
space can be modified. The following assignments can be made before
compiling the pattern string. The character sets are captured when the
pattern is compiled, so changing them after pattern compilation will
not alter the behavior of matches unless the pattern string is
recompiled.

\iconcode{
\>   Re\_WordChars := {\textquotesingle}whatever{\textquotesingle} \#
default: \&letters++\&digits++{\textquotesingle}\_{\textquotesingle} \\
\>   Re\_Digits := \&digits ++
{\textquotesingle}ABCDEFabcdef{\textquotesingle} \# Defaults to
\&digits \\
\>   Re\_Space := {\textquotesingle}whatever{\textquotesingle} \#
Defaults to {\textquotesingle}
{\textbackslash}t{\textbackslash}v{\textbackslash}n{\textbackslash}r{\textbackslash}f{\textquotesingle}
}

These globals are initialized in the first call to \texttt{RePat()} if
they are null. They can be explicitly initialized to their defaults (if
they are null) by calling \texttt{Re\_Default()}.

Characters compiled into patterns can be passed through a user-supplied
filter procedure, provided in global variable \textsf{Re\_Filter}.
Filtering is done as the pattern is compiled, before the characters are
bound into the pattern. The filter is passed one argument, the string
to filter, and it must return the filtered string as its result. If the
filter procedure fails, the string will be used unfiltered. The filter
is called with an argument of either type string (for characters in the
pattern) or cset (for character classes [...]). By default, individual
pattern elements are matched in a {\textquotedbl}leftmost-
longest-first{\textquotedbl} sequence, which is the order observed by
\index{Perl}Perl, e\index{grep}grep, and most other regular expression
matchers. The following global variable setting causes the matcher to
operate in leftmost-shortest- first order.

\iconcode{
\>   Re\_LeftmostShortest := 1}

In the case of patterns containing alternation, \texttt{ReFind()} will
generally not produce positions in increasing order, but will produce
all positions from the first term of the alternation (in increasing
order) followed by all positions from the second (in increasing order).
If it is necessary that the positions be generated in strictly
increasing order, with no duplicates, assign a non-null value to
\texttt{Re\_Ordered}:

\iconcode{
\>   Re\_Ordered := 1}

The \texttt{Re\_Ordered} option imposes a small performance penalty in
some cases, and the co-expression facility is required in your Icon
implementation.

\paragraph{Regular Expression Characters and Features Supported}
The regular expression format supported by procedures in this file model
very closely those supported by the UNIX
{\textquotedbl}egrep{\textquotedbl} program, with modifications as
described in the Perl programming language definition. Following is a
brief description of the special characters used in regular
expressions. The abbreviation RE means regular expression.

\texttt{c} An ordinary character (not one of the special characters
discussed below) is a one-character RE that matches that character.

\texttt{{\textbackslash}c} A backslash followed by any special character
is a one-character RE that matches the special character itself. Note
that backslash escape sequences representing non-graphic characters are
not supported directly by these procedures. Of course, strings coded in
an Icon program will have such escapes handled by the Icon translator.
If such escapes must be supported in strings read from the run-time
environment (e.g. files), they will have to be converted by other
means, such as the Icon Program Library procedure \texttt{escape()}.

\texttt{.} A period is a one-character RE that matches any character.

\texttt{[string]} A non-empty string enclosed in square brackets is a
one-character RE that matches any one character in that string. If the
first character is \texttt{{\textquotedbl}\^{}{\textquotedbl}}
(circumflex), the RE matches any character not in the remaining
characters of the string. The \texttt{{\textquotedbl}-{\textquotedbl}}
(minus), when between two other characters, may be used to indicate a
range of consecutive \index{ASCII}ASCII characters (e.g. \texttt{[0-9]}
is equivalent to \texttt{[0123456789]}). Other special characters stand
for themselves in a bracketed string.

\texttt{*} Matches zero or more occurrences of the RE to its
left.\\
\texttt{+} Matches one or more occurrences of the RE to its
left.\\
\texttt{?} Matches zero or one occurrences of the RE to its
left.\\
\texttt{\{N\}} Matches exactly \texttt{N} occurrences of the RE to its
left.\\
\texttt{\{N,\}} Matches at least \texttt{N} occurrences of the RE to its
left.\\
\texttt{\{N,M\}} Matches at least \texttt{N} occurrences but at most
\texttt{M} occurrences of the RE to its left.\\
\texttt{\^{}} A caret at the beginning of an entire RE constrains that
RE to match an initial substring\\
 \ \ \ \ of the subject string.\\
\texttt{\$} A currency symbol at the end of an entire RE constrains that
RE to match a final\\
 \ \ \ \ substring of the subject string.\\
\texttt{{\textbar}} \index{alternation operator ( {\textbar}
)}Alternation: two regular expressions separated by
\texttt{{\textquotedbl}{\textbar}{\textquotedbl}} match either a match
for the\\
 \ \ \ \ first or a match for the second.\\
\texttt{()} A RE enclosed in parentheses matches a match for the regular
expression\\
 \ \ \ \ (parenthesized groups are used for grouping, and for accessing
the matched string\\
 \ \ \ \ subsequently in the match using the {\textbackslash}N
expression).\\
\texttt{{\textbackslash}N} where \texttt{N} is a digit in the range 1-9,
matches the same string of characters as was\\
 \ \ \ \ matched by a parenthesized RE to the left in the same RE. The
sub-expression\\
 \ \ \ \ specified is that beginning with the \texttt{N}th occurrence of
\texttt{{\textquotedbl}({\textquotedbl}} counting from the
left.\\
 \ \ \ \ e.g., \^{}(.*){\textbackslash}1. matches a string consisting of
two consecutive occurrences of the same\\
 \ \ \ \ string.

\paragraph{Extensions beyond UNIX egrep}
The following extensions to UNIX regular expressions, as specified in
the Perl programming language, are supported.

\texttt{{\textbackslash}w} matches any alphanumeric (including
\texttt{{\textquotedbl}\_{\textquotedbl}}).\\
\texttt{{\textbackslash}W} Matches any non-alphanumeric.\\
\texttt{{\textbackslash}b} matches only at a word-boundary (a word \ is
a string of alphanumerics, as in \texttt{{\textbackslash}w}).\\
\texttt{{\textbackslash}B} matches only non-word-boundaries.\\
\texttt{{\textbackslash}s} matches any white-space character.\\
\texttt{{\textbackslash}S} matches any non-white-space
character.\\
\texttt{{\textbackslash}d} matches any digit \texttt{[0-9]}.\\
\texttt{{\textbackslash}D} matches any non-digit.\\
\texttt{{\textbackslash}w}, \texttt{{\textbackslash}W},
\texttt{{\textbackslash}s}, \texttt{{\textbackslash}S},
\texttt{{\textbackslash}d}, \texttt{{\textbackslash}D} can be used
within \texttt{[string]} regular expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{repetit}}

\texttt{repetit(L:list) : integer} returns the length of the smallest
range of values that repeat in a list. For example, if L := [1, 2, 3,
1, 2, 3, 1, 2, 3] , \textsf{repetit(L)} returns \texttt{3}. If there is
no repetition, \textsf{repetit()} returns the length of the list. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{re\index{wrap}wrap}}

\textsf{rewrap(s:string,i:70) : string?} reformats text fed to it into
strings \textsf{{\textless}i} in length. \textsf{rewrap()} utilizes a
static buffer, so it can be called repeatedly with different string
arguments, and still produce homogeneous output. This buffer is flushed
by calling \texttt{rewrap()} with a null first argument.
Here{\textquotesingle}s a simple example of how \texttt{rewrap()} could
be used. The following program reads the standard input, producing
fully rewrapped output.

\iconcode{
procedure main() \\
\>   every write(rewrap(!\&input)) \\
\>   write(rewrap()) \\
end
}

Naturally, in practice you would want to do things like check for
indentation or blank lines in order to wrap only on a paragraph by
paragraph basis, as in

\iconcode{
procedure main() \\
\>   while line := read(\&input) do \{ \\
\>   \ \ \ if line == {\textquotedbl}{\textquotedbl} then \{ \\
\>   \ \ \ \ \ \ write({\textquotedbl}{\textquotedbl} \~{}==rewrap()) \\
\>   \ \ \ \ \ \ write(line) \\
\>   \ \ \ \ \ \ \} \\
\>   \ \ \ else \{ \\
\>   \ \ \ \ \ \ if
match({\textquotedbl}{\textbackslash}t{\textquotedbl}, line) then \{ \\
\>   \ \ \ \ \ \ \ \ \ write(rewrap()) \\
\>   \ \ \ \ \ \ \ \ \ write(rewrap(line)) \\
\>   \ \ \ \ \ \ \ \ \ \} \\
\>   \ \ \ \ \ \ else \\
\>   \ \ \ \ \ \ \ \ \ write(rewrap(line)) \\
\>   \ \ \ \ \ \ \} \\
\>   \ \ \ \} \\
end
}

Fill-prefixes can be implemented simply by prepending them to the output
of rewrap:

\iconcode{
i := 70; fill\_prefix := {\textquotedbl} {\textgreater} {\textquotedbl}}

\iconcode{
while line := read(input\_file) do \{ \\
\>   line ?:= (f\_bit := tab(many({\textquotesingle}{\textgreater}
{\textquotesingle})) {\textbar} {\textquotedbl}{\textquotedbl},
tab(0)) \\
\>   write(fill\_prefix {\textbar}{\textbar} f\_bit
{\textbar}{\textbar} rewrap(line, i - *fill\_prefix)) \\
\>   etc.
}

Obviously, these examples are fairly simplistic. Putting them to actual
use would certainly require a few environment-specific modifications
and/or extensions. Still, they offer some indication of the kinds of
applications \texttt{rewrap()} might be used in. Note: If you want
leading and trailing tabs removed, map them to spaces first.
\texttt{rewrap()} only fools with spaces, leaving tabs intact. This can
be changed easily enough, by running its input through the Icon
\texttt{detab()} function.

See also: \texttt{wrap.icn}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scan}}

This module contains procedures related to \index{string!scanning}string
scanning: Where indicated by parameter names, they follow the string
scanning conventions for parameter defaults.

\textsf{balq(c1,c2,c3,c4:{\textquotesingle}{\textbackslash}{\textquotesingle}{\textquotedbl}{\textquotesingle},c5:{\textquotesingle}{\textbackslash}{\textquotesingle},s,i1,i2):integer*}
generates integer positions in \texttt{s} preceding a character of
\texttt{c1} in \texttt{s[i1:i2]} that are (a) balanced with respect to
characters in \texttt{c2} and \texttt{c3} and (b) not
{\textquotedbl}quoted{\textquotedbl} by characters in \texttt{c4} with
{\textquotedbl}escape{\textquotedbl} sequences as defined in
\texttt{c5}.

\texttt{balqc(c1,c2,c3,c4:{\textquotesingle}{\textbackslash}{\textquotesingle}{\textquotedbl}{\textquotesingle},c5,s1:{\textquotedbl}/*{\textquotedbl},s2:{\textquotedbl}*/{\textquotedbl},s3,i1,i2):integer*}
is like \texttt{balq()} with the addition that balanced characters
within {\textquotedbl}comments{\textquotedbl}, as delimited by the
strings \texttt{s1} and \texttt{s2}, are also excluded from balancing.
In addition, if \texttt{s1} is given and \texttt{s2} is null then the
\index{comment}comment terminates at the end of string.

\texttt{limatch(L:list, c:cset) : integer?} matches items in L delimited
by characters in c. Returns the last cursor position scanned to, or
fails 

\texttt{slashbal(c1,c2,c3,s,i,j) : integer*} behaves like
\texttt{bal()}, except that it ignores, for purposes of balancing, any
\texttt{c2} or \texttt{c3} char which is preceded by a backslash.

\textsf{slashupto(c, s, i, j) : integer?} works just like
\texttt{upto()}, except that it ignores backslash escaped characters.

\texttt{snapshot(title:string, len:integer)} writes a snapshot of the
state of string scanning, showing the value of \texttt{\&subject} and
\texttt{\&pos} Two optional arguments specify a title written at the
top of the snapshot, and a width (in characters) at which to wrap
output. For example,

\iconcode{
{\textquotedbl}((a+b)-delta)/(c*d)){\textquotedbl} ?
\{tab(bal({\textquotesingle}+-/*{\textquotesingle}));
snapshot({\textquotedbl}example{\textquotedbl})\}}

produces

\iconcode{
{}-{}-{}-example-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}}

{\ttfamily
{\textbar}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}}

{\ttfamily
{\textbar} \&subject =
{\textquotedbl}((a+b)-delta)/(c*d)){\textquotedbl} {\textbar}}

{\ttfamily
{\textbar} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}
\ \ \ \ \ \ \ {\textbar}}

{\ttfamily
{\textbar}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}}

\iconcode{
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

Note that the bar showing \textsf{\&pos} is positioned under the
\textsf{\&pos{\textquotesingle}}th character (actual positions are
between characters). If \textsf{\&pos} is at the end of
\textsf{\&subject}, the bar is positioned under the quotation mark
delimiting the subject. Escape sequences are handled properly. 

(RLG, DAG, REG, RLS, CW)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scanset}}

\textsf{scan\_setup(s, i1, i2) : scan\_setup\_result?} sets things up
for user-written string-scanning procedures that are in the spirit of
Icon{\textquotesingle}s built-ins. The values passed are the last three
arguments to all Icon scanning functions (such as
\textsf{upto(c,s,i1,i2)}). \textsf{scan\_setup()} supplies any
appropriate defaults and returns needed values. The value returned is a

\iconcode{
record scan\_setup\_result(ss, offset)
}

where \texttt{ss} is the substring of \texttt{s} to be scanned, and
offset is the size of the substring of \texttt{s} that precedes the
substring to be scanned. \texttt{scan\_setup()} fails if \texttt{i1} or
\texttt{i2} is out of range with respect to \texttt{s}. The
user-written procedure can then match in the string \texttt{ss} to
compute the position within \texttt{ss} appropriate to the scan
(\texttt{p}). The value returned (or suspended) to the caller is
\texttt{p + offset} (the position within the original string,
\texttt{s}). For example, the following function finds two words
separated by spaces:

\iconcode{
procedure two\_words(s,i1,i2) \\
\>   local x,p \\
\>   x := scan\_setup(s,i1,i2) {\textbar} fail \# fail if out of range \\
\>   x.ss ? suspend \{ \\
\>   \ \ \ tab(upto(\&letters)) \& \\
\>   \ \ \ pos(1) {\textbar} (move(-1) \& tab(any(\~{}\&letters))) \& \\
\>   \ \ \ p := \&pos \& \# remember starting position \\
\>   \ \ \ tab(many(\&letters)) \& tab(many({\textquotesingle}
{\textquotesingle})) \& \\
\>   \ \ \ tab(many(\&letters)) \& \\
\>   \ \ \ p + x.offset \# return position in original s \\
\>   \ \ \ \} \\
end
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{segment}}

These procedures segment a string \texttt{s} into consecutive substrings
consisting of characters that respectively do/do not occur in
\texttt{c}. (WHM)

\index{segment(s,c)}\textsf{segment(s,c)}\textsf{ : string*} generates
the substrings, while \textsf{seglist(s,c) : list} produces a list of
the segments. For example, \textsf{segment({\textquotedbl}Not a
sentence.{\textquotedbl},\&letters)} generates six string results:
{\textquotedbl}Not{\textquotedbl} {\textquotedbl} {\textquotedbl}
{\textquotedbl}a{\textquotedbl} {\textquotedbl} {\textquotedbl}
{\textquotedbl}sentence{\textquotedbl} {\textquotedbl}.{\textquotedbl}
while \textsf{seglist({\textquotedbl}Not a
sentence.{\textquotedbl},\&letters)} produces a list of size six:
[{\textquotedbl}Not{\textquotedbl},{\textquotedbl}
{\textquotedbl},{\textquotedbl}a{\textquotedbl},{\textquotedbl}sentence{\textquotedbl},{\textquotedbl}.{\textquotedbl}]


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sentence, senten1}}

Two alternative modules provide a function \texttt{sentence(f) :string*}
that \index{generate sentences}generates sentences from file
\texttt{f}. A lot of grammatical and stylistic analysis programs are
predicated on the notion of a sentence. For instance, some programs
count the number of words in each sentence. Others count the number and
length of clauses. Still others pedantically check for sentence-final
particles and prepositions. Neither module{\textquotesingle}s
definition of a sentence will handle all possible inputs properly; you
may wish to try both of them to see which one works better on your
inputs.

Module \texttt{sentence} requires co-expressions, while module
\texttt{senten1} does not. Module \texttt{senten1} uses a definition of
a {\textquotedbl}sentence{\textquotedbl} that is detailed in the module
source code. (RLG, PAB)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{seqimage}}

\textsf{Seqimage\{e,i,j\}: string} produces a string image of the result
sequence for the expression \texttt{e}.  The first \texttt{i}
results are printed. If \texttt{i} is omitted, there is no limit. If
there are more than \texttt{i} results for \texttt{e}, ellipses are
provided in the image after the first \texttt{i}. If \texttt{j} is
specified, at most \texttt{j} results from the end of the sequence are
printed after the ellipses. If \texttt{j} is omitted, only the first
\texttt{i} results are produced. For example, the expressions 

\iconcode{
\>   Seqimage\{1 to 12\} \\
\>   Seqimage\{1 to 12,10\}  \\
\>   Seqimage\{1 to 12,6,3\}
}

produce, respectively, 

\iconcode{
\>   \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\} \\
\>   \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...\} \\
\>   \{1, 2, 3, 4, 5, 6, ..., 10, 11, 12\}
}

If \texttt{j} is not omitted and \texttt{e} has an infinite result
sequence, \textsf{Seqimage\{\}} does not terminate.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sername}}

\textsf{sername(p:{\textquotedbl}file{\textquotedbl},
s:{\textquotedbl}{\textquotedbl}, n:3, i:0) : string} produces a series
of names of the form p{\textless}nnn{\textgreater}s. If \texttt{n} is
given it determines the number of digits in
{\textless}nnn{\textgreater}. If \texttt{i} is given it resets the
sequence to start with \texttt{i}. {\textless}nnn{\textgreater} is a
right-adjusted integer padded with zeros. Ordinarily, the arguments
only are given on the first call. Subsequent calls without arguments
give the next name. For example,
\textsf{sername({\textquotedbl}image{\textquotedbl},
{\textquotedbl}.gif{\textquotedbl}, 3, 0)} produces
\textsf{{\textquotedbl}image000.gif{\textquotedbl}}, and subsequently,
\textsf{sername()} produces
\textsf{{\textquotedbl}image001.gif{\textquotedbl}},
\textsf{{\textquotedbl}image002.gif{\textquotedbl}}, and so on. If any
argument changes on subsequent calls, all non-null arguments are reset.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sets}}

\texttt{cset2set(c:cset): set} returns a set that contains the
individual characters in \texttt{c}.\\
\texttt{domain(T:table)} returns the domain (set of keys) of the
function defined by \texttt{T}.

\texttt{inverse(T:table, x) : table} returns the inverse of the function
defined by \texttt{T}.\\
 \ \ \ \ \ If \texttt{x} is null, it{\textquotesingle}s the functional
inverse. If \texttt{x} is an empty list, it{\textquotesingle}s the
relational inverse.\\
 \ \ \ \ \ If \texttt{x} is an empty set, it the relational inverse, but
with each table member as a set\\
 \ \ \ \ \ instead of a list.

\texttt{pairset(T:table) : set} converts \texttt{T} to an equivalent set
of ordered pairs.

\texttt{range(T:table):set} returns the range (set of values) of the
function defined by \texttt{T}.\\
\texttt{seteq(S1, S2) : set?} tests \index{equivalence!set}equivalence
of sets \texttt{S1} and \texttt{S2}.

\texttt{setlt(S1, S2) : set?} tests inclusion (strict subset) of set
\texttt{S1} in \texttt{S2}. 

(AB, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{showtbl}}

\textsf{showtbl(title:{\textquotedbl}{\textquotedbl}, T, mode, limit,
order, posit, w1:10, w2:10, gutter:3, f1:left, f2:right)} displays
table T according to the arguments given. The remaining arguments are:

\texttt{mode} indicates the type of sorting, one of:
\texttt{{\textquotedbl}ref{\textquotedbl}{\textbar}{\textquotedbl}val{\textquotedbl}}
(by key or decreasing value)\\
\texttt{limit} specifies the maximum lines of table output, if
any\\
\texttt{order} gives the sort order, one of:
\texttt{{\textquotedbl}incr{\textquotedbl}{\textbar}{\textquotedbl}decr{\textquotedbl}}
(not implemented yet)\\
\texttt{posit} is the first column position, one of:
\texttt{{\textquotedbl}ref{\textquotedbl}{\textbar}{\textquotedbl}val{\textquotedbl}}
(not implemented yet)\\
\texttt{w1} is the width of 1\textsuperscript{st} column\\
\texttt{w2} is the width of 2\textsuperscript{nd} column\\
\texttt{gutter} is the width between columns\\
\texttt{f1} supplies the formatting function used on the 1st
column\\
\texttt{f2} supplies the formatting function used on the 2nd column

\texttt{showtbl()} returns a record with the first element being a count
of the size of the table and the second element the number of lines
written. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shquote}}

This module is useful for writing Icon programs that generate
\index{shell commands}shell commands. Certain characters cannot appear
in the open in strings that are to be interpreted as
{\textquotedbl}words{\textquotedbl} by command shells. This family of
procedures assists in quoting such strings so that they will be
interpreted as single words. Quoting characters are applied only if
necessary -{}- if strings need no quoting they are returned unchanged.
(RJA)

\texttt{shquote(s1, s2,..., sN) : string} \ produces a string of words
\texttt{s1, s2, ..., sN} that are properly separated and quoted for the
Bourne Shell (sh).

\texttt{cshquote(s1, s2,..., sN) : string} produces a string of words
\texttt{s1, s2,..., sN} that are properly separated and quoted for the
C-Shell (csh).

\texttt{mpwquote(s1, s2,..., sN) : string} produces a string of words
\texttt{s1, s2,..., sN} that are properly separated and quoted for the
Macintosh Programmer{\textquotesingle}s Workshop shell (MPW Shell).

\texttt{dequote(s1,s2:{\textquotedbl}{\textbackslash}{\textbackslash}{\textquotedbl})
: string} produces the UNIX-style command line word \texttt{s1} with
any quoting characters removed. \texttt{s2} is the escape character
required by the shell.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{signed}}

\textsf{signed(s) : integer} puts raw bits of characters of string
\texttt{s} into an integer. The value is taken as signed. This
procedure is normally used for processing of binary data read from a
file. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sort}}

\index{sort}\textsf{sort}\textsf{ff(L, fields[])} is like
\textsf{sortf()}, except it takes an unlimited number of \index{sort by
field}field arguments. \textsf{sortgen(T, m) : any*} generates sorted
output in a manner specified by \texttt{m}:

\texttt{{\textquotedbl}k+{\textquotedbl}} sort by key in ascending
order\\
\texttt{{\textquotedbl}k-{\textquotedbl}} sort by key in descending
order\\
\texttt{{\textquotedbl}v+{\textquotedbl}} sort by value in ascending
order\\
\texttt{{\textquotedbl}v-{\textquotedbl}} sort by value in descending
order

\index{sortt}\texttt{sortt}\texttt{(T, i)} is like \texttt{sort(T, i)}
but produces a list of two-element records instead of a list of
two-element lists. (RJA,RLG,REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{\index{soundex}soundex, soundex1}}

\texttt{soundex(name:string) : string} produces a code for a name that
tends to bring together variant spellings. See Donald E. Knuth, The Art
of Computer Programming, Vol.3; Searching and Sorting, pp. 391-392.
(CW)

Module \texttt{soundex1} employs an approach proposed by Margaret K.
Odell and Robert C. Russell; see the source code for details. (JDS)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{statemap}}

\texttt{statemap() : table} produces a
{\textquotedbl}two-way{\textquotedbl} table to map \index{state names,
U.S.}state names (in the postal sense) to their postal abbreviations
and vice-versa. The list is done in two parts with auxiliary procedures
so that this procedure can be used with the default constant-table size
for the translator and linker. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{str2toks}}

String scanning procedure \texttt{str2toks(c:\~{}(\&letters++\&digits),
s, i1, i2) : string*} suspends portions of \texttt{s[i1:i2]} delimited
by characters in \texttt{c}. \texttt{str2toks()} is not a primitive
scanning function in the sense that it suspends strings, and not
integer positions. The code:

\iconcode{
\>   {\textquotedbl}hello, how are ya?{\textquotedbl} ? every
write(str2toks()) }

writes to \texttt{\&output}, on successive lines, the words
\texttt{{\textquotedbl}hello{\textquotedbl}},
\texttt{{\textquotedbl}how{\textquotedbl}},
\texttt{{\textquotedbl}are{\textquotedbl}}, and finally
\texttt{{\textquotedbl}ya{\textquotedbl}} (skipping the punctuation).
Naturally, the beginning and end of the line count as delimiters. Note
that if \texttt{i {\textgreater} 1} or \texttt{j {\textless} *s+1} some
tokens may end up appearing truncated. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{strings}}

These procedures perform operations on \index{string}strings. 

\textsf{cat(s1, s2,...) : string} concatenates an arbitrary number of
strings.\\
\textsf{charcnt(s, c) : integer} returns the number of instances of
characters in c in s.

\textsf{collate(s1, s2) : string} \index{collate}collates the characters
of s1 and s2. For example,\\
 \ \ \ \ \ \textsf{collate({\textquotedbl}abc{\textquotedbl},
{\textquotedbl}def{\textquotedbl})} produces
\textsf{{\textquotedbl}adbecf{\textquotedbl}}.

\textsf{comb(s, i) : string*} generates the \index{combinations,
string}combinations of characters from s taken i at a time.\\
\textsf{compress(s, c:\&cset) : string} compresses consecutive
occurrences of members of c in s.

\texttt{csort(s) : string} produces the characters of \texttt{s} in
lexical order.\\
\texttt{decollate(s, i:1) : string} produces a string consisting of
every other\\
 \ \ \ \ \ character of \texttt{s}. If \texttt{i} is odd, the
odd-numbered characters are selected, while if \texttt{i} is\\
 \ \ \ \ \ even, the even-numbered characters are selected.

\texttt{deletec(s, c) : string} deletes occurrences of characters in
\texttt{c} from \texttt{s}.\\
\texttt{deletep(s, L) : string} deletes all characters at positions
specified in \texttt{L}.\\
\texttt{deletes(s1, s2) : string} deletes occurrences of \texttt{s2} in
\texttt{s1}.\\
\texttt{diffcnt(s) : integer} returns count of the number of different
characters in \texttt{s}.\\
\texttt{extend(s, n) : string} replicates \texttt{s} to length
\texttt{n}.\\
\textsf{interleave(s1, s2) : string} interleaves characters \textsf{s2}
extended to the length of \texttt{s1} with \texttt{s1}.\\
\texttt{ispal(s) : string?} succeeds and returns \texttt{s} if
\texttt{s} is a palindrome

\texttt{maxlen(L, p:proc({\textquotedbl}*{\textquotedbl},1)) : integer}
returns the length of the longest\\
 \ \ \ \ \ string in \texttt{L}. \texttt{p} is applied to each string as
a {\textquotedbl}length{\textquotedbl} procedure.

\texttt{meander(s, n) : string} produces a
{\textquotedbl}meandering{\textquotedbl} string that contains
all\\
 \ \ \ \ \ n-tuples of characters of \texttt{s}.\\
\texttt{minlen(L, p: proc({\textquotedbl}*{\textquotedbl}, 1)) :
integer} returns the length of the shortest\\
 \ \ \ \ \ string in \texttt{L}. \texttt{p} is applied to each string as
a {\textquotedbl}length{\textquotedbl} procedure.

\textsf{ochars(s) : string} produces unique characters in the order that
they first appear in \texttt{s}.\\
\textsf{palins(s, n) : string*} generates all the \texttt{n}{}-character
\index{palindrome}palindromes from the characters in
\texttt{s}.\\
\texttt{permute(s) : string*} generates all the permutations of the
string \texttt{s}.\\
\texttt{pretrim(s, c:{\textquotesingle} {\textquotesingle}) : string}
trims characters from beginning of \texttt{s}.\\
\texttt{reflect(s1, i, s2:{\textquotedbl}{\textquotedbl}) : string}
returns \texttt{s1} concatenated with \texttt{s2} and the\\
 \ \ \ \ \ reversal of \texttt{s1} to produce a partial palindrome. The
values of \texttt{i} determine {\textquotedbl}end\\
 \ \ \ \ \ conditions{\textquotedbl} for the reversal: 0 = omit first
and last characters,\\
 \ \ \ \ \ 1 = omit first character, 2 = omit last character, 3 =
don{\textquotesingle}t omit character.

\texttt{replace(s1, s2, s3) : string} replaces all occurrences of
\texttt{s2} in \texttt{s1} by \texttt{s3}.\\
\texttt{replacem(s,...) : string} performs multiple \index{replacement,
string}replacements in the style of \texttt{replace()}, where multiple
argument pairs may be given, as in\\
 \ \ \ \ \ \texttt{replacem(s, {\textquotedbl}a{\textquotedbl},
{\textquotedbl}bc{\textquotedbl}, {\textquotedbl}d{\textquotedbl},
{\textquotedbl}cd{\textquotedbl})} which replaced all
a{\textquotesingle}s by
\texttt{{\textquotedbl}bc{\textquotedbl}\\
} \ \ \ \ \ and all d{\textquotesingle}s by
\texttt{{\textquotedbl}cd{\textquotedbl}}. Replacements are performed
one after another, not in parallel.

\textsf{replc(s, L) : string} replicates each character of \texttt{s} by
the amount given by the values in \texttt{L}.\\
\textsf{rotate(s, i:1) : string} rotates \texttt{s} by \texttt{i}
characters to the left (negative \texttt{i} rotates to the
right).\\
\texttt{schars(s) : string} produces the unique characters of \texttt{s}
in lexical order.\\
\texttt{scramble(s) : string} scrambles (shuffles) the characters of
\texttt{s} randomly.\\
\texttt{selectp(s, L) : string} selects characters of \texttt{s} that
are at positions given in \texttt{L}.\\
\textsf{transpose(s1, s2, s3) : string} transposes \texttt{s1} according
to label \texttt{s2} and transposition \texttt{s3}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{stripcom}}

\texttt{stripcom(s) : string?} strips the commented-out portion of a
line of Icon code. Fails on lines which, either stripped or otherwise,
come out as an empty string. \texttt{stripcom()} can{\textquotesingle}t
handle lines ending in an underscore as part of a broken string
literal, since \texttt{stripcom()} is not intended to be used on
sequentially read files. It simply removes \index{comment}comments from
individual lines. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{stripunb}}

\texttt{stripunb(c1,c2,s,i,j,t:table) : string} strips material from a
line which is unbalanced with respect to the characters defined in
arguments 1 and 2 (unbalanced being defined as \texttt{bal()} defines
it, except that characters preceded by a backslash are counted as
regular characters, and are not taken into account by the balancing
algorithm). If you call \texttt{stripunb()} with a table argument as
follows,
\texttt{stripunb({\textquotesingle}{\textless}{\textquotesingle},{\textquotesingle}{\textgreater}{\textquotesingle},s,\&null,\&null,t)}
and if \texttt{t} is a table having the form

\iconcode{
key: {\textquotedbl}bold{\textquotedbl} value:
outstr({\textquotedbl}{\textbackslash}e[2m{\textquotedbl},
{\textquotedbl}{\textbackslash}e1m{\textquotedbl})}

\iconcode{
key: {\textquotedbl}underline{\textquotedbl} value:
outstr({\textquotedbl}{\textbackslash}e[4m{\textquotedbl},
{\textquotedbl}{\textbackslash}e1m{\textquotedbl}) etc.}

then every instance of
\texttt{{\textquotedbl}{\textless}bold{\textgreater}{\textquotedbl}} in
string s will be mapped to
\texttt{{\textquotedbl}{\textbackslash}e2m,{\textquotedbl}} and every
instance of
\texttt{{\textquotedbl}{\textless}/bold{\textgreater}{\textquotedbl}}
will be mapped to
\texttt{{\textquotedbl}{\textbackslash}e[1m.{\textquotedbl}} Values in
table t must be records of type \texttt{outstr(on, off)}. When
\texttt{{\textquotedbl}{\textless}/{\textgreater}{\textquotedbl}} is
encountered, \texttt{stripunb()} will output the \texttt{.off} value
for the preceding \texttt{.on} string encountered.

Links: \texttt{scan}. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tab2list, tab2rec}}

\texttt{tab2list(string):list} takes tab-separated strings and inserts
them into a list.\\
 \ \ \ \ \ Vertical tabs in strings are converted to carriage returns.

\texttt{tab2rec(s, x) : null} takes tab-separated strings and assigns
them into fields of\\
 \ \ \ \ \ a record or list \texttt{x}. Vertical tabs in strings are
converted to carriage returns.

See also: list2tab.icn, rec2tab.icn. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tables}}

\texttt{keylist(T) : list} produces a list of keys in table
\texttt{T}.\\
\texttt{kvallist(T) : list} produces values in \texttt{T} ordered by
sorted order of keys.\\
\texttt{tbleq(T1, T2) : table?} tests the equivalence of tables
\texttt{T1 and T2}.\\
\texttt{tblunion(T1, T2) : table} approximates \texttt{T1 ++
T2}.\\
\texttt{tblinter(T1, T2) : table} approximates \texttt{T1 **
T2}.\\
\texttt{tbldiff(T1, T2) : table} approximates \texttt{T1 -{}-
T2}.\\
\texttt{tblinvrt(T) : table} produces a table with the keys and values
of \texttt{T} swapped.\\
\texttt{tbldflt(T) : any} produces the default value for
\texttt{T}.\\
\texttt{twt(T) : table} produces a \index{two-way table}two-way table
based on \texttt{T}.\\
\texttt{vallist(T) : list} produces list of values in table \texttt{T}.

For the operations on tables that mimic set operations, the
correspondences are only approximate and do not have the mathematical
properties of the corresponding operations on sets. For example, table
{\textquotedbl}union{\textquotedbl} is not symmetric or transitive.
Where there is potential asymmetry, the procedures
{\textquotedbl}favor{\textquotedbl} their first argument. The
procedures that return tables return new tables and do not modify their
arguments. (REG, AB)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tclass}}

\textsf{tclass(x) : string} returns {\textquotedbl}atomic{\textquotedbl}
or {\textquotedbl}composite{\textquotedbl} depending on the type of
\texttt{x}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{title, titleset}}

\texttt{title(name:string) : string} produces the title of a name, such
as {\textquotedbl}Mr.{\textquotedbl} from\\
 \ \ \ \ \ {\textquotedbl}Mr. John Doe{\textquotedbl}. The process is
imperfect. Links \texttt{titleset}.

\texttt{titleset() : set} produces a set of strings that commonly appear
as titles in\\
 \ \ \ \ \ names. This set is (necessarily) incomplete. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{trees}}

\texttt{depth(t) : integer} compute maximum depth of \index{tree}tree
\texttt{t}\\
\texttt{ldag(s) : list} construct a \index{DAG}DAG from the string
\texttt{s}\\
\texttt{ltree(s) : list} construct a tree from the string
\texttt{s}\\
\texttt{stree(t) : string} construct a string from the tree
\texttt{t}\\
\texttt{tcopy(t) : list} deep copy tree \texttt{t}.\\
\texttt{teq(t1,t2) : list?} compare trees \texttt{t1} and
\texttt{t2}\\
\texttt{visit(t) : any*} visit, in preorder, the nodes of the tree
\texttt{t} by suspending them all 

This module provides tree operations that use a list representation of
trees and directed acyclic graphs (DAGs). These procedures do not
protect themselves from cycles. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tuple}}

\texttt{tuple(tl:list) : list} implements a
{\textquotedbl}tuple{\textquotedbl} feature that produces the effect of
multiple keys. A tuple is created by an expression of the form
\texttt{tuple([exrp1, expr2,..., exprn])}. The result can be used in a
\index{case expression}case expression or as a table subscript. Lookup
is successful provided the values of expr1, expr2,..., exprn are the
same (even if the lists containing them are not). For example, consider
selecting an operation based on the types of two operands. The
following expression uses \texttt{tuple()} to drive a case expression
using value pairs. (WHM)

\iconcode{
case tuple([type(op1), type(op2)]) of \{ \\
\>   tuple([{\textquotedbl}integer{\textquotedbl},
{\textquotedbl}integer{\textquotedbl}]): op1 + op2 \\
\>   tuple([{\textquotedbl}string{\textquotedbl},
{\textquotedbl}integer{\textquotedbl}]) : op1 {\textbar}{\textbar}
{\textquotedbl}+{\textquotedbl} {\textbar}{\textbar} op2 \\
\>   tuple([{\textquotedbl}integer{\textquotedbl},
{\textquotedbl}string{\textquotedbl}]) : op1 {\textbar}{\textbar}
{\textquotedbl}+{\textquotedbl} {\textbar}{\textbar} op2 \\
\>   tuple([{\textquotedbl}string{\textquotedbl},
{\textquotedbl}string{\textquotedbl}]) : op1 {\textbar}{\textbar}
{\textquotedbl}+{\textquotedbl} {\textbar}{\textbar} op2 \\
\>   \}
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{typecode}}

\texttt{typecode(x) : string} produces a one-letter string identifying
the type of its argument. In most cases, the code is the first
(lowercase) letter of the type, as in
\texttt{{\textquotedbl}i{\textquotedbl}} for the integer type.
Structure types are in uppercase, as in
\texttt{{\textquotedbl}L{\textquotedbl}} for the list type. All records
have the code \texttt{{\textquotedbl}R{\textquotedbl}}. The code
\texttt{{\textquotedbl}C{\textquotedbl}} is used for the co-expression
type to avoid conflict for the \texttt{{\textquotedbl}c{\textquotedbl}}
for the cset type. The code \texttt{{\textquotedbl}w{\textquotedbl}} is
produced for windows. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unsigned}}

\texttt{unsigned(s) : integer} puts raw bits of characters of string
\texttt{s} into an integer. The value is taken as unsigned. This
procedure is normally used for processing of binary data read from a
file. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{usage}}

These procedures provide various common services: 

\index{Usage(s)}\texttt{Usage(s)} stops execution with a message
indicating the expected usage of a program.\\
\texttt{Error(args?)} writes arguments to \texttt{\&errout} on a single
line, preceded by \texttt{{\textquotedbl}*** {\textquotedbl}}.\\
\textsf{ErrorCheck(l,f) : null} reports to \texttt{\&output} an error
that has been converted to failure.\\
\index{Feature(s)}\texttt{Feature(s)}\texttt{ : ?} \ succeeds if feature
\texttt{s} is available in this implementation.\\
\texttt{Requires(s)} terminates execution is feature \texttt{s} is not
available.\\
\texttt{Signature()} writes the version, host, and features support in
the running\\
 \ \ \ \ \ implementation of Icon. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{varsub}}

\texttt{varsub(s, varProc:getenv)} obtains a variable value from the
procedure, \texttt{varProc}. As with the UNIX Bourne shell and C shell,
variable names are preceded by \$. Optionally, the variable name can
additionally be surrounded by curly braces \{\}, which is usually done
when necessary to isolate the variable name from surrounding text. As
with the C-shell, the special symbol
\texttt{\~{}{\textless}username{\textgreater}} is handled. Username can
be omitted; in which case the value of the variable \texttt{HOME} is
substituted. If username is supplied, the \texttt{/etc/passwd} file is
searched to supply the home directory of username (this action is
obviously not portable to non-UNIX environments). (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{version}}

\index{version}\texttt{version}\texttt{() : string?} produces the
version number of Icon on which a program is running. It only works if
the \texttt{\&version} is in the standard form. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{vrml, vrml1lib, vrml2lib}}

These modules contain procedures for producing \index{VRML}VRML files.

\texttt{point\_field(L)} create VRML point field from point list
\texttt{L\\
u\_crd\_idx(i)} create VRML coordinate index for 0 through i - 1\\
\texttt{render(x)} render node x\\
\texttt{vrml1(x)} produces VRML 1.0 file for node \texttt{x\\
vrml2(x)} produces VRML 2.0 file for node \texttt{x\\
vrml\_color(s)} converts Icon color specification to vrml form

Notes: Not all node types have been tested. Where field values are
complex, as in vectors, these must be built separately as strings to go
in the appropriate fields. There is no error checking. Fields must be
given in the order they appear in the node record declarations and
field values must be of the correct type and form. The introduction of
record types other than for nodes will cause bogus output. A structural
loop will produce output until the evaluation \index{stack}stack
overflows.

\texttt{vrml1lib.icn} contains record declarations for VRML 1.0 nodes.
Note: Although VRML 1.0 allows node fields to be given in any order,
they must be specified in the order given in the record declarations
that follow. Omitted (null-valued) fields are ignored on output. Group
nodes require list arguments for lists of nodes.

\texttt{vrml2lib.icn} contains record declarations for VRML 2.0 nodes.
Note: Although VRML 2.0 allows node fields to be given in any order,
they must be specified in the order given in the record declarations
that follow. Group nodes require list arguments for lists of nodes. 

Links: \texttt{records}. Requires: Version 9 graphics for color
conversion. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wdiag}}

\texttt{wdiag(s1, s2,...) : null} writes the values of the global
variables named \texttt{s1, s2, ...} with \texttt{s1, s2, ...} as
identifying labels. It writes a diagnostic message to standard error
output if an argument is not the name of a global variable. Note that
this procedure only works for global variables. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{weighted}}

\texttt{WeightedShuffle(sample, percentage) : list} returns the list
\texttt{sample} with a portion of the elements switched. Examples:

\texttt{WeightedShuffle(X, 100)} - returns a fully shuffled list\\
\texttt{WeightedShuffle(X, 50)} - every other element is eligible to be
switched\\
\texttt{WeightedShuffle(X, 25)} - every fourth element is
shuffled\\
\texttt{WeightedShuffle(X, 0)} - nothing is changed

The procedure will fail if the given percentage is not between 0 and
100, inclusive, or if it is not a numeric value. (EE)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wildcard}}

This is a kit of procedures to deal with UNIX-like filename
\index{wild-card patterns}wild-card patterns containing *, ?, and
[...]. The meanings are as of the pattern characters are the same as in
the UNIX shells csh and sh. They are described briefly in the
\texttt{wild\_pat()} procedure. These procedures are interesting partly
because of the {\textquotedbl}recursive suspension{\textquotedbl}
technique used to simulate conjunction of an arbitrary number of
computed expressions. The public procedures are:

\texttt{wild\_match(pattern,s,i1,i2) : integer*} produces the sequence
of positions in \texttt{s} past a substring starting at \texttt{i1}
that matches \texttt{pattern}, but fails if there is no such position.
Similar to \texttt{match()}, but is capable of generating multiple
positions.

\texttt{wild\_find(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} where substrings begin that match
\texttt{pattern}, but fails if there is no such position. Similar to
\texttt{find()}. \texttt{pattern} can be either a string or a pattern
list, see \texttt{wild\_pat()}, below.

Default values of \texttt{s}, \texttt{i1}, and \texttt{i2} are the same
as for Icon{\textquotesingle}s built-in string scanning procedures such
as \texttt{match()}.

\textsf{wild\_pat(s) : L} creates a pattern element list from pattern
string \texttt{s}. A pattern element is needed by
\textsf{wild\_match()} and \textsf{wild\_find()}.
\textsf{wild\_match()} and \textsf{wild\_find()} will automatically
convert a pattern string to a pattern list, but it is faster to do the
conversion explicitly if multiple operations are done using the same
pattern. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{word}}

String scanning function \texttt{word(s, i1, i2) : integer?} produces
the position past a UNIX-style command line word, including quoted and
escaped characters.

\texttt{word\_dequote(s) : string} produces the UNIX-style command line
word \texttt{s} with any quoting characters removed.

Links: \texttt{scanset}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wrap}}

\index{wrap}\texttt{wrap}\texttt{(s:{\textquotedbl}{\textquotedbl},i:0)
: string?} facilitates accumulation of small strings into longer output
strings, outputting when the accumulated string would exceed a
specified length (e.g. outputting items in multiple columns).
\texttt{s} is the string to accumulate, \texttt{i} is the width of
desired output string. \texttt{wrap()} fails if the string \texttt{s}
did not necessitate output of the buffered output string; otherwise the
output string is returned (which never includes \texttt{s}). Calling
\texttt{wrap()} with no arguments produces the buffer (if it is not
empty) and clears it. \texttt{wrap()} does no output to files.
Here{\textquotesingle}s how \texttt{wrap()} is normally used:

\iconcode{
wrap() \# Initialize; not needed unless there was a previous use. \\
every i := 1 to 100 do \# Loop to process strings to output -{}-  \\
\>   write(wrap(x[i],80)) \# only writes when 80-char line filled. \\
write(wrap()) \# Output what{\textquotesingle}s in buffer, if something
to write.
}

\texttt{wraps(s,i) : string?} is similar to \texttt{wrap()}, but
intended for use with \texttt{writes()}. If the string \texttt{s} did
not necessitate a line-wrap, \texttt{s} is returned. If a line-wrap is
needed, \texttt{s}, preceded by a new-line character
(\texttt{{\textquotedbl}{\textbackslash}n{\textquotedbl}}), is
returned. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xcodes}}

This module provides procedures to save and restore Icon structures to
disk. Module \index{xcodes}\texttt{xcodes} handles the encoding of
records using canonical names: record0, record1, ... This allows
programs to decode files by providing declarations for these names when
the original declarations are not available. \texttt{xcodes} also
provides for procedures and files present in the encoded file that are
not in the decoding program.

These procedures provide a way of storing Icon values in files and
retrieving them. \texttt{xencode(x,f)} stores \texttt{x} in file
\texttt{f} such that it can be converted back to \texttt{x} by
\texttt{xdecode(f)}. These procedures handle several kinds of values,
including structures of arbitrary complexity and even loops. The
following sequence will output \texttt{x} and recreate it as
\texttt{y}:

\iconcode{
\>   \ f :=
open({\textquotedbl}xstore{\textquotedbl},{\textquotedbl}w{\textquotedbl}) \\
\>   \ xencode(x,f) \\
\>   \ close(f) \\
\>   \ f := open({\textquotedbl}xstore{\textquotedbl}) \\
\>   \ y := xdecode(f) \\
\>   \ close(f)
}

For {\textquotedbl}scalar{\textquotedbl} types -{}- null, integer, real,
cset, and string, the above sequence will result in the relationship x
=== y. For structured types -{}- list, set, table, and record types
-{}- \texttt{y} is not identical to \texttt{x}, but it has the same
{\textquotedbl}shape{\textquotedbl} and its elements bear the same
relation to the original as if they were encoded and decoded
individually. Files, co-expressions, and windows cannot generally be
restored in any way that makes much sense; they are restored as empty
lists so that (1) they will be unique objects and (2) will likely
generate \index{run-time error}run-time errors if they are (probably
erroneously) used in computation. However, the special files
\texttt{\&input}, \texttt{\&output}, and \texttt{\&errout} are
restored. Not much can be done with functions and procedures, except to
preserve type and identification. The encoding of strings and csets
handles all characters in a way that it is safe to write the encoding
to a file and read it back. \texttt{xdecode()} fails if given a file
that is not in xcode format or it the encoded file contains a record
for which there is no declaration in the program in which the decoding
is done. Of course, if a record is declared differently in the encoding
and decoding programs, the decoding may be bogus.

\texttt{xencoden()} and \texttt{xdecoden()} perform the same operations,
except they take the name of a file to open, not an already-open file.

\texttt{xencodet()} and \texttt{xdecodet()} are like \texttt{xencode()}
and \texttt{xdecode()} except that the trailing argument is a type
name. If the encoded decoded value is not of that type, they fail.
\texttt{xencodet()} does not take an opt argument. 

\texttt{xencode(x, f:\&output, p:write) : f} encodes \texttt{x} writing
to file \texttt{f} using procedure \texttt{p} that writes a line on
\texttt{f} using the same interface as \texttt{write()} (the first
parameter is always the value passed as \texttt{f}).

\texttt{xencode(f:\&input, p:read) : x} returns the restored object
where \texttt{f} is the file to read, and \texttt{p} is a procedure
that reads a line from f using the same interface as read() (the
parameter is always the value passed as \texttt{f}). The \texttt{p}
parameter is not normally used for storage in text files, but it
provides the flexibility to store the data in other ways, such as a
string in memory. If \texttt{p} is provided, then \texttt{f} can be any
arbitrary data object -{}- it need not be a file. For example, to
{\textquotedbl}write{\textquotedbl} \texttt{x} to an Icon string:

\iconcode{
record StringFile(s) \\
procedure main() ... \\
\>   encodeString :=
xencode(x,StringFile({\textquotedbl}{\textquotedbl}),WriteString).s \\
\>   ... \\
end \\
procedure WriteString(f,s[]) \\
\>   \ every f.s {\textbar}{\textbar}:= !s \\
\>   \ f.s {\textbar}{\textbar}:=
{\textquotedbl}{\textbackslash}n{\textquotedbl} \\
\>   \ return \\
end
}

Links: \texttt{escape}. See also: \texttt{object.icn},
\texttt{codeobj.icn}. (RJA, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xforms}}

These procedures produce matrices for affine transformation in two
dimensions and transform point lists. A point list is a list of
\texttt{Point()} records.

\texttt{transform(p:list, M) : list} transforms a point list by
matrix\\
\texttt{transform\_points(pl:list,M)} transforms point list\\
\texttt{set\_scale(x, y) : matrix} produces a matrix for scaling\\
\texttt{set\_trans(x, y) : matrix} produces a matrix for
translation\\
\texttt{set\_xshear(x) : matrix} produces a matrix for x shear\\
\texttt{set\_yshear(y) : matrix} produces a matrix for y shear\\
\texttt{set\_rotate(x) : matrix} produces a matrix for rotation

Links: \texttt{gobject}. See also: \texttt{matrix}. (SBW, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ximage}}

\texttt{ximage(x) : s} produces a string image of \texttt{x}.
\texttt{ximage()} differs from \texttt{image()} in that it outputs all
elements of \index{structure types}structured data types. The output
resembles Icon code and is thus familiar to Icon programmers.
Additionally, it indents successive structural levels in such a way
that it is easy to visualize the data{\textquotesingle}s structure.
Note that the additional arguments in the \texttt{ximage()} procedure
declaration are used for passing data among recursive levels. 

\texttt{xdump(x1,x2,...,xn) : xn} uses \texttt{ximage()} to successively
write the images of x1, x2, ..., xn to \texttt{\&errout}. For example,
the code

\iconcode{
\>   t := table() ; t[{\textquotedbl}one{\textquotedbl}] := 1 ;
t[{\textquotedbl}two{\textquotedbl}] := 2 \\
\>   xdump({\textquotedbl}A table{\textquotedbl},t) \\
\>   xdump({\textquotedbl}A
list{\textquotedbl},[3,1,3,[2,4,6],3,4,3,5])
}

writes the following output (note that \texttt{ximage()} infers the
predominant list element value and avoids excessive output):

\iconcode{
{\textquotedbl}A table{\textquotedbl} \\
T18 := table(\&null) \\
T18[{\textquotedbl}one{\textquotedbl}] := 1 \\
T18[{\textquotedbl}two{\textquotedbl}] := 2 \\
{\textquotedbl}A list{\textquotedbl} \\
L25 := list(8,3) \\
L25[2] := 1 \\
L25[4] := L24 := list(3) \\
L24[1] := 2 \\
L24[2] := 4 \\
L24[3] := 6 \\
L25[6] := 4 \\
L25[8] := 5
}

(RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xrotate}}

\texttt{xrotate(X, i)} rotates the values in \texttt{X} right by one
position. It works for lists and records. This procedure is mainly
interesting as a recursive version of\\
 \ \ \ \ \ \texttt{x1 :=: x2 :=: x3 :=: ... xn\\
}since a better method for lists is \texttt{push(L, pull(L))}. 

\clearpage\subsection{Application Programs, Examples, and Tools}

The Icon Program Library \texttt{progs} directory contains 200+ programs
that are useful for demonstration, entertainment, and/or practical
utility. When it is available, usage information is presented with
[optional] and repeated* command-line arguments.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{adlcheck, adlcount, adlfilter, adlfirst, adllist,
adlsort}

\textsf{adlcheck} checks address lists for correctness.

\textsf{adlcount} counts all the entries in an address list file. If an
argument is given, it counts only those that have designators with
characters in the argument.

\textsf{adlfilter} filters address lists, allowing through only those
entries with specified selectors. The option \textsf{{}-s arg} selects
entries with characters in args (default is all). Option \textsf{{}-x}
inverts the logic, selecting characters not in args

\textsf{adlfirst} writes all the first lines of entries in an address
list file. If an argument is given, it counts only those that have
designators with characters in the argument.

\textsf{adllist} lists entries in address lists.

\texttt{adlsort} sorts entries in address lists.

These programs take various subsets of the following options:\\
\ \ \texttt{{}-n}\ \ by name (default; adllist, adlsort)\\
\ \ \texttt{{}-s}\ \ state (U.S. labels only)\\
\ \ \texttt{{}-z}\ \ ZIP code (U.S. labels only)\\
\ \ \texttt{{}-c}\ \ country name (a very heuristic check)\\
\ \ \texttt{{}-a}\ \ all of the above (adlcheck) \\
\ \ \texttt{{}-C}\ \ by city (U.S., in adllist only)\\
\ \ \texttt{{}-d}\ \ report addresses that exceed
{\textquotedbl}standard dimensions{\textquotedbl} for labels:\\
\ \ \ \ 40 character line length, 8 lines per entry

See also: address.doc, labels.icn.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{animal \hfill (RJA)}}

\textsf{animal} is the familiar {\textquotedbl}animal
game{\textquotedbl} written in Icon. The program asks its human
opponent a series of questions in an attempt to guess what animal he or
she is thinking of. It is an {\textquotedbl}expert
system{\textquotedbl} that starts out with limited knowledge, knowing
only one question, but gets smarter as it plays and learns from its
opponents. At the conclusion of a session, the program asks permission
to remember for future sessions that which it learned. The saved file
is an editable text file, so typos entered during the heat of battle
can be corrected. The game is not limited to guessing only animals. By
simply modifying the first two lines of procedure
{\textquotedbl}main{\textquotedbl} a program can be created that will
happily build a knowledge base in other categories. For example, the
lines:

\iconcode{
GameObject := {\textquotedbl}president{\textquotedbl} \\
Tree := Question({\textquotedbl}Has he ever been known as
Bonzo{\textquotedbl},
{\textquotedbl}Reagan{\textquotedbl},{\textquotedbl}Lincoln{\textquotedbl})
}

can be substituted, the program works reasonably well, and could even
pass as educational. The knowledge files will automatically be kept
separate, too. Typing {\textquotedbl}list{\textquotedbl} at any yes/no
prompt will show an inventory of animals known, and there are some
other commands too. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{banner \hfill (CT)}}

\textsf{banner} is a utility inspired by the UNIX \textsf{banner(1)}
command. It outputs enlarged letters (5x6 matrix) in portrait mode.
With some fiddling you can change the scale or font. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bj \hfill (CT, RLG)}}

\textsf{bj} is a simple but fun blackjack game. The original version was
for an ANSI screen. This version has been modified to work with the
UNIX termcap database file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{blnk2tab}}

\textsf{blnk2tab} is a UNIX-style filter that converts strings of two or
more blanks to tabs.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{c2icn \hfill (RJA)}}

The \textsf{c2icn} filter does the easy work involved in porting a C
program to Icon. It reformats \index{comment}comments, moving embedded
comments to end of line, removes the {\textquotedbl};{\textquotedbl}
from ends of lines, reformats line-continued strings, changes
\texttt{=} to \texttt{:=}, and changes \texttt{{}-{\textgreater}} to
\texttt{.} 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{calc}}

\textsf{calc} is a simple Polish {\textquotedbl}desk
calculator{\textquotedbl}. It accepts as values Icon integers, reals,
csets, and strings (as they would appear in an Icon program) as well as
an empty line for the null value. Other lines of input are interpreted
as operations. These may be Icon operators, functions, or the commands
listed below. In the case of operator symbols, such as \texttt{+}, that
correspond to both unary and binary operations, the binary one is used.
Thus, the unary operation is not available. In case of Icon functions
like \texttt{write()} that take an arbitrary number of arguments, one
argument is used. The commands are:\\
 \ \ \ \ clear\ \ remove all values from the
calculator{\textquotesingle}s \index{stack}stack\\
 \ \ \ \ dump\ \ write out the contents of the stack\\
 \ \ \ \ quit\ \ \ \ exit from the calculator\\
Failure and most errors are detected, but arguments are consumed and not
restored to the stack.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{chkhtml \hfill (RJA)}}

This program checks an \index{HTML}HTML file and detects the following
errors:

\begin{itemize}
\item \ \ Reference to undefined anchor name.
\item \ \ Duplicated anchor name.
\item \ \ Warning for unreferenced anchor name.
\item \ \ Unknown tag.
\item \ \ Badly formed tag.
\item \ \ Improper tag nesting.
\item \ \ Unescaped {\textless}, {\textgreater}, {\textquotedbl}, or \&.
\item \ \ Bad escape string.
\item \ \ Improper embedding of attributes.
\item \ \ Bad (non-\index{ASCII}ASCII) characters
\end{itemize}
The program also advises on the use of
\texttt{{\textless}HTML{\textgreater}},
\texttt{{\textless}HEAD{\textgreater}}, and
\texttt{{\textless}BODY{\textgreater}} tags. 

{\sffamily\bfseries
colm \ \textrm{\textmd{[-w linewidth] [-s space] [-m min\_width] [-t
tab\_width] [-x] [-d] file*}}}

\textsf{colm} arranges a number of data items, one per line, into
multiple columns. Items are arranged in column-wise order, that is, the
sequence runs down the first column, then down the second, etc. If a
null line appears in the input stream, it signifies a break in the
list, and the following line is taken as a title for the following data
items. No title precedes the initial sequence of items. (RJA)

\textsf{\ \ linewidth\ \ }the maximum width allowed for output lines
(default: 80).\\
\ \ \textsf{space\ \ \ \ }minimum number of spaces between items
(default: 2).\\
\ \ \textsf{min\_width\ \ }minimum width to be printed for each entry
(default: no minimum).\\
\ \ \textsf{tab\_width}\texttt{\ \ }tab width used to entab output
lines. (default: no tabs).\\
\ \ \textsf{{}-x}\ \ \ \ print items in row-wise order rather than
column-wise.\\
\ \ \textsf{{}-d}\ \ \ \ distribute columns throughout available
width.\\
\ \ \textsf{{}-h}\texttt{\ \ \ \ }generates a help message.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{comfiles}}

\textsf{comfiles} lists common file names in two directories given as
command-line arguments. Requires: UNIX 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{concord}}

\textsf{concord} produces a simple concordance from standard input to
standard output. Words less than three characters long are ignored.
There are two options:

\texttt{\ \ }\textsf{{}-l n}\texttt{\ \ }\ \ set maximum line length to
n (default 72), starts new line\\
\ \ \textsf{{}-w n}\texttt{\ \ }\ \ set maximum width for word to n
(default 15), truncates

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{conman \hfill (WED)}}

\textsf{conman} responds to queries like {\textquotedbl}? Volume of the
earth in tbsp{\textquotedbl}. The keywords of the language (which are
not reserved) are: \textsf{load, save, print, ?} (same as print),
\textsf{list, is, are} (same as is)

{\textquotedbl}Load{\textquotedbl} followed by an optional filename
loads definitions of units from a file. If filename is not supplied, it
defaults to \texttt{conman.sav}.

{\textquotedbl}Save{\textquotedbl} makes a file for
{\textquotedbl}load{\textquotedbl}. Filename defaults to
\texttt{conman.sav}. {\textquotedbl}Save{\textquotedbl} appends to an
existing file so a user needs to periodically edit his save file to
prune it back.

{\textquotedbl}Print{\textquotedbl} and {\textquotedbl}?{\textquotedbl}
are used in phrases like: ? 5 minutes in seconds. Conman replies: 5
minutes in seconds equals 300.

List puts up on the screen all the defined units and the corresponding
values. The format is same as load/store format.

{\textquotedbl}Is{\textquotedbl} and {\textquotedbl}are{\textquotedbl}
are used like this: 100 cm are 1 meter The discovery of is or are
causes the preceding token (in this case
{\textquotedbl}cm{\textquotedbl}) to be defined. The load/store format
is: \textit{unitname} {\textquotedbl}is{\textquotedbl} \textit{value}.
Examples:

{\sffamily
8 furlongs is 1 mile}

{\sffamily
furlong is 1 / 8 mile }

These last two are equivalent. Note spaces before and after
{\textquotedbl}/{\textquotedbl}. Continuing examples:

{\sffamily
1 fortnight is 14 days }

{\sffamily
furlong/fortnight is furlong / fortnight}

{\sffamily
inches/hour is inch / hour }

After this a user might type: ? 1 furlong/fortnight in inches/hour.
Conman will reply: 1 furlong/fortnight in inches/hour equals 23.57.
Conman{\textquotesingle}s operators have no precedence so the line
above works, but 1 furlong/fortnight in inches/hour gives a wrong
answer. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{countlst}}

\textsf{countlst} counts the number times each line of input occurs and
writes a summary. With no option, the output is sorted first by
decreasing count and within each count, alphabetically. With the option
\texttt{{}-a}, the output is sorted alphabetically. The option
\texttt{{}-t} prints a total at the end.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cross \hfill (WPM)}}

\textsf{cross} takes a list of words and tries to arrange them in
crossword format so that they intersect. Uppercase letters are mapped
into lowercase letters on input. The program objects if the input
contains a nonalphabetic character. It produces only one possible
intersection and it does not attempt to produce the most compact
result. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{crypt \ \ \textrm{\textmd{[key] {\textless}infile
{\textgreater}outfile \hfill (PB, PLT)}}}}

\textsf{crypt} is an example \index{encryption}encryption program. Do
\textit{not} use this in the face of competent cryptanalysis. Helen
Gaines{\textquotesingle} book (Gaines, 1939) is a classical
introduction to the field. As written, \textsf{crypt} uses UNIX-style
console I/O.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{csgen}}

\textsf{csgen} accepts a context-sensitive production grammar and
generates randomly selected sentences from the corresponding language.
Uppercase letters stand for nonterminal symbols and
\texttt{{}-{\textgreater}} indicates the left-hand side can be
rewritten by the right-hand side. Other characters are considered to be
terminal symbols. Lines beginning with \texttt{\#} are comments and are
ignored. A line consisting of a nonterminal symbol followed by a colon
and a nonnegative integer i is a generation specification for i
instances of sentences for the language defined by the nonterminal
(goal) symbol. An example of input to \textsf{csgen} is:

\iconcode{
\# a(n)b(n)c(n)\\
\# Salomaa, p. 11.\\
\# Attributed to M. Soittola.\\
\#\\
X-{\textgreater}abc\\
X-{\textgreater}aYbc\\
Yb-{\textgreater}bY\\
Yc-{\textgreater}Zbcc\\
bZ-{\textgreater}Zb\\
aZ-{\textgreater}aaY\\
aZ-{\textgreater}aa\\
X:10}

The output of \textsf{csgen} for this example is

\iconcode{
aaabbbccc\\
aaaaaaaaabbbbbbbbbccccccccc\\
abc\\
aabbcc\\
aabbcc\\
aaabbbccc\\
aabbcc\\
abc\\
aaaabbbbcccc\\
aaabbbccc}

A positive integer followed by a colon can be prefixed to a production
to replicate that production, making its selection more likely. For
example, \textsf{3:X-{\textgreater}abc} is equivalent to

\iconcode{
X-{\textgreater}abc}

\iconcode{
X-{\textgreater}abc}

\iconcode{
X-{\textgreater}abc}

One option is supported: \textsf{{}-g i} number of derivations;
overrides the number specified in the grammar. Limitations: Only single
uppercase letters may represent nonterminal symbols, and there is no
way to represent uppercase letters as terminal symbols. There can be
only one generation specification and it must appear as the last line
of input. Comments: Generation of context-sensitive strings is a slow
process. It may not terminate, either because of a loop in the
rewriting rules or due to the progressive accumulation of nonterminal
symbols. The program avoids deadlock, where there are no possible
rewrites for a string in the derivation. This program would be improved
if the specification of nonterminal symbols were more general, as in
\textsf{rsg}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cstrings \hfill (RJA)}

\textsf{cstrings} prints all strings (enclosed in double quotes) in C
source files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cwd}}

\textsf{cwd} writes the current working directory, shorn of its path
specification. For appropriately named directories, it can be used as
is: e.g. \textsf{ftp {\textasciigrave}cwd{\textasciigrave}}. Requires:
UNIX. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{daystil \hfill (NL)}

\textsf{daystil} calculates the number of days between the current date
and the date specified on the command line, and writes this number to
\&output. This is useful if you want to know how many days it is until
a birthday, wedding day, etc. The date on the command line can be
specified in a variety of ways. For instance, if you wanted to know how
many days it is until August 12, you could specify it as
{\textquotedbl}August 12{\textquotedbl}, {\textquotedbl}Aug
12{\textquotedbl}, {\textquotedbl}12 August{\textquotedbl}, or
{\textquotedbl}12 aUGuS{\textquotedbl}, among others. The match is case
insensitive. The arguments are accepted as long as exactly one of them
is an integer, and if there are exactly two arguments. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{deal}}

\textsf{deal} shuffles, deals, and displays hands in the game of bridge.
Its utput looks like:

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ S: KQ987\\
 \ \ \ \ \ \ \ \ \ H: 52}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ D: T94}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ C: T82}

{\ttfamily
S: 3 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ S: JT4}

{\ttfamily
H: T7 \ \ \ \ \ \ \ \ \ \ \ \ \ \ H: J9863}

{\ttfamily
D: AKQ762 \ \ \ \ \ \ \ \ \ \ D: J85}

{\ttfamily
C: QJ94 \ \ \ \ \ \ \ \ \ \ \ \ C: K7}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ S: A652}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ H: AKQ4}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ D: 3}

{\ttfamily
\ \ \ \ \ \ \ \ \ \ C: A653}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

Options: The following options are available:

\texttt{{}-h n}\ \ Produce n hands. The default is 1.\\
\texttt{{}-s n}\ \ Set the seed for random generation to n (default 0).
Different seeds give different hands.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{declchck}}

\textsf{declchck} examines ucode files and reports declared identifiers
that may conflict with function names. Requires: UNIX. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{delamc \hfill (TRH)}

\textsf{delamc} delaminates standard input into several output files
according to the separator characters specified by the string following
the -t option. It writes the fields in each line to the corresponding
output files as individual lines. If no data occurs in the specified
position for a given input line an empty output line is written. This
insures that all output files contain the same number of lines as the
input file. If \texttt{{}-} is used as an output file name, the
corresponding field is written to the standard output. If the
\texttt{{}-t} option is not used, an ASCII horizontal tab character is
assumed as the default field separator. The use of delamc is
illustrated by the following:

\textsf{delamc labels opcodes operands}\ \ writes the fields of standard
input, each of which is separated by a tab character, to the output
files \textsf{labels}, \textsf{opcodes}, and \textsf{operands}.

\textsf{delamc -t: scores names matric ps1 ps2 ps3} writes the fields of
standard input, each of which are separated by a colon, to the
indicated output files.

\textsf{delamc -t,: oldata f1 f2} separates the fields using either a
comma or a colon.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{detex \hfill (CLJ)}

\textsf{detex} reads in documents written in the \index{LaTeX}LaTeX
typesetting language, and removes some of the common LaTeX commands to
produce plain \index{ASCII}ASCII. Output must typically be further
edited by hand to produce an acceptable result.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffn \ \ \textrm{\textmd{file*}} \hfill (RJA)}}

\textsf{diffn} shows the \index{diff}differences between n files.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffsort \ \ \textrm{\textmd{[file]}} \hfill (GMT)}}

\textsf{diffsort} reorders the output from the Unix
{\textquotedbl}diff{\textquotedbl} program by moving one-line entries
such as {\textquotedbl}Common subdirectory...{\textquotedbl} and
{\textquotedbl}Only in ...{\textquotedbl} to the front of the output
file and sorting them. Actual difference records then follow, in the
original order, separated by lines of equal signs. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffsum \ \ \textrm{\textmd{[file]}} \hfill (GMT)}}

\textsf{diffsum} reads a file containing output from a run of the Unix
\textsf{diff(1)} utility. Diffsum handles either normal diffs or
context diffs. For each pair of files compared, diffsum reports two
numbers: The number of lines added or changed, and the net change in
file size. The first of these indicates the magnitude of the changes
and the second the net effect on file size. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffu \ \
\textrm{\textmd{f1 f2}} \hfill (RM)}}

\textsf{diffu} exercises the \textsf{dif()} procedure, making it act
like the UNIX \textsf{diff(1)} file difference command.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffword}}

\textsf{diffword} lists the different words in the input text. The
definition of {\textquotedbl}word{\textquotedbl} is naive. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diskpack}}

\textsf{diskpack} is designed to produce a list of files to fit onto
\index{diskettes}diskettes. It can be adapted to other uses. This
program uses a straightforward, first-fit algorithm. The options
supported are:\\
\ \ \textsf{{}-s i}\ \ diskette capacity, default 360000\\
\ \ \textsf{{}-r i}\ \ space to reserve on first diskettes, default
0\\
\ \ \textsf{{}-n s}\texttt{\ \ }UNIX-style file name specification for
files to be packed, default {\textquotedbl}*.lzh{\textquotedbl}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{duplfile}}

\textsf{duplfile} lists the file names that occur in more than one
subdirectory and the subdirectories in which the names occur. This
program should be used with caution on large directory structures.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{duplproc \hfill (RLG)}}

Use \textsf{duplproc} if you plan on posting utility procedures suitable
for inclusion in someone{\textquotesingle}s Icon library directories.
duplproc.icn compiles into a program that will search through every
directory in your ILIBS \index{environment variable!ILIBS}environment
variable (and/or in the directories supplied as arguments to the
program). If it finds any duplicate procedure or record identifiers, it
will report this on the standard output. It is important to try to use
unique procedure names in programs you write, especially if you intend
to link in some of the routines contained in the IPL. BUG: duplproc
thinks that differently written names for the same directory are in
fact different directories. Use absolute path names, and
you{\textquotesingle}ll be fine.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{envelope \ \texttt{\textmd{[options] {\textless}
address(es) \hfill (RF)}}}}

\textsf{envelope} addresses envelopes on a \index{PostScript}PostScript
or HP-LJ printer, including barcodes for the zip code. A line beginning
with \texttt{\#} or an optional alternate separator can be used to
separate multiple addresses. The parser will strip the formatting
commands from an address in a troff or LaTeX letter. Typically,
\textsf{envelope} is used from inside an \index{editor}editor. In
Emacs, mark the region of the address and do \textsf{M-{\textbar}
envelope}. In vi, put the cursor on the first line of the address and
do \textsf{:,+N w !envelope} where N = number-of-lines-in-address.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{farb, farb2}}

Dave \index{Farber, Dave}Farber, co-author of the original SNOBOL
programming language, is noted for his creative use of the English
language. Hence the terms {\textquotedbl}farberisms{\textquotedbl} and
{\textquotedbl}to farberate{\textquotedbl}. This program produces a
randomly selected farberism. Notes: Not all of the farberisms contained
in this program were uttered by the master himself; others have learned
to emulate him. A few of the farberisms may be objectionable to some
persons.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filecnvt \ \textrm{\textmd{[-i s1] [-o s2] infile
outfile}} \hfill (BW)}}

\texttt{filecnvt} copies a text file, converting line terminators. The
file name {\textquotedbl}-{\textquotedbl} is taken to be standard input
or output, depending on its position, although standard input/output
has limited usefulness, since it translates line terminators according
the system being used. The options are:

\textsf{\ \ {}-i s1}\ \ input file has line termination for the system
\textsf{\textit{s1}}. The default is
{\textquotedbl}u{\textquotedbl}.\\
\ \ \textsf{{}-o s2}\ \ write output with line terminators for the
system s2. The default is {\textquotedbl}u{\textquotedbl}.

The designations are:

\ \ d\ \ MS-DOS
({\textquotedbl}{\textbackslash}n{\textbackslash}r{\textquotedbl});
also works for the Atari ST\\
\ \ m\ \ Macintosh
({\textquotedbl}{\textbackslash}r{\textquotedbl})\\
\ \ u\ \ UNIX ({\textquotedbl}{\textbackslash}n{\textquotedbl}); also
works for the Amiga

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fileprnt}}

\textsf{fileprnt} reads the file specified as a command-line argument
and writes out a representation of each character in several forms:
hexadecimal, octal, decimal, symbolic, and \index{ASCII}ASCII code.
Input is from a named file rather than standard input, so that it can
be opened in untranslated mode. Otherwise, on some systems, input is
terminated for characters like \^{}Z. Since this program is
comparatively slow, it is not suitable for processing very large files.
Requires: co-expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filesect}}

\textsf{filesect} writes the section of the input file starting at a
specified line number and extending a specified number of lines. The
specifications are given as integer command-line arguments; the first
is the starting line, the second is the number of lines. For example,
\textsf{filesect 20 100 {\textless}input {\textgreater}output} copies
100 lines from input to output, starting at line 20. If the
specifications are out of range, the file is truncated without comment.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filtskel \hfill (RJA)}

\textsf{filtskel} is a generic filter skeleton in Icon. This program is
not intended to be used as is, it serves as a starting point for
creation of filter programs. Command line options, file names, and
tabbing are handled by the skeleton. You need only provide the
filtering code. As it stands, \textsf{filtskel.icn} copies the input
file(s) to standard output. Multiple files can be specified as
arguments, and will be processed in sequence. The file name
\textsf{{\textquotedbl}-{\textquotedbl}} represents the standard input
file. If there are no arguments, standard input is processed.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findstr \hfill (RJA)}}

\textsf{findstr} is a utility filter to list character strings embedded
in data files (e.g. object files). Options:

\textsf{{}-l length}\ \ minimum string size to be printed (default
3)\\
\textsf{{}-c chars}\ \ a string of characters (besides the standard
ASCII printable characters) to be\\
\ \ \ \ considered part of a string. Icon string escape sequences can be
used.

Multiple files can be specified as arguments, and will be processed in
sequence. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findtext \hfill (PLT)}}

\textsf{findtext} retrieves multiline text from a
\index{database}database indexed by idxtext. Each stretch of text
follows a line declaring the index terms:

\iconcode{
::be ::to ::by ::retrieved}

\iconcode{
Text to be retrieved}

\iconcode{
by findtext}

\iconcode{
::index ::line}

\iconcode{
Each index line begins with {\textquotedbl}::{\textquotedbl}. }

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fixpath \ \textrm{\textmd{filename oldpath
newpath}} \hfill (GMT)}

\textsf{fixpath} changes file paths or other strings in a binary file by
modifying the file in place. Each null-terminated occurrence of
\textsf{oldpath} is replaced by \textsf{newpath}. If the new path is
longer than the old one, a warning is given and the old path is
extended by null characters, which must be matched in the file for
replacement to take place. This is dangerous in general but allows
repairing an errant fixpath command. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fnctab}}

\textsf{fnctab} processes an MVT token file and tabulates the usage of
functions. Since function usage cannot be determined completely from
static analysis, the results should be viewed with this limitation in
mind.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{format \hfill (RJA)}

\textsf{format} is a filter program that word-\index{wrap}wraps a range
of text. Options include full justification (see usage text, below).
All lines that have the same indentation as the first line (or same
comment leading character format if -c option) are wrapped. Other lines
are left as is. This program is useful in conjunction with editors that
can invoke filters on a range of selected text.

The \texttt{{}-c} option attempts to establish the form of a comment
based on the first line, then does its best to deal properly with the
following lines. The types of comment lines that are handled are those
in which each line starts with a {\textquotedbl}comment{\textquotedbl}
character string (possibly preceded by spaces). While formatting
comment lines, text lines following the \index{prototype}prototype line
that don{\textquotesingle}t match the prototype but are flush with the
left margin are also formatted as comments. This feature simplifies
initially entering lengthy comments or making major modifications,
since new text can be entered without concern for comment formatting,
which will be done automatically later.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{former}}

\textsf{former} takes a single line of input and outputs it in lines no
greater than the number given on the command line (default 80). 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fract \hfill (REG, GMT)}}

\textsf{fract} produces successive rational approximations to a real
number. The options are:\\
\ \ \textsf{{}-n r} \ real number to be approximated, default
.6180339887498948482 (see below)\\
\ \ \textsf{{}-l i} limit on number of approximations, default 100
(unlikely to be reached).\\
This program was based on a calculator algorithm posted by: Joseph D.
Rudmin, Duke University Physics Dept. Aug 19, 1987.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fuzz \hfill (AC)}

\textsf{fuzz} does {\textquotedbl}fuzzy{\textquotedbl} string
\index{pattern matching}pattern matching. The result of matching s and
t is a number between 0 and 1, based on counting matching pairs of
characters in increasingly long substrings of s and t. Characters may
be weighted differently. The reverse tally may be given a negative
bias.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gcomp \hfill (WHM, REG)}

\textsf{gcomp} produces a list of the files in the current directory
that do not appear among the arguments. For example, \textsf{gcomp *.c}
produces a list of files in the current directory that do not end in
.c. As another example, to remove all the files in the current
directory that do not match \textsf{Makefile}, \textsf{*.c}, and
\textsf{*.h} the following can be used: \textsf{rm
{\textasciigrave}gcomp Makefile *.c *.h{\textasciigrave}} The files
\textsf{.} and \textsf{..} are not included in the output, but other
{\textasciigrave}dot files{\textquotesingle} are. Requires: UNIX. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{genqueen \hfill (PAB)}

\textsf{genqueen} solves the non-attacking \index{n-queens}n-queens
problem for (square) boards of arbitrary size. The problem consists of
placing chess queens on an n-by-n grid such that no queen is in the
same row, column, or diagonal as any other queen. The output is each of
the solution boards; rotations not considered equal. An example of the
output for n=8:

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}- }

{\ttfamily
{\textbar}Q{\textbar} {\textbar} {\textbar} {\textbar} {\textbar}
{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar} {\textbar} {\textbar} {\textbar}
{\textbar}Q{\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar} {\textbar} {\textbar}Q{\textbar}
{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar}{\textbar} {\textbar} {\textbar}
{\textbar} {\textbar}Q{\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar}Q{\textbar} {\textbar} {\textbar} {\textbar}
{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar} {\textbar}Q{\textbar} {\textbar}
{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar} {\textbar} {\textbar}
{\textbar}Q{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

{\ttfamily
{\textbar} {\textbar} {\textbar}Q{\textbar} {\textbar} {\textbar}
{\textbar} {\textbar} {\textbar}}

{\ttfamily
{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

Usage: \texttt{genqueen n\\
}where n is the number of rows / columns in the board. The default for n
is 6. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gftrace \hfill (GMT)}}

\textsf{gftrace} writes a set of procedures to standard output. Those
procedures can be linked with an Icon program to enable the
\index{tracing}tracing of calls to built-in functions. See the comments
in the generated code for details. The set of generated functions
reflects the built-in functions of the version of Icon under which this
\index{generator}generator is run. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{graphdem \hfill (MH)}

\textsf{graphdem} is a simple bar graphics package with two
demonstration applications. The first displays the 4 most frequently
used characters in a string; the second displays the Fibonacci numbers.
Requires: ANSI terminal support.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{grpsort \hfill (TRH)}

\textsf{grpsort} sorts input containing
{\textquotedbl}records{\textquotedbl} defined to be groups of
consecutive lines. Output is written to standard output. One or more
repetitions of a demarcation line (a line beginning with the separator
string) separate each input record. The first line of each record is
used as the key. If no separator string is specified on the command
line, the default is the empty string. Because all input lines are
trimmed of white space (blanks and tabs), empty lines are default
demarcation lines. The separator string specified can be an initial
substring of the string used to demarcate lines, in which case the
resulting partition of the input file may be different from a partition
created using the entire demarcation string.

The \textsf{{}-o} option sorts the input file but does not produce the
sorted records. Instead it lists the keys (in sorted order) and line
numbers defining the extent of the record associated with each key. The
use of grpsort is illustrated by the following examples. The command
\textsf{grpsort {\textquotedbl}catscats{\textquotedbl} {\textless}x
{\textgreater}y} sorts the file \texttt{x}, whose records are separated
by lines containing the string
\textsf{{\textquotedbl}catscats{\textquotedbl}}, into the file
\textsf{y} placing a single line of
\textsf{{\textquotedbl}catscats{\textquotedbl}} between each output
record. Similarly, the command \textsf{grpsort
{\textquotedbl}cats{\textquotedbl} {\textless}x {\textgreater}y} sorts
the file \textsf{x} as before but assumes that any line beginning with
the string \textsf{{\textquotedbl}cats{\textquotedbl}} delimits a new
record. This may or may not divide the lines of the input file into a
number of records different from the previous example. In any case, a
single line of \textsf{{\textquotedbl}cats{\textquotedbl}} will
separate the output records. Another example is \textsf{grpsort -o
{\textless}bibliography {\textgreater}bibkeys}, which sorts the file
bibliography and produces a sorted list of the keys and the extents of
the associated records in bibkeys. Each output key line is of the form:
\textsf{[s-e] key} where \textsf{s} is the line number of the key line,
\textsf{e} is the line number of the last line, and \textsf{key} is the
actual key of the record.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{headicon}}

\textsf{headicon} prepends a standard header to an Icon program. It does
not check to see if the program already has a header. The first
command-line argument is taken as the base name of the file; default
{\textquotedbl}foo{\textquotedbl}. The second command-line argument is
taken as the author; the default is \textsf{{\textquotedbl}Ralph E.
Griswold{\textquotedbl}} -{}- but you can personalize it for your own
use. The new file is brought up in the vi \index{editor}editor. The
file \textsf{skeleton.icn} must be accessible via \textsf{dopen()}.
Requires: system(), vi(1).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hebcalen,hcal4unx
\hfill (ADC, RLG)}

The Jewish year harmonizes the solar and lunar cycle, using the 19-year
cycle of Meton (c. 432 BCE). It corrects so that certain dates shall
not fall on certain days for religious convenience. The Jewish year has
six possible lengths, 353, 354, 355, 383, 384, and 385 days, according
to day and time of new year lunation and position in Metonic cycle.
Time figures from 6pm previous night. The lunation of year 1 is
calculated to be on a Monday (our Sunday night) at ll:11:20pm. Our data
table begins with a hypothetical year 0, corresponding to 3762 B.C.E.
Calculations in this program are figured in the ancient Babylonian unit
of halaqim {\textquotedbl}parts{\textquotedbl} of the hour = 1/1080
hour. Startup syntax is simply \textsf{hebcalen [date]}, where
\textsf{date} is a year specification of the form 5750 for a Jewish
year, +1990 or 1990AD or 1990CE or -1990 or 1990BC or 1990BCE for a
civil year. \ Requires: \index{keyboard}keyboard functions,
\textsf{hebcalen.dat}, \textsf{hebcalen.hlp}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hr \hfill (CT)}

\textsf{hr} implements a horse-race game.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ibar}}

\textsf{ibar} replaces \index{comment}comment bars in Icon programs by
bars 76 characters long, the library standard. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ibrow \hfill (RJA)}

\textsf{ibrow} browses Icon files for declarations. If no source file
names are provided on the command line, all \texttt{*.icn} files in the
current directory are browsed. The program facilitates browsing of Icon
programs. It was originally written to browse the Icon Program Library,
for which purpose it serves quite well. The user interface is
self-explanatory -{}- use {\textquotedbl}?{\textquotedbl} for help if
you{\textquotesingle}re confused.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icalc \hfill (SBW)}

\textsf{icalc} is a simple infix calculator with control structures and
compound statements. It illustrates a technique that can be easily used
in Icon to greatly reduce the performance cost associated with
recursive-descent parsing with \index{backtracking}backtracking.
Features include:

\begin{itemize}
\item \ \ integer and real value arithmetic
\item \ \ variables
\item \ \ function calls to Icon functions
\item \ \ strings allowed as function arguments
\item \ \ unary operators: + (absolute value), - (negation)
\item \ \ assignment: :=
\item \ \ binary operators: +,-,*,/,\%,\^{},
\item \ \ relational operators: =, !=, {\textless}, {\textless}=,
{\textgreater}, {\textgreater}= (return 1 for true and 0 for false)
\item \ \ compound statements in curly braces with semicolon separators
\item \ \ if-then and if-then-else
\item \ \ while-do
\item \ \ limited form of multiline input
\end{itemize}
The grammar at the start of the {\textquotedbl}parser{\textquotedbl}
proper provides more details. Normally, the input is processed one line
at a time, in calculator fashion. However, compound statements can be
continued across line boundaries. Here is a simple input:

{\sffamily
\{ a := 10; while a {\textgreater}= 0 do \{ write(a); a := a - 1 \};
write({\textquotedbl}Blastoff{\textquotedbl}) \}}

For this input execution is delayed until entire compound statement is
entered. For:

\iconcode{
write(pi := 3.14159)}

\iconcode{
write(sin(pi/2)) }

execution done as each line is entered. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icalls}}

\textsf{icalls} processes trace output and tabulates calls of
procedures.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icn2c \hfill (RJA)}

This filter does some mundane aspects of conversion of Icon to C. It
reformats comments, line-continued strings and procedure declarations,
changes \texttt{:=} to \texttt{=,} and changes \texttt{end} to
\texttt{{\textquotedbl}\}{\textquotedbl}} . 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icontent \ \textmd{{\textless}options{\textgreater}
{\textless}Icon source file{\textgreater}...} \hfill (RJA)}}

\textsf{icontent} builds a list, in Icon comment format, of procedures
and records in an Icon source file. \ Multiple files can be specified
as arguments, and are processed in sequence. The file name
{\textquotedbl}-{\textquotedbl} indicates the standard input file. If
there are no arguments, standard input is processed. Options:\\
\texttt{{}-s}\ \ sort names alphabetically (default is in order of
occurrence)\\
\texttt{{}-l}\ \ list in single column (default is to list in multiple
columns).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icvt \hfill (CW, REG)}

\textsf{icvt} converts Icon programs from \index{ASCII}ASCII syntax to
\index{EBCDIC}EBCDIC syntax or vice versa. The option \texttt{{}-a}
converts to ASCII, while the option \texttt{{}-e} converts to EBCDIC.
The program given in standard input is written in converted form to
standard output. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{idepth}}

\textsf{idepth} processes trace output and reports the maximum depth of
\index{recursion}recursion. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{idxtext \
\texttt{\textmd{[-a] file1 [file2 [...]]}} \hfill (RLG, PLT)}}

\textsf{idxtext} turns a file associated with the \textsf{gettext()}
routine into an indexed text-base. Though \textsf{gettext()} will work
fine with files that haven{\textquotesingle}t been indexed via
\textsf{idxtext()}, access is faster if the indexing is done if the
file is, say, over 5k or 10k.

\textsf{file1, file2}, etc. are the names of \textsf{gettext}{}-format
files that are to be (re-)indexed. The \textsf{{}-a} flag tells
\textsf{idxtext} to abort if an index file already exists. Indexed
files have the format:

\iconcode{
keyname delimiter offset [delimiter offset [etc.]]{\textbackslash}n.}

The first line of the index file is a pointer to the last indexed byte
of the text-base file it indexes. Index files are large. Index names
are not uniquely identified with their original text file. If
you{\textquotesingle}re worried, use the \textsf{{}-a} flag. See also:
\textsf{gettext.icn}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ifilter}}

\textsf{ifilter} applies the operation given as a command-line argument
to each line of standard input, writing out the results. For example,
\textsf{ifilter reverse {\textless}foo} writes out the lines of foo
reversed end-for-end. Trailing arguments can be given on the command
line, as in

\iconcode{
ifilter right 10 0 {\textless}foo \# right(*,
{\textquotedbl}10{\textquotedbl}, {\textquotedbl}0{\textquotedbl})}

\iconcode{
ifilter {\textquotedbl}\%{\textquotedbl} 11 {\textless}foo \# * \%
{\textquotedbl}11{\textquotedbl}}

Except for use with operators and (built-in) functions, this program
needs to be linked with procedures that might be used with it. The
following options are supported:\\
\textsf{\ \ {}-a i}\ \ argument position for strings read in; default
1\\
\ \ \textsf{{}-o i}\ \ resolution of ambiguous operator string names. 1
= unary, 2 = binary. Default 2.\\
\ \ \textsf{{}-l i}\ \ limit on generation, with nonpositive indicating
no limitation; default 1

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{igrep \hfill (RJA)}}

\textsf{i}\index{grep}\textsf{grep} emulates UNIX egrep using the
enhanced regular expressions supported by \textsf{regexp.icn}. Options
supported are nearly identical to those supported by egrep (no -b:
print disk block number). The additional option, -E, allows Icon-type
(hence C-type) string escape sequences in the pattern string. Beware:
when -E is used, backslashes that are meant to be processed in the
regular expression context must be doubled. The following patterns are
equivalent: without -E:
{\textquotesingle}{\textbackslash}bFred{\textbackslash}b{\textquotesingle}
with -E:
{\textquotesingle}{\textbackslash}{\textbackslash}bFred{\textbackslash}{\textbackslash}b{\textquotesingle}


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iheader}}

\textsf{iheader} lists the headers of Icon files whose names are given
on the command line. It complains if the header does not start
correctly but otherwise does not check the syntax of what follows. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ihelp \ \textrm{\textmd{[-f helpfile] [item] [keyword
...]\ \ \ \ \ \ \ \ }}(RJA)}}

\textsf{ihelp} displays help information. The optional item name
specifies the section of the help file that is to be displayed. If no
item name is specified a default section will be displayed, which
usually lists the help items that are available. An initial substring
of the item name that differentiates it from other items is sufficient.
If keyword(s) are specified, then only lines that contain all of the
keywords, in any order, are displayed. The keywords do not have to
correspond to whole words in the help text; only to text fragments. All
item name and keyword matches are case independent. The help file name
is taken from \index{environment variable!HELPFILE}environment variable
HELPFILE. If HELPFILE is not in the environment, file
{\textquotedbl}help{\textquotedbl} in the current directory is used. A
help file name specified in the \texttt{{}-f} option overrides. The
help files are formatted as follows:

\iconcode{
default text lines\\
{}-\\
one\\
item {\textquotedbl}one{\textquotedbl} text lines\\
{}-\\
two\\
item {\textquotedbl}two{\textquotedbl} text lines\\
...}

Sections are separated by lines containing a single
{\textquotedbl}-{\textquotedbl}. Item names are the first line
following a separator line.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iidecode \ \textrm{\textmd{[infile] [-x]}}, iiencode
\ \textrm{\textmd{[infile] [-x] remotefile [-o outfile]}}}}

These are Icon ports of the UNIX/C uudecode/\index{uuencode,
uudecode}uuencode utilities, based on freely distributable BSD code.
The functional changes to the program are: (1) file modes are always
encoded with 0644 permissions, and (2) a command-line switch was added
for xxencoded files (similar to uuencoded files, but capable of passing
unscathed through non-\index{ASCII}ASCII \index{EBCDIC}EBCDIC sites).

\textsf{iidecode} is similar to uudecode. An optional first argument
specifies the file to be decoded (default: standard input).
\textsf{iidecode}{\textquotesingle}s \textsf{{}-x} switch forces use of
the xxdecoding algorithm. If you try to decode an xxencoded file
without specifying \textsf{{}-x}, \textsf{iidecode} will forge ahead
anyway. If it thinks you{\textquotesingle}ve made a mistake,
\textsf{iidecode} informs you after the decode is finished.

\textsf{iiencode} is similar to uuencode. An optional first argument
specifies the file to be encoded (default: standard input). The next
argument specifies the name the encoded file should have when it is
decoded. Extensions to the base uuencode command options include
\textsf{{}-x} and \textsf{{}-o}. An \textsf{{}-x} tells
\textsf{iiencode} to use xxencode (rather than uuencode) format. Option
\textsf{{}-o} causes the following argument to be used as the file
\textsf{iiencode} is to write its output to (default is
\textsf{\&output}). On systems with newline translation (e.g. MS-DOS),
the \textsf{{}-o} argument should always be used. (RLG, FJL)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ilnkxref \ \textrm{\textmd{[-options] {\textless}icon source
file{\textgreater}... \hfill }}(RJA)}

\textsf{ilnkxref} is a utility to create
\index{cross-reference}cross-reference of library files used in Icon
programs (i.e., those files named in \index{link}link declarations).
Requires: UNIX.\\
\texttt{\ \ {}-p}\ \ sort by
{\textquotedbl}popularity{\textquotedbl}\\
\ \ \texttt{{}-v}\ \ report progress information

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ilump}}

\textsf{ilump} copies one or more Icon source files, incorporating
recursively the \index{source code}source code for files named by link
directives. This produces a standalone source program in one file,
which is useful with certain profiling and visualization tools.
Searching for linked source files is similar to the action of Iconc
under UNIX. If a linked file is not found in the current directory,
directories specified by the LPATH \index{environment
variable!LPATH}environment variable are tried.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{imagetyp}}

\textsf{imagetyp} accepts file names from standard input and writes
their image type to standard output. It relies on a procedure
\textsf{imagetyp(s)} that attempts to determine the type of image file
named \texttt{s}. This is problematic and corrupted or fake files can
easily fool it. Furthermore, examples of some image file types were not
available for testing. The types presently recognized are:

\ \ Value returned\ \ \ \ Image file type\\
\ \ ps\ \ \ \ \ \ \index{PostScript}PostScript document\\
\ \ cgm text\ \ \ \ Computer Graphics Metafil, text\\
\ \ cgm binary\ \ \ \ Computer Graphics Metafil, binary\\
\ \ cgm char\ \ \ \ Computer Graphics Metafil, character\\
\ \ sundraw\ \ \ \ SunDraw document\\
\ \ ras\ \ \ \ \ \ UNIX raster image\\
\ \ iris\ \ \ \ \ \ Iris image\\
\ \ rle\ \ \ \ \ \ UNIX RLE image\\
\ \ pbm\ \ \ \ \ \ PBM image\\
\ \ pgm\ \ \ \ \ \ PGM image\\
\ \ ppm\ \ \ \ \ \ PPM image\\
\ \ xwd\ \ \ \ \ \ X Window dump\\
\ \ gif\ \ \ \ \ \ Compuserv GIF image\\
\ \ bmp\ \ \ \ \ \ BMP image\\
\ \ xmp\ \ \ \ \ \ XMP image\\
\ \ xpm\ \ \ \ \ \ XPM image\\
\ \ pcx\ \ \ \ \ \ PCX image\\
\ \ tiff\ \ \ \ \ \ TIFF image\\
\ \ iff\ \ \ \ \ \ IFF/ILBM image\\
\ \ ?\ \ \ \ \ \ unknown type

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ineeds \hfill (RJA)}}

\textsf{ineeds} determines Icon modules required by an Icon module. It
expects environment variable LPATH to be set properly as for the Icon
Compiler.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inter}}

\textsf{inter} lists lines common to two files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{interpe, interpp\hfill (REG, JN)}}

\textsf{interpe} is a crude but effective interpreter for Icon
expressions. Each line entered from standard input must be an Icon
expression. The expression is wrapped with a main procedure, and
written to a pipe that compiles and executes the resulting program. If
the expression is a \index{generator}generator, all its results are
produced. If the command-line option -e is given, the expression is
echoed. This technique is, of course, inefficient and may be painfully
slow except on the fastest platforms. However, the technique is
completely general and as correct as Icon itself.

\textsf{interpp} is kind of like an interactive version of BASIC: Icon
expressions are entered with line numbers and you can resequence them
list them etc. and execute all the lines entered. There is no editor
built in. You have to retype a line to change it. Documentation is
lacking but there is a {\textquotedbl}?{\textquotedbl} help command
that lists all the other commands. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipatch \ \textrm{\textmd{file
path\hfill }(GMT)}}}

\textsf{ipatch} changes the path to iconx, the Icon interpreter, which
is embedded in an Icon executable file under Unix. Because the headers
of such files are not designed to expand, a different form of header is
written to accommodate a possibly longer path.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipldoc}}

\textsf{ipldoc} collects selected information from documentation headers
for Icon procedure files named on the command line. The following
options are supported:\\
\texttt{\ \ }\textsf{{}-s}\ \ skip file headers\\
\ \ \textsf{{}-f}\ \ sort procedure list by file; default sort by
procedure name

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplindex\hfill (REG, SBW)}}

\textsf{iplindex} produces an indexed listing of the Icon Program
Library. The following options are supported:\\
\texttt{\ \ }\textsf{{}-k i}\ \ width keyword field, default 16\\
\ \ \textsf{{}-p i}\ \ width of field for program name, default
12\\
Some noise words are omitted (see
{\textquotedbl}exceptions{\textquotedbl} in the program text). If a
file named except.wrd is open and readable in the current directory,
the words in it are used instead. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplkwic\hfill (SBW, REG)}}

\textsf{iplkwic} is a specialized version of \textsf{kwic.icn} used for
producing kwic listings for the Icon program library. This is a simple
keyword-in-context (\index{KWIC}KWIC) program. It reads from standard
input and writes to standard output. The
{\textquotedbl}key{\textquotedbl} words are aligned at a specified
column, with the text shifted as necessary. Text shifted left is
truncated at the left. Tabs and other characters whose
{\textquotedbl}print width{\textquotedbl} is less than one may not be
handled properly. The following options are supported:\\
\ \ \textsf{{}-c i}\ \ column at which keywords are aligned, default
30\\
\ \ \textsf{{}-h i}\ \ width of identifying column at left, default
20\\
Some noise words are omitted (see
{\textquotedbl}exceptions{\textquotedbl} in the program text). If a
file named except.wrd is open and readable in the current directory,
the words in it are used instead.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplweb \ \textrm{\textmd{[-ipl source] [dest]}}}}

\index{iplweb}\textsf{iplweb} generates web pages from IPL header
\index{comment}comments. It uses an \index{environment
variable!IPL}environment variable IPL which is a path to the Icon
Program Library as a default if \textsf{{}-ipl} is not specified,
\textsf{dest} is the current directory if not specified.
\textsf{iplweb} generates an \index{HTML}HTML subdirectory in
\textsf{dest} and makes an index to \textsf{gprogs}, \textsf{gprocs},
\textsf{procs}, and \textsf{progs} directories under HTML. In each of
these directories is an \textsf{.html} file for each of the
\textsf{.icn} files in the referenced directory. An index to all of
these files is also generated. Each of the \textsf{.html} files
contains the IPL standard comment header info inside. (JK)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iprint \hfill (RJA)}}

\textsf{iprint} is a program to print Icon programs. If a program is
written in a consistent style, this program attempts to keep whole
procedures on the same page. The default is to identify the end of a
print group (i.e. a procedure) by looking for the string
{\textquotedbl}end{\textquotedbl} at the beginning of a line. Through
the -g option, alternative strings can be used to signal end of a
group. Using {\textquotedbl}end{\textquotedbl} as the group delimiter
(inclusive), comments and declarations prior to the procedure are
grouped with the procedure. Specifying a null group delimiter string
(\textsf{{}-g {\textquotedblleft}{\textquotedbl}}) suppresses grouping.
Page creases are skipped over, and form-feeds (\^{}L) embedded in the
file are handled properly. (Form-feeds are treated as spaces by many C
compilers, and signal page ejects in a listing). Page headings (file
name, date, time, page number) are printed unless suppressed by the
\texttt{{}-h} option. Options:\\
\ \ \textsf{{}-n}\ \ number lines\\
\ \ \textsf{{}-pN}\ \ page length: number of lines per page (default: 60
lines)\\
\ \ \textsf{{}-tN}\ \ tab stop spacing (default: 8)\\
\ \ \textsf{{}-h}\ \ suppress page headings.\\
\ \ \textsf{{}-l}\ \ add three lines at top of each page for laser
printer.\\
\ \ \textsf{{}-gS}\ \ end of group string (default:
{\textquotedbl}end{\textquotedbl}).\\
\ \ \textsf{{}-cS}\ \ start of comment string (default:
{\textquotedbl}\#{\textquotedbl}).\\
\ \ \textsf{{}-xS}\ \ end of comment string (default: none).\\
\ \ \textsf{{}-i}\ \  ignore FF at start of line.\\
Any number of file names specified will be printed, each starting on a
new page. For example, to print C source files such as the Icon source
code, use the following options:

{\sffamily
\ \ iprint -g {\textquotesingle} \}{\textquotesingle} -c
{\textquotesingle}/*{\textquotesingle} -x
{\textquotesingle}*/{\textquotesingle} file ... }

Control lines are special character strings that occur at the beginnings
of lines that signal special action. Control lines begin with the start
of comment string (see options). The control lines currently recognized
are:

\texttt{{\textless}comment string{\textgreater}eject} -{}- page eject
(line containing {\textquotedbl}eject{\textquotedbl} does not
print).\\
\texttt{{\textless}comment string{\textgreater}title} -{}- define a
title line to print at top of each page. Title text is separated from
the \texttt{{\textless}comment string{\textgreater}title} control
string by one space and is terminated by \texttt{{\textless}end of
comment string{\textgreater}} or end of line, whichever comes
first.\\
\texttt{{\textless}comment string{\textgreater}subtitle} -{}- define a
subtitle line to print at top of each page. Format is parallel to the
{\textquotedbl}title{\textquotedbl} control line, above.

If a page ejection is forced by maximum lines per page being exceeded
(rather than intentional eject via control line, form feed, or
grouping), printing of blank lines at the top of the new page is
suppressed. Line numbers will still be printed correctly. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipsort}}

\textsf{ipsort} reads an Icon program and writes an equivalent program
with the procedures \index{sort source file procedures}sorted
alphabetically. Global, link, and record declarations come first in the
order they appear in the original program. The main() procedure comes
next followed by the remaining procedures in alphabetical order.
Comments and white space between declarations are attached to the next
following declaration. Limitations: This program only recognizes
declarations that start at the beginning of a line. Comments and
interline white space between declarations may not come out as
intended. One option is accepted: -v preserve VIB section at end.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipsplit}}

\textsf{ipsplit} reads an Icon program and writes each procedure to a
separate file. The output file names consist of the procedure name with
\textsf{.icn} appended. If \textsf{{}-g} is specified, any global,
link, and record declarations are written to that file. Otherwise they
are written in the file for the procedure that immediately follows
them. Comments and white space between declarations are attached to the
next following declaration. The program only recognizes declarations
that start at the beginning of lines. Comments and interline white
space between declarations may not come out as intended. If the -g
option is not specified, global, link, or record declarations that
follow the last procedure are discarded.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipxref \hfill (AJA)}}

\textsf{ipxref} \index{cross-reference}cross-references Icon programs.
It lists the occurrences of each variable by line number. Variables are
listed by procedure or separately as globals. The options specify the
formatting of the output and whether or not to cross-reference quoted
strings and non-alphanumerics. Variables that are followed by a left
parenthesis are listed with an asterisk following the name. If a file
is not specified, then standard input is cross-referenced. The
following options change the defaults:\\
\ \ \textsf{{}-c n}\ \ The column width (default:4) per line
number.\\
\ \ \textsf{{}-l n}\ \ The left margin or starting column (default: 40)
of the line numbers.\\
\ \ \textsf{{}-w n}\ \ The column width (default: 80) of the whole
output line.\\
Normally only alphanumerics are cross-referenced. These options expand
what is considered:\\
\ \ \textsf{{}-q}\ \ Include quoted strings.\\
\ \ \textsf{{}-x}\ \ Include all non-alphanumerics.\\
This program assumes the subject file is a valid Icon program. For
example, it expects quotes be matched. Bugs: In some situations, the
output is not properly formatted.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{isrcline}}

\textsf{isrcline} counts the number of lines in an Icon program that
actually contain code, as opposed to being comments or blank lines.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{istrip}}

\textsf{istrip} removes comments, empty lines, and leading whitespace
from an Icon program.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itab \ \textrm{\textmd{[options]
[source-program...]}}\hfill (RJA)}}

\textsf{itab} entabs an Icon program, leaving quoted strings alone. The
options are:\\
\texttt{{}-i}\ \ Input tab spacing (default 8)\\
\texttt{{}-o}\ \ Output tab spacing (default 8).\\
\textsf{itab} observes Icon conventions for escapes and continuations in
string constants. If no source-program names are given, standard input
is {\textquotedbl}itabbed{\textquotedbl} to standard output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itags \ \textrm{\textmd{[-aBFtvwx] [-f tagsfile]
file...}} \hfill (RJA)}}

\textsf{itags} creates a tags file for an Icon program. The options
are:\\
\ \ \texttt{{}-a}\ \ append output to an existing tags file.\\
\ \ \texttt{{}-B}\ \ use backward searching patterns (?...?).\\
\ \ \texttt{{}-F}\ \ use forward searching patterns (/.../)
(default).\\
\ \ \texttt{{}-x}\ \ produce a list of object names, the line number and
file name on which each is\\
\ \ \ \ defined, as well as the text of that line and prints this on the
standard output.\\
\ \ \ \ This simple index can be printed out as an off-line readable
function index.\\
\ \ \texttt{{}-t}\ \ create tags for records.\\
\ \ \texttt{{}-v}\ \ produce on the standard output an index of the form
expected by vgrind(1). This\\
\ \ \ \ listing contains the function name, file name, and page number
(assuming 64 line\\
\ \ \ \ pages). Since the output will be sorted into lexicographic
order, it may be desired\\
\ \ \ \ to run the output through sort -f. Sample use:\\
\ \ \ \  \ \ \ \textsf{itags -v files {\textbar} sort -f {\textgreater}
index vgrind -x index}\texttt{\\
\ \ {}-w}\ \ suppress warning diagnostics.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrbksum}}

\textsf{itrbksum} summarizes traceback information produced on error
termination by filtering out the bulk of the procedure traceback
information.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrcfltr}}

\textsf{itrcfilter} filters trace output. If there are command-line
arguments, they are taken as procedure names, and only those lines with
those names are written. If there are no command-line arguments, all
lines are written. The names of procedures to pass through can be given
in a {\textquotedbl}response{\textquotedbl} file as accepted by
\textsf{options()}, as in\\
\ \ \textsf{itrcfltr @names {\textless}trace\_file}\\
where \textsf{names} is a file containing the names to be passed
through. The following option is supported: \textsf{{}-a} list all
trace messages; overrides any procedure names given.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrcsum}}

\textsf{itrcsum} provides a summary of Icon trace output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iundecl\hfill (RJA, REG)}}

\textsf{iundecl} invokes icont to find undeclared variables in an Icon
source program. The output is in the form of a
{\textquotedbl}local{\textquotedbl} declaration, preceded by a comment
line that identifies that procedure and file name from whence it arose.
Beware that undeclared variables aren{\textquotesingle}t necessarily
local, so any which are intended to be global must be removed from the
generated list. Multiple files can be specified as arguments, and will
be processed in sequence. The file name {\textquotedbl}-{\textquotedbl}
represents the standard input file. If there are no arguments, standard
input is processed. The program works only if procedures are formatted
such that the keywords {\textquotedbl}procedure{\textquotedbl} and
{\textquotedbl}end{\textquotedbl} are the first words on their
respective lines. Requires: pipe support.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iwriter}}

\textsf{iwriter} reads standard input and produces Icon expressions,
which when compiled and executed, write out the original input. This is
handy for incorporating, for example, message text in Icon programs. Or
even for writing Icon programs that write Icon programs that ... 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{knapsack\hfill (AVH)}}

\textsf{knapsack} is a filter that solves a knapsack problem - how to
fill a container to capacity by inserting items of various volumes. Its
input consists of a string of newline-separated volumes. Its output is
a single solution. knapsack is a demonstration of an underlying
algorithm that might be useful in a variety of real-world applications
you can build. Knapsack may be tested conveniently by supplying its
standard input with any sequence of random numbers. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{krieg\hfill (DJS)}}

Kriegspiel (German for {\textquotedbl}war game{\textquotedbl})
implements a monitor and, if desired, an automatic opponent for a
variation of the game of chess which has the same rules and goal as
ordinary chess except that neither player sees the
other{\textquotesingle}s moves or pieces. Thus Kriegspiel combines the
intricacies and flavor of chess with additional elements of
uncertainty, psychology, subterfuge, etc., which characterize games of
imperfect information such as bridge or poker. To start the game, the
{\textquotedbl}White{\textquotedbl} player makes a move on his board.
If the move is legal, the monitor plays it on his board and invites
{\textquotedbl}Black{\textquotedbl} to make his response. If a move
attempt is illegal (because it leaves the king in check or tries to
move through an enemy piece, etc.), the monitor announces that fact to
both players and the moving player must try again until he finds a
legal move. The game continues until it ends by checkmate, draw, or
agreement by the players. The monitor keeps a record of the moves so
that the players can play the game over at its conclusion and see what
actually happened, which is often quite amusing.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kross\hfill}}

\textsf{kross} accepts pairs of strings on successive lines. It diagrams
all the intersections of the two strings in a common character. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kwic, kwicprep\hfill (SBW, REG)}}

\textsf{kwic} is a simple keyword-in-context (\index{KWIC}KWIC) program.
It reads from standard input and writes to standard output. The
{\textquotedbl}key{\textquotedbl} words are aligned in column 40, with
the text shifted as necessary. Text shifted left is truncated at the
left. Tabs and other characters whose {\textquotedbl}print
width{\textquotedbl} is less than one may not be handled properly. If
an integer is given on the command line, it overrides the default 40.
Some noise words are omitted (see
{\textquotedbl}exceptions{\textquotedbl} in the program text). If a
file named \textsf{except.wrd} is open and readable in the current
directory, the words in it are used instead. 

\textsf{kwicprep} prepares information to create keyword-in-context
listings of the Icon program library. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{labels}}

\textsf{labels} produces mailing labels using coded information taken
from the input file. In the input file, a line beginning with \# is a
label header. Subsequent lines up to the next header or end-of-file are
accumulated and written out centered horizontally and vertically on
label forms. Lines beginning with * are treated as comments and are
ignored. The following options are available:\\
\ \ \textsf{{}-c n}\ \ Print n copies of each label.\\
\ \ \textsf{{}-s s}\ \ Select only those labels whose headers contain a
character in s.\\
\ \ \textsf{{}-t}\ \ Format for curved tape labels (the default is
rectangular mailing labels).\\
\ \ \textsf{{}-w n}\ \ Limit line width to n characters. The default
width is 40.\\
\ \ \textsf{{}-l n}\ \ Limit the number of printed lines per label to n.
The default is 8.\\
\ \ \textsf{{}-d n}\ \ Limit the depth of the label to n. Default is 9
for rectangular labels, 12 for\\
\ \ \ \ tape labels (\textsf{{}-t}).\\
Options are processed from left to right. If the number of printed lines
is set to a value that exceeds the depth of the label, the depth is set
to the number of lines. If the depth is set to a value that is less
than the number of printed lines, the number of printed lines is set to
the depth. Note that the order in which these options are specified may
affect the results. Printing Labels: Label forms should be used with a
pin-feed platen. For mailing labels, the carriage should be adjusted so
that the first character is printed at the leftmost position on the
label and so that the first line of the output is printed on the
topmost line of the label. For curved tape labels, some experimentation
may be required to get the text positioned properly. Diagnostics: If
the limits on line width or the number of lines per label are exceeded,
a label with an error message is written to standard error output. See
also: address.doc, adl*.icn, zipsort.icn. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lam\hfill (TRH)}}

\textsf{lam} laminates files named on the command line to the standard
output, producing a concatenation of corresponding lines from each file
named. If the files are different lengths, empty lines are substituted
for missing lines in the shorter files. A command line argument of the
form \textsf{{}-s} causes the string \textsf{s} to be inserted between
the concatenated file lines. Each command line argument is placed in
the output line at the point that it appears in the argument list. For
example, lines from file1 and file2 can be laminated with a colon
between each line from file1 and the corresponding line from file2 by
the command lam file1 -: file2. File names and strings may appear in
any order in the argument list. If - is given for a file name, standard
input is read at that point. If a file is named more than once, its
lines will be duplicated on the output line, except that if standard
input is named more than once, its lines will be read alternately. For
example, each pair of lines from standard input can be joined onto one
line with a space between them by the command lam - {\textquotedbl}-
{\textquotedbl} - while the command lam file1 {\textquotedbl}-
{\textquotedbl} file1 replicates each line from file1.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{latexidx\hfill (DSC)}}

\textsf{latexidx} processes \index{LaTeX}LaTeX idx files. Input: A latex
.idx file containing the {\textbackslash}indexentry lines. Output:
{\textbackslash}item lines sorted in order by entry value, with page
\index{reference!page}references put into sorted order. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lc}}

\textsf{lc} simply counts the number of lines in standard input and
writes the result to standard output. Assumes UNIX-style line
terminators, and uses lots of memory. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lindcode}}

\textsf{lindcode} reads a file of L-system specifications and build Icon
code that creates a table of records containing the specifications. If
the option -e is given, symbols for which there is no definition are
included in the table with themselves as replacement. See also:
\textsf{lindrec.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lineseq}}

\textsf{lineseq} reads values on separate lines and strings them
together on a single line. The default separator is a blank; other
separating strings can be specified by the \textsf{{}-s} option.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lisp\hfill (SBW, PLT)}}

\textsf{lisp} is a simple interpreter for pure \index{Lisp}Lisp. It
takes the name of the Lisp program as a command-line argument. The
syntax and semantics are based on EV-LISP, as described in Laurent
Siklossy{\textquotesingle}s {\textquotedbl}Let{\textquotesingle}s Talk
LISP{\textquotedbl} (Prentice-Hall, 1976). Functions that have been
predefined match those described in Chapters 1-4 of the book. No
attempt at improving efficiency has been made; this is rather an
example of how a simple Lisp interpreter might be implemented in Icon.
The language implemented is case-insensitive. It only reads enough
input lines at one time to produce at least one lisp-expression, but
continues to read input until a valid lisp-expression is found. Errors:
Fails on EOF; fails with error message if current input cannot be made
into a valid lisp-expression (i.e. more right than left parentheses). 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{literat\hfill (MH)}}

\textsf{literat} is a \index{database}database system to manage
information concerning \index{literature}literature. The program uses
standard files \textsf{literat.fil}, \textsf{literat2.fil} and
\textsf{adress.fil} to store its data on the disk. It has a predefined
structure of the items and predefined field labels to make it easy to
use and to cut down the source code length. Requires: ANSI terminal
support, e.g. \textsf{ansi.sys}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{loadmap\hfill (SBW)}

\textsf{loadmap} produces a formatted listing of selected symbol classes
from a compiled file. The listing is by class, and gives the name,
starting address, and length of the region associated with each symbol.
The options are:\\
\ \ \textsf{{}-a}\ \ Display the absolute symbols.\\
\ \ \textsf{{}-b}\ \ Display the BSS segment symbols.\\
\ \ \textsf{{}-c}\ \ Display the common segment symbols.\\
\ \ \textsf{{}-d}\ \ Display the data segment symbols.\\
\ \ \textsf{{}-t}\ \ Display the text segment symbols.\\
\ \ \textsf{{}-u}\ \ Display the undefined symbols.\\
If no options are specified, \textsf{{}-t} is assumed. If the address of
a symbol cannot be determined, ???? is given in its place. The size of
the last region in a symbol class is suspect and is usually given as
rem. Output is not particularly exciting on a stripped file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{longest}}

\textsf{longest} writes the (last) longest line in the input file. If
the command-line option -\# is given, the number of the longest line is
written first. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lower}}

\textsf{lower} maps the names of all files in the current directory to
lowercase. Requires: UNIX. 

{\sffamily\bfseries
makepuzz \ \textrm{\textmd{[-f}}\textmd{
}\textrm{\textmd{infil]}}\textmd{ }\textrm{\textmd{[-o}}\textmd{
}\textrm{\textmd{outfil]}}\textmd{ }\textrm{\textmd{[-h}}\textmd{
}\textrm{\textmd{ht]}}\textmd{ }\textrm{\textmd{[-w}}\textmd{
}\textrm{\textmd{wd]}}\textmd{ }\textrm{\textmd{[-t}}\textmd{
}\textrm{\textmd{sec]}}\textmd{ }\textrm{\textmd{[-r}}\textmd{
}\textrm{\textmd{reject]}}\textmd{ }\textrm{\textmd{[-s]}}\textmd{
}\textrm{\textmd{[-d]}}}

\textsf{makepuzz} takes a list of words, and constructs out of them one
of those square find-the-word puzzles that some people like to bend
their minds over. infile is a file containing words, one to a line
(defaults to \textsf{\&input}), and outfile is the file you would like
the puzzle written to (defaults to \textsf{\&output}). \textsf{ht}
(height) and \textsf{wd} (width) are the basic dimensions you want to
try to fit your word game into (default 20x20). If the \textsf{{}-s}
argument is present, \textsf{makepuzz} will scramble its output, by
putting random letters in all the blank spaces. The \textsf{{}-t} tells
the computer when to give up, and construct the puzzle (letting you
know if any words didn{\textquotesingle}t make it in). Defaults to 60
(i.e. one minute). The \textsf{{}-r} argument tells \textsf{makepuzz}
to run until it arrives at a solution with number-of-rejects or fewer
un-inserted words. \textsf{{}-d} turns on certain diagnostic messages.
Most of these options can safely be ignored. Just type something like
\textsf{makepuzz -f wordlist}, where \textsf{wordlist} is a file
containing about sixty words, one word to a line. Out will pop a
{\textquotedbl}word-find{\textquotedbl} puzzle. Once you get the hang
of what is going on, try out the various options. The algorithm used
here is a combination of random insertions and mindless, brute-force
iterations through possible insertion points and insertion directions.
If you don{\textquotesingle}t like \textsf{makepuzz}{\textquotesingle}s
performance on one run, run it again. If your puzzle is large, try
increasing the timeout value (see \textsf{{}-t} above). (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{missile\hfill (CT)}}

\textsf{missile} is a cheap attempt at a Missile Command game. It runs
on systems that support the \textsf{delay()} function, and uses ANSI
escape sequences for screen output. To play use 7, 8, and 9 to launch a
missile. 7 is leftward, 8 is straight, and 9 is right. q quits the
game. Requires: \textsf{ansi.sys}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{miu\hfill (CAC, REG)}}

\textsf{miu} generates strings from the MIU string system. The number of
generations is determined by the command-line argument; default is 7.
Reference: Godel, Escher, and Bach: an Eternal Golden Braid, Douglas R.
Hofstadter, Basic Books, 1979. pp. 33-36. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mkpasswd\hfill (JK)}}

\textsf{mkpasswd} creates a list of randomly generated
\index{password}passwords consisting of eight random characters in the
range [A-Z0-9]. Number of passwords to generate is the first argument;
default 1.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{monkeys\hfill (SBW, REG, AB)}}

The old monkeys at the typewriters anecdote... \textsf{monkeys} uses
ngram analysis to randomly generate text in the same
{\textquotesingle}style{\textquotesingle} as the input text. The
arguments are:\\
\ \ \textsf{{}-s}\ \ show the input text\\
\ \ \textsf{{}-n}\ \ n use n as the ngram size (default:3)\\
\ \ \textsf{{}-l n}\ \ output at about n lines (default:10)\\
\ \ \textsf{{}-r n}\ \ set random number seed to n

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{morse\hfill (REG, RJA)}}

If \textsf{morse} is invoked without arguments, a \index{Morse
code}Morse code table is printed. If arguments are given, the Morse
code conversion is printed in dots and dashes. If the first
argument{\textquotesingle}s first character is a dot or dash, the
arguments are Morse code and converted to a string.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mr \ \textrm{\textmd{[recipient] [-u user] [-f spool]}}\hfill(RF)}}

With no arguments, \textsf{mr} reads the default \index{mail spool}mail
spool. Another user, a spool file, or the recipient for outgoing mail
can be given as a command line argument. Help, including the symbols
used to indicate the status of mail, is available with the H command.
The program is oriented towards UNIX Internet mail processing.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{newicon\hfill}}

\textsf{newicon} creates a new file with a standard Icon program header
and a skeleton mail procedure. The first command-line argument is taken
as the base name of the file; default
{\textquotedbl}foo{\textquotedbl}. The second command-line argument is
taken as the author. The default is {\textquotedbl}Ralph E.
Griswold{\textquotedbl}; personalize it for your own use. The same
\index{comment}comment applies to the skeleton file mentioned below.
The new file is brought up in the vi \index{editor}editor. The options
are:\\
\ \ \textsf{{}-f}\ \ overwrite an existing file\\
\ \ \textsf{{}-p}\ \ produce a procedure file instead of a
program\\
\ \ \textsf{{}-o}\ \ provide program skeleton with
\textsf{options()}\\
The files \textsf{skeleton.icn}, \textsf{skelproc.icn}, and
\textsf{skelopt.icn} must be accessible via \textsf{dopen()}.
\ Requires: system(), vi(1).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{newsrc\hfill (ADC)}}

\index{news}\textsf{news}\textsf{rc} takes the \textsf{.newsrc} file,
moves active groups to the beginning, and then appends inactive groups
with the numbers omitted, followed by anything else. The groups are
alphabetized. The user may retain a set of groups at the top of the
file by specifying how many groups on the command line. If not
specified, it will be prompted for. The new file is called newnewsrc.
The user can replace .newsrc with it if it is satisfactory. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{nim\hfill (JN)}}

The game of \textsf{nim} focuses on a pile of 15 sticks. Each player can
select 1, 2, or 3 sticks from the sticks remaining in the pile when
it{\textquotesingle}s their turn. The player to pick up the last
stick(s) wins. The loser of the previous game always gets to go first.
There are two versions of nim in here. The first (default) version uses
an algorithm to make its moves. It will never lose if it gets the first
turn. The second version learns from each game. After a while it will
also never lose if it gets the first turn, if you know how to play.
Since the learning version learns from the person it plays against, if
you{\textquotesingle}re lousy, the game will be too. To invoke the
learning version, pass any argument to the program. To see how the
program learns, use \textsf{show} as the argument and the
program{\textquotesingle}s game memory is displayed after each game.
Invoke the game with \textsf{save} as an argument to create a file
called {\textquotedbl}.nimdump{\textquotedbl} in the current directory
with a dump of the program{\textquotesingle}s game memory when you
quit. When the game is played in learn mode it will initialize its game
memory from the dump. You can invoke this program with both
\textsf{show} and \textsf{save} at the same time.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{oldicon}}

\textsf{oldicon} updates the date line in a standard Icon program
header. The old file is saved with the suffix \textsf{.bak}. The file
then is brought up in the vi \index{editor}editor unless the
\textsf{{}-f} option is specified. Requires: \textsf{system()},
\textsf{vi(1)}, UNIX.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pack}}

\textsf{pack} takes a list of file names on the command line and
packages the files into a single file, which is written to standard
output. Files are separated by a header, \#\#\#\#\#\#\#\#\#\#, followed
by the file name. This simple scheme does not work if a file contains
such a header itself, and it{\textquotesingle}s problematical for files
of binary data. See also: \textsf{unpack.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{paginate\hfill (PA)}}

\textsf{paginate} processes a document text file, inserting \index{form
feed}form feeds at appropriate places. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{papply}}

\textsf{papply} applies the procedure given as a command-line argument
to each line of standard input, writing out the results. For example,
\textsf{papply reverse {\textless}foo} writes out the lines of foo
reversed end-for-end. As it stands, there is no way to provide other
arguments. Except for use with (built-in) functions, this program needs
to be linked with procedures that might be used with it. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{parens}}

\textsf{parens} produces parenthesis-balanced strings in which the
parentheses are randomly distributed. The following options are
available:\\
\ \ \textsf{{}-b n}\ \ Bound the length of the strings to n left and
right parentheses each. Default: 10.\\
\ \ \textsf{{}-n n}\ \ Produce n strings. Default: 10.\\
\ \ \textsf{{}-l s}\ \ Use the string s for the left parenthesis.
Default: \textsf{{\textquotedbl}({\textquotedbl}} .\\
\ \ \textsf{{}-r s}\ \ Use the string s for the right parenthesis.
Default: \textsf{{\textquotedbl}){\textquotedbl} }.\\
\ \ \textsf{{}-v}\ \ Randomly vary the length of the strings between 0
and the bound. In the absence\\
\ \ \ \ of this option, all strings are the exactly as long as the
specified bound.\\
This program was motivated by the need for test data for error repair
schemes for block-structured programming languages. A useful extension
to this program would be some way of generating other text among the
parentheses. In addition to the intended use of the program, it can
produce a variety of interesting patterns, depending on the strings
specified by \textsf{{}-l} and \textsf{{}-r}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pargen}}

\textsf{pargen} reads a context-free BNF grammar and produces an Icon
program that is a parser for the corresponding language. Nonterminal
symbols are enclosed in angular brackets. Vertical bars separate
alternatives. All other characters are considered to be terminal
symbols. The nonterminal symbol on the first line is taken to be the
goal. An example is:

\iconcode{
{\textless}expression{\textgreater}::={\textless}term{\textgreater}{\textbar}{\textless}term{\textgreater}+{\textless}expression{\textgreater}}

\iconcode{
{\textless}term{\textgreater}::={\textless}element{\textgreater}{\textbar}{\textless}element{\textgreater}*{\textless}term{\textgreater}}

\iconcode{
{\textless}element{\textgreater}::=x{\textbar}y{\textbar}z{\textbar}\{{\textless}expression{\textgreater}\}}

Parentheses can be used for grouping symbols, as in
\textsf{{\textless}term{\textgreater}::={\textless}element{\textgreater}({\textbar}*{\textless}term{\textgreater})
}Note that an empty alternative is allowable. The right-hand side
metacharacters \texttt{{\textless}}, \texttt{{\textgreater}},
\texttt{(}, \texttt{)}, and \texttt{{\textbar}} are accessible through
the built-in symbols \textsf{{\textless}lb{\textgreater}},
\textsf{{\textless}rb{\textgreater}},
\textsf{{\textless}lp{\textgreater}},
\textsf{{\textless}rp{\textgreater}}, and
\textsf{{\textless}vb{\textgreater}}, respectively. There are two other
build-in symbols, \textsf{{\textless}empty{\textgreater}} and
\textsf{{\textless}nl{\textgreater}} that match the empty string and a
newline, respectively. Characters in nonterminal names are limited to
letters, digits, and underscores. An underscore is appended to the
parsing procedure name to avoid possible collisions with Icon function
names. Lines beginning with an = are passed through unchanged. This
allows Icon declarations to be placed in the parser. Lines beginning
with a \# are considered to be \index{comment}comments and are ignored.
If the name of a ucode file is given on the command line, a
\index{link}link declaration for it is provided in the output.
Otherwise the main procedure in \textsf{recog} is used. Limitations:
Left \index{recursion}recursion in the grammar may cause the parser to
loop. There is no check that all nonterminal symbols are defined or
that there may be duplicate definitions. Output links \textsf{recog},
\textsf{matchlib}. See also: \textsf{recog.icn}, \textsf{matchlib.icn},
and \textsf{parscond.icn} in the IPL \index{source code}source code. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{parse, parsex\hfill (KW, CW)}}

\index{parse}\textsf{parse} parses simple statements. It provides an
interesting example of the use of co-expressions. \textsf{parsex} is
another expression parser, adapted from C code written by Allen I.
Holub (Dr. Dobb{\textquotesingle}s Journal, Feb 1987). This
general-purpose expression analyzer can evaluate any expression
consisting of numbers and the following operators (listed according to
precedence level):\\
\textsf{\ \ () - !
{\textquotesingle}str{\textquotesingle}str{\textquotesingle} * / \& + -
{\textless} {\textless}= {\textgreater} {\textgreater}= == != \&\&
{\textbar}{\textbar}} \\
All operators associate left to right unless () are present. The top -
is a unary minus. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patchu\hfill (RM)}

\index{patch}\textsf{patch}\textsf{u} reads a source file and a diff
file, producing an updated file. The diff file may be generated by the
UNIX \textsf{diff(1)} utility, or by \textsf{diffu.icn}, which uses
\textsf{dif.icn} for the hard work. The original \textsf{patch(1)}
utility, written by Larry Wall, is widely used in the UNIX community.
See \textsf{diff(1)} in a UNIX manual for more details. Requires:
co-expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pdecomp}}

\textsf{pdecomp} lists the prime factors of integers given in standard
input.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{polydemo\hfill (EE)}}

\textsf{polydemo} is an example use of the \textsf{polystuf} library
module. The user is given options that allow the creation, output,
deletion, or operations on up to 26 polynomials, indexed by letter.
Available commands: (R)ead - allows input of a polynomial by giving
pairs of coefficients and exponents. For example, entering 5, 6, 2, and
3 will create 5x\^{}6 + 2x\^{}3. This polynomial will be stored by an
index that is a lower-case letter. (W)rite - outputs to the screen a
chosen polynomial. (A)dd - adds two polynomials and defines the sum as
a third (S)ubtract - subtracts two polynomials and defines the
difference as a third. (M)ultiply - multiplies two polynomials and
defines the product as a third. (E)valuate - gives the result of
setting x in a polynomial to a value (C)lear - deletes one polynomial
(H)elp - lists all commands (Q)uit - end the demonstration.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{polydemo\hfill (EE)}}
post \ \textrm{\textmd{[-n groups] [-s subj] [-d dist] [-f followup] [-p
prefix] [file]}}

\textsf{post} posts a \index{news}news article to Usenet. Given the name
of a file (\textsf{{\textquotedbl}-{\textquotedbl}} for standard input)
containing a news article, \textsf{post} creates a follow-up article,
with an attribution and quoted text. The newsgroups, subject,
distribution, follow-up, and quote prefix (default
{\textquotesingle}{\textgreater} {\textquotesingle}) can optionally be
specified on the command line. On systems posting via \textsf{inews},
\textsf{post} validates newsgroups and distributions in the
\textsf{active} and \textsf{distributions} files in the news library
directory. Bugs: Newsgroup validation assumes the active file is
sorted. (RF)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{press\hfill (RJA)}}

Besides being a useful file archiving utility, \textsf{press} can be
used to experiment with the LZW compression process, as it contains
extensive \index{tracing}tracing facilities that illustrate the process
in detail. Compression can be turned off if faster archiving is
desired. The LZW compression procedures in this program are general
purpose and suitable for reuse in other programs.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procprep}}

\textsf{procprep} is used to produce the data needed to index the
{\textquotedbl}\#:{\textquotedbl} comments on procedure declarations
that is needed to produces a permuted index to procedures. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procwrap}}

\textsf{procwrap} takes procedure names from standard input and writes
minimal procedure declarations for them. For example, the input line
wrapper produces:

\iconcode{
procedure wrapper()}

\iconcode{
end}

This program is useful when you have a lot of procedures to write. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{psrsplit
\ \textrm{\textmd{file}}\hfill (GMT)}}

\index{PostScript}\textsf{psrsplit} separates \textsf{psrecord.icn}
output pages. If a file produced by the procedures in
\textsf{psrecord.icn} contains multiple pages, it cannot be easily
incorporated into another document. \textsf{psrsplit} reads such a file
and breaks it into individual pages. The algorithm is frugal of memory
and file descriptors at the expense of reading the input file multiple
times. For an input file named \textsf{xxxx} or \textsf{xxxx.yyy}, the
output files are named \textsf{xxxx.p01}, \textsf{xxxx.p01}, etc. for
as many pages as are available. It is assumed that the input file was
written by \textsf{psrecord.icn}; the likelihood of correctly
processing anything else is small. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{puzz}} \hfill (CT)}

\textsf{puzz} creates word search puzzles. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{qei\hfill (WHM, REG)}}

\textsf{qei} takes expressions entered at the command line and evaluates
them. A semicolon is required to complete an expression. If one is not
provided, the subsequent line is added to what already has been
entered. It is important to know that \texttt{qei} accumulates
expressions and evaluates all previously entered expressions before it
evaluates a new one. A line beginning with a colon is a command. The
commands are:\\
\ \ :clear\ \ clear the accumulated expressions.\\
\ \ :every\ \ generate all the results from the expression; otherwise,
at most one is produced.\\
\ \ :exit\ \ terminate the session\\
\ \ :quit\ \ terminate the session\\
\ \ :list\ \ list the accumulated expressions.\\
\ \ :type\ \ toggle switch that displays the type of the result
(default: on)\\
{\textquotedbl}qei{\textquotedbl} is derived from the Latin
{\textquotedbl}quod erat
inveniendum{\textquotedbl}-{}-{\textquotedbl}which was to be found
out{\textquotedbl}. Requires: co-expressions and \textsf{system()}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{qt
\ \textrm{\textmd{[-a]}}\hfill (RJA)}}

\textsf{qt} writes out the time in English. If \textsf{{}-a} is present,
only the time is printed: \textsf{just after a quarter to three.}
Otherwise, time is printed as a sentence: \textsf{It{\textquotesingle}s
just after a quarter to three}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{queens\hfill (SBW)}}

\textsf{queens} displays the solutions to the non-attacking
\index{n-queens}n-queens problem: the ways in which n queens can be
placed on an n-by-n chessboard so that no queen can attack another. A
positive integer can be given as a command line argument to specify the
number of queens. For example, \textsf{queens -n8} displays the
solutions for 8 queens on an 8-by-8 chessboard. The default value in
the absence of an argument is 6. This program is worth reading for its
programming techniques.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ranstars}}

\textsf{ranstars} displays a random field of
{\textquotedbl}stars{\textquotedbl} on an ANSI terminal. It displays
stars at randomly chosen positions on the \index{screen}screen until
the specified maximum number is reached. It then extinguishes existing
stars and creates new ones for the specified steady-state time, after
which the stars are extinguished, one by one. The programming technique
is worth noting. It is originally due to Steve Wampler. The options
are:\\
\ \ \textsf{{}-m n}\ \ maximum number of stars, default 10.\\
\ \ \textsf{{}-t n}\ \ length of steady-state time before stars are
extinguished, default 50.\\
\ \ \textsf{{}-s c}\ \ the character used for
{\textquotedbl}stars{\textquotedbl}, default *. Only the first
character in \texttt{c} is used.\\
Requires: co-expressions, ANSI terminal.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{recgen}}

\textsf{recgen} reads a context-free \index{BNF}BNF grammar and produces
an Icon program that is a recognizer for the corresponding language.
Nonterminal symbols are enclosed in angular brackets. Vertical bars
separate alternatives. All other characters are considered to be
terminal symbols. The nonterminal symbol on the first line is taken to
be the goal. An example is:

\iconcode{
{\textless}expression{\textgreater}::={\textless}term{\textgreater}{\textbar}{\textless}term{\textgreater}+{\textless}expression{\textgreater}\\
{\textless}term{\textgreater}::={\textless}element{\textgreater}{\textbar}{\textless}element{\textgreater}*{\textless}term{\textgreater}\\
{\textless}element{\textgreater}::=x{\textbar}y{\textbar}z{\textbar}({\textless}expression{\textgreater})}

Characters in nonterminal names are limited to letters and underscores.
An underscore is appended for the recognizing procedure name to avoid
possible collisions with Icon function names. Lines beginning with an =
are passed through unchanged. This allows Icon code to be placed in the
recognizer. Limitations: Left \index{recursion}recursion in the grammar
may cause the recognizer to loop. There is no check that all
nonterminal symbols that are referenced are defined or for duplicate
definitions. Reference: The Icon Programming Language, Second Edition,
Ralph E. and Madge T. Griswold, Prentice-Hall, 1990. pp. 180-187. See
also: \textsf{pargen.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{reply \ \texttt{\textmd{[prefix] {\textless}
}}\texttt{\textmd{\textit{news-article}}}\texttt{\textmd{ or
}}\texttt{\textmd{\textit{mail-item}}} \hfill (RF)}}

\textsf{reply} creates the appropriate headers and attribution, quotes a
news or mail message, and uses \textsf{system()} calls to put the user
in an \index{editor}editor and then to mail the reply. The default
prefix for quoted text is \textsf{{\textquotedblleft}{\textgreater}
{\textquotedblleft}}. If a smarthost is defined, Internet addresses are
converted to bang paths (\textsf{name@site.domain} becomes
\textsf{site.domain!name}). The mail is routed to a domained smarthost
as \textsf{address@smarthost.domain}, otherwise to
\textsf{smarthost!address}. The default editor can be overridden with
the EDITOR \index{environment variable!EDITOR}environment variable. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{repro\hfill (KW)}}

\textsf{repro} is the shortest known self-reproducing Icon program. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{revsort\hfill}}

\textsf{revsort} sorts strings with characters in reverse order. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{roffcmds}}

\textsf{roffcmds} processes standard input and writes a tabulation of
nroff/troff commands and defined strings to standard output.
Limitations: the program only recognizes commands that appear at the
beginning of lines and does not attempt to unravel conditional
constructions. Similarly, defined strings buried in disguised form in
definitions are not recognized. Reference: Nroff/Troff
User{\textquotesingle}s Manual, Joseph F. Ossana, Bell Laboratories,
Murray Hill, New Jersey. October 11, 1976. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rsg}}

\textsf{rsg} generates randomly selected strings
({\textquotedbl}sentences{\textquotedbl}) from a grammar specified by
the user. Grammars are basically context-free and resemble BNF in form,
although there are a number of extensions. The program works
interactively, allowing the user to build, test, modify, and save
grammars. Input to \textsf{rsg} consists of various kinds of
specifications, which can be intermixed: Productions define nonterminal
symbols in syntax similar to the rewriting rules of BNF with various
alternatives consisting of the concatenation of nonterminal and
terminal symbols. Generation specifications cause the generation of a
specified number of sentences from the language defined by a given
nonterminal symbol. Grammar output specifications cause the definition
of a specified nonterminal or the entire current grammar to be written
to a given file. Source specifications cause subsequent input to be
read from a specified file. In addition, any line beginning with \# is
considered to be a comment, while any line beginning with = causes the
rest of that line to be used subsequently as a prompt to the user
whenever \textsf{rsg} is ready for input (there normally is no prompt).
A line consisting of a single = stops prompting. Productions look like:

\iconcode{
{\textless}expr{\textgreater}::={\textless}term{\textgreater}{\textbar}{\textless}term{\textgreater}+{\textless}expr{\textgreater}\\
{\textless}term{\textgreater}::={\textless}elem{\textgreater}{\textbar}{\textless}elem{\textgreater}*{\textless}term{\textgreater}\\
{\textless}elem{\textgreater}::=x{\textbar}y{\textbar}z{\textbar}({\textless}expr{\textgreater})}

Productions may occur in any order. Specifying a new production for it
changes the definition for a nonterminal symbol. There are a number of
special devices to facilitate the definition of grammars, including
eight predefined, built-in nonterminal symbols:\\
\ \ symbol\ \ definition\\
\ \ {\textless}lb{\textgreater}\ \ \ \ {\textless}\\
\ \ {\textless}rb{\textgreater}\ \ \ \ {\textgreater}\\
\ \ {\textless}vb{\textgreater}\ \ \ \ {\textbar}\\
\ \ {\textless}nl{\textgreater}\ \ \ \ newline\\
\ \ {\textless}{\textgreater}\ \ \ \ empty string\\
\ \ {\textless}\&lcase{\textgreater}\ \ any single lowercase
letter\\
\ \ {\textless}\&ucase{\textgreater}\ \ any single uppercase
letter\\
\ \ {\textless}\&digit{\textgreater}\ \ any single digit (Note: \&digit,
not \&digits)\\
In addition, if the string between a {\textless} and a {\textgreater}
begins and ends with a single quotation mark, it stands for any single
character between the quotation marks. For example,
{\textless}{\textquotesingle}xyz{\textquotesingle}{\textgreater} is
equivalent to x{\textbar}y{\textbar}z

A generation specification consists of a nonterminal symbol followed by
a nonnegative integer. An example is {\textless}expr{\textgreater}10
which specifies the generation of 10 {\textless}expr{\textgreater}s. If
the integer is omitted, it defaults to 1. Generated sentences are
written to standard output. Grammar Output Specifications: A grammar
output specification consists of a nonterminal symbol, followed by
-{\textgreater}, followed by a file name. Such a specification causes
the current definition of the nonterminal symbol to be written to the
given file, defaulting to standard output. If the nonterminal symbol is
omitted, the entire grammar is written out. Thus, -{\textgreater}
causes the entire grammar to be written to standard output.

A source specification consists of @ followed by a file name. Subsequent
input is read from that file. When an end of file is encountered, input
reverts to the previous file. Input files can be nested. The following
options are available:\\
\ \ \texttt{{}-s n}\ \ Set the seed for random generation to n.\\
\ \ \texttt{{}-r\ \ }Set the seed to 0 for repeatable results.
\texttt{{}-r} is same as \texttt{{}-s 0}.\\
\ \ \texttt{{}-l n\ \ }Terminate if \# symbols to be processed exceeds
n. The default is limit is 1000.\\
\ \ \texttt{{}-t\ \ }Trace the generation of sentences. Trace output
goes to standard error output.

Syntactically erroneous input lines are noted but are otherwise ignored.
Specifications for a file that cannot be opened are noted and treated
as erroneous. If an undefined nonterminal symbol is encountered during
generation, an error message that identifies the undefined symbol is
produced, followed by the partial sentence generated to that point.
Exceeding the limit of symbols remaining to be generated as specified
by the -l option is handled similarly. Caveats: Generation may fail to
terminate because of a loop in the rewriting rules or, more seriously,
because of the progressive accumulation of nonterminal symbols. The
latter problem can be identified by using the -t option and controlled
by using the -l option. Duplicating alternatives that lead to fewer
rather than more nonterminal symbols often can circumvent the problem.
For example, changing

\iconcode{
{\textless}term{\textgreater}::={\textless}elem{\textgreater}{\textbar}{\textless}elem{\textgreater}*{\textless}term{\textgreater}}

to

\iconcode{
{\textless}term{\textgreater}::={\textless}elem{\textgreater}{\textbar}{\textless}elem{\textgreater}{\textbar}{\textless}elem{\textgreater}*{\textless}term{\textgreater}}

increases the probability of selecting
\texttt{{\textless}elem{\textgreater}} from 1/2 to 2/3. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ruler\hfill (RJA)}}

\textsf{ruler} writes a character ruler to standard output. The first
optional argument is the length of the ruler in characters (default
80). The second is a number of lines to write, with a line number on
each line.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scramble\hfill (CT)}}

\textsf{scramble} takes a document and re-outputs it in a cleverly
scrambled fashion. It uses the next two most likely words to follow.
The concept was found in a recent Scientific American and Icon seemed
to offer the best implementation.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{setmerge \ \texttt{\textmd{file [[op]
file]...}} \hfill (GMT)}}

\textsf{setmerge} combines sets of items according to the specified
operators. Sets are read from files, one entry per line. Operation is
from left to right without any precedence rules. After all operations
are complete the resulting set is sorted and written to standard
output. Operations:\\
\ \ +\ \ add contents to set\\
\ \ {}-\ \ subtract contents from set\\
\ \ *\ \ intersect contents with set\\
Note that operators must be separate command options, and that some
shells my require some of them to be quoted.

Example 1: combine files, sorting and eliminating duplicates:

\iconcode{
\ \ setmerge file1 + file2 + file3 + file4}

Example 2: print lines common to three files

\iconcode{
\ \ setmerge file1 {\textquotesingle}*{\textquotesingle} file2
{\textquotesingle}*{\textquotesingle} file3}

Example 3: print lines in file1 or file2 but not in file3

\iconcode{
\ \ setmerge file1 + file2 - file3 }

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shar
\ \texttt{\textmd{text\_file...}}\hfill (RJA)}}

\textsf{shar} creates Bourne shell archive of text files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shortest}}

\textsf{shortest} writes the (last) shortest line in the input file. If
the command-line option -\# is given, the number of the shortest line
is written first. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shuffile}}

\textsf{shuffile} writes a version of the input file with the lines
shuffled. For example, the result of shuffling 

\iconcode{
\>   \ \ \ \ \ \ \ On the Future!-how it tells \\
 \ \ \ \ \ \ \ \ \ Of the rapture that impells\\
 \ \ \ \ \ \ \ \ To the swinging and the ringing \\
 \ \ \ \ \ \ \ \ \ Of the bells, bells, bells-\\
 \ \ \ \ \ \ Of the bells, bells, bells, bells,\\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Bells, bells, bells-\\
 \ \ To the rhyming and the chiming of the bells!}

is

\iconcode{
\>   To the rhyming and the chiming of the bells!\\
 \ \ \ \ \ \ \ \ To the swinging and the ringing\\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Bells, bells, bells-\\
 \ \ \ \ \ \ \ \ \ Of the bells, bells, bells-\\
 \ \ \ \ \ \ \ \ \ On the Future!-how it tells\\
 \ \ \ \ \ \ Of the bells, bells, bells, bells,\\
 \ \ \ \ \ \ \ \ \ Of the rapture that impells}

The following options are supported:\\
\ \ \textsf{{}-s i}\ \ Set random seed to \textsf{i}; default 0\\
\ \ \textsf{{}-r}\ \ Set random seed using \textsf{randomize()};
overrides \textsf{{}-s}\\
This program stores the input file in memory and shuffles pointers to
the lines; there must be enough memory available to store the entire
file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sing \hfill (FJL)}}

\textsf{sing} is an Icon adaptation of a SNOBOL program by Mike Shapiro
in (Griswold71). The procedure \textsf{sing()} writes the lyrics to the
song, {\textquotedbl}The Twelve Days of Christmas{\textquotedbl} to a
parameter that can be any file open for output. It would be especially
nice to send the lyrics to a speech synthesizer (perhaps via a pipe).
The algorithm used can be adapted to other popular songs, such as
{\textquotedbl}Old McDonald had a Farm{\textquotedbl}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{snake
\ \texttt{\textmd{[character]}} \hfill (RLG)}}

While away the idle moments watching the snake eat blank squares on your
screen. \texttt{character} represents a single character to be used in
drawing the snake. The default is an
\textsf{{\textquotedbl}o{\textquotedbl}}. In order to run
\textsf{snake}, your terminal must have cursor movement capability, and
must be able to do reverse video. Bugs: Most magic cookie terminals
just won{\textquotesingle}t work. Terminal really needs reverse video.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{solit} \hfill (JN, PLT, REG)}}

\textsf{solit} was inspired by a solitaire game that was written and
copyrighted by Allyn Wade \ in 1985, designed for the IBM PC/XT/PCjr
with a color or monochrome monitor. This program has the correct escape
sequences programmed into it to handle several common terminals and
PC{\textquotesingle}s. It is commented well enough that most people can
modify the source to work for their hardware, or make the auto pilot
smarter. Note: The command-line argument, which defaults to support for
the VT100, determines the screen driver. For MS-DOS computers, the
ANSI.SYS driver is needed.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sortname}}

\textsf{sortname} sorts a list of person{\textquotesingle}s names by the
last names. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{splitlit}}

\textsf{splitlit} creates a string literal with continuations in case
it{\textquotesingle}s too long. Options:\\
\ \ \textsf{{}-w i}\ \ width of piece on line, default 50\\
\ \ \textsf{{}-i i}\ \  indent, default 3

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{streamer}}

\textsf{streamer} outputs one long line obtained by concatenating the
lines of the input file. The supported options are:\\
\ \ \textsf{{}-l i}\ \ stop when line reaches or exceeds i; default no
limit\\
\ \ \textsf{{}-s s}\ \ insert s after each line; default no
separator\\
Separators are counted in the length limit.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{strpsgml \ \textrm{\textmd{[-f}}\textmd{
}\textrm{\textmd{translation-file]}}\textmd{
}\textrm{\textmd{[left-delimiter}}\textmd{
}\textrm{\textmd{[right-delimiter]]}}}}

\textsf{strpsgml} strips or performs simple translation on
\index{SGML}SGML \texttt{{\textless}{\textgreater}}{}-style tags. The
default left-delimiter is \texttt{{\textless}}, the default right
delimiter is \texttt{{\textgreater}}. If no translation file is
specified, the program acts as a stripper, simply removing material
between the delimiters. \textsf{strpsgml} takes its input from standard
input and writes to standard output. The format of the translation file
is:

\iconcode{
\ code\ \ \ \ initialization\ \ completion }

A tab or colon separates the fields. If you want to use a tab or colon
as part of the text (and not as a separator), place a backslash before
it. The completion field is optional. There is not currently any way of
specifying a completion field without an initialization field. Do not
specify delimiters as part of code. Note that, if you are translating
SGML code into font change or escape sequences, you may get unexpected
results. This isn{\textquotesingle}t
\texttt{strpsgml}{\textquotesingle}s fault. It{\textquotesingle}s just
a matter of how your terminal or WP operate. Some need to be
{\textquotedbl}reminded{\textquotedbl} at the beginning of each line
what mode or font is being used. If you want to put a greater-than or
less-than sign into your text, put a backslash before it. This will
effectively {\textquotedbl}escape{\textquotedbl} the special meaning of
those symbols. It is possible to change the default delimiters, but the
option has not been thoroughly tested. (RLG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tablc}}

\textsf{tablc} tabulates characters and lists each character and the
number of times it occurs. Characters are written using
Icon{\textquotesingle}s escape conventions. Line termination and other
control characters are included in the tabulation. The following
options are available:\\
\ \ \textsf{{}-a}\ \ Write the summary in alphabetical order of the
characters. This is the default.\\
\ \ \textsf{{}-n}\ \ Write the summary in numerical order of the
counts.\\
\ \ \textsf{{}-u}\ \ Write only the characters that occur just once.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tablw}}

\textsf{tablw} tabulates words and lists number of times each word
occurs. A word is defined to be a string of consecutive upper- and
lowercase letters with at most one interior occurrence of a dash or
apostrophe. The following options are available:

\texttt{\ \ }\textsf{{}-a}\ \ Write the summary in alphabetical order of
the words. This is the default.\\
\ \ \textsf{{}-I}\ \ Ignore case distinctions among letters; uppercase
letters are mapped to corres-\\
\ \  \ \ ponding lowercase letters on input. The default is to maintain
case distinctions.\\
\ \ \textsf{{}-n}\ \ Write the summary in numerical order of the
counts.\\
\ \ \textsf{{}-l n}\ \ Tabulate only words longer than n characters. The
default tabulates all words.\\
\ \ \textsf{{}-u}\ \ Write only the words that occur just once.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{textcnt}}

\textsf{textcnt} tabulates the number of characters,
{\textquotedbl}words{\textquotedbl}, and lines in standard input and
gives the maximum and minimum line length. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{textcvt\hfill (RJA)}}

\textsf{textcvt} converts text file(s) among various
platforms{\textquotesingle} formats. The supported text file types are
UNIX, MS-DOS, and Macintosh. A universal input text reading algorithm
is used, so only the output file format must be specified. The files
are either converted in-place by converting to a temporary file and
copying the result back to the original, or are copied to a separate
new file, depending on the command line options. If the conversion is
interrupted, the temporary file might still remain as
{\textless}original name{\textgreater}.temp (or, for MS-DOS,
{\textless}original name root{\textgreater}.tmp.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{toktab}}

\textsf{toktab} reads the token files given on the command line and
summarizes them in a single file. The supported options are:\\
\ \ \textsf{{}-n}\ \ sort tokens by category in decreasing
\textit{numerical} order; default is alphabetical\\
\ \ \textsf{{}-l i}\ \ limit output in any category to i items; default
no limit

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{trim}}

\textsf{trim} copies lines from standard input to standard output,
truncating the lines at n characters and removing any trailing blanks.
The default value for n is 80. For example,

\iconcode{
\ \ trim 70 {\textless}grade.txt {\textgreater}grade.fix}

copies \textsf{grade.txt} to \textsf{grade.fix}, with lines longer than
70 characters truncated to 70 characters and the trailing blanks
removed from all lines. The \textsf{{}-f} option causes all lines to be
n characters long by adding blanks to short lines; otherwise, short
lines are left as is.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ttt\hfill (CT)}}

\textsf{ttt} plays the game of tic-tac-toe.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{turing\hfill (GMT)}}

\textsf{turing} simulates the operation of an n-state \index{Turing
machine}Turing machine, tracing all actions. The machine starts in
state 1 with an empty tape. A description of the Turing machine is read
from the file given as a command-line argument, or from standard input
if none is specified. Comment lines beginning with
{\textquotesingle}\#{\textquotesingle} are allowed, as are empty lines.
The program states must be numbered from 1 and must appear in order.
Each appears on a single line in this form:

\iconcode{
\>   sss. wdnnn wdnnn}

\texttt{sss} is the state number in decimal. The \texttt{wdnnn} fields
specify the action to be taken on reading a 0 or 1 respectively:
\texttt{w} is the digit to write (0 or 1), \texttt{d} is the direction
to move (L/l/R/r, or H/h to halt), \texttt{nnn} is the next state
number (0 if halting).

Sample input file:

\iconcode{
1. 1r2 1l3}

\iconcode{
2. 1l1 1r2}

\iconcode{
3. 1l2 1h0}

One line is written for each cycle giving the cycle number, current
state, and an image of that portion of the tape that has been visited
so far. The current position is indicated by reverse video (using ANSI
terminal escape sequences). Input errors are reported to standard error
output and inhibit execution. Bugs: Transitions to nonexistent states
are not detected. Reverse video should be parameterizable or at least
optional. There is no way to limit the number of cycles. Infinite loops
are not detected. (Left as an exercise...\texttt{:-)} Reference:
Scientific American, August 1984, pp. 19-23. A. K.
Dewdney{\textquotesingle}s discussion of {\textquotedbl}busy
beaver{\textquotedbl} Turing machines in his {\textquotedbl}Computer
Recreations{\textquotedbl} column motivated this program. The sample
above is the three-state busy beaver.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unique\hfill (AVH, RJA)}}

\textsf{unique} filters out (deletes) identical adjacent lines in a
file. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unpack}}

\textsf{unpack} unpackages files produced by \textsf{pack.icn}. See that
program for limitations. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{upper}}

\textsf{upper} maps the names of all files in the current directory to
uppercase. Requires: UNIX. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{verse\hfill (CT)}}

This \index{verse}verse maker was initially published in an early 1980s
Byte magazine in TRS80 Basic. It fetches the vocabulary from a
vocabulary file specified on the command line; it looks for
\textsf{verse.dat} by default. See that file for examples of form. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{versum}}

\textsf{versum} writes the versum sequence for an integer to a file of a
specified name. If such a file exists, it picks up where it left off,
appending new values to the file. The supported options are:\\
\texttt{\ \ }\textsf{{}-s i}\ \ The seed for the sequence, default
196\\
\ \ \textsf{{}-f s}\ \ Name of file to extend, no default\\
\ \ \textsf{{}-F s}\ \ Name of file, default
{\textless}i{\textgreater}.vsq, where {\textless}i{\textgreater} is the
seed of the sequence\\
\ \ \textsf{{}-t i}\ \ The number of steps to carry the sequence out to,
default unlimited\\
\ \ \textsf{{}-m i}\ \ Stop when value equals or exceeds m; default no
limit\\
If both \texttt{{}-f} and \texttt{{}-F} are given, \texttt{{}-f}
overrides.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{webimage}}

\textsf{webimage} takes the names of image files on the command line and
writes a Web page that embeds each image. Requires: Version 9 graphics.
The following options are supported:\\
\ \ \textsf{{}-a s}\ \ alignment, default
{\textquotedbl}bottom{\textquotedbl}\\
\ \ \textsf{{}-t s}\ \ title for page; default
{\textquotedbl}untitled{\textquotedbl}\\
\ \ \textsf{{}-n}\ \ include file names; default no names

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{what \hfill (PLT)}}

\textsf{what} writes all strings beginning with
{\textquotedbl}@{\textquotedbl} followed by
{\textquotedbl}(\#){\textquotedbl} and ending with null, newline,
quotes, greater-than or backslash. Follows UNIX \textsf{what(1)}
conventions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{when\hfill (CT)}}

\textsf{when} is like a date based \textsf{ls} command. UNIX
\textsf{find} can do the same things, but \textsf{find} is a bit
arcane, so \textsf{when} provides a simpler alternative. Here are some
samples:

\iconcode{
when before 4/12/92 \# files before a date}

\iconcode{
when before 300 \# files older than an age}

\iconcode{
when after 3/25 \# or younger than a date this year}

\iconcode{
when before 2/1/94 and after 10/31/93 \# even a range}

More options and clauses are supported. Look at the code for clues. This
one only works in the current directory. Requires: UNIX.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xtable\hfill (RJA, AB)}}

\textsf{xtable} prints various character translation tables. See
procedure \textsf{help()} for the capabilities.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{yahtz\hfill (CT, RLG, PLT)}}

This classic dice game will run under UNIX and under DOS as well. It
should run out of the box on DOS as long as you stay in the current
directory. See the README file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{zipsort}}

\textsf{zipsort} sorts labels produced by labels in ascending order of
their postal zip codes. Option: The option \textsf{{}-d n} sets the
number of lines per label to n. The default is 9. This value must agree
with the value used to format the labels. Zip Codes: The zip code must
be the last nonblank string at the end of the label. It must consist of
digits but may have an embedded dash for extended zip codes. If a label
does not end with a legal zip code, it is placed after all labels with
legal zip codes. In such a case, an error message is written to
standard error output. See also: \textsf{labels.icn}.

\subsection{Selected IPL Authors and Contributors}

This Appendix presents the work of the following authors and
contributors of Icon Program Library modules and programs. Ralph
Griswold deserves primary credit for initiating and maintaining the
collection. To a great extent, the various authors{\textquotesingle}
code is described in their own words, from the public domain
documentation they have written about it. We would like to acknowledge
their contribution to the Icon community and to this book. Any errors
that remain in this Appendix are solely our responsibility, and we
apologize for them.


\bigskip

Paul Abrahams\ \ \ \ Robert J. Alexander\ \ \ \ Allan J. Anderson

Norman Azadian\ \ \ \ Alan Beale\ \ \ \ \ \ Phil Bewig

Peter A. Bigot\ \ \ \ \ \ David S. Cargo\ \ \ \ Alex Cecil

Alan D. Corre\ \ \ \ \ \ Cary A. Coutant\ \ \ \ William E. Drissel

Erik Eid\ \ \ \ \ \ Ronald Florence\ \ \ \ David A. Gamey

Michael Glass\ \ \ \ \ \ Richard L. Goerwitz\ \ \ \ Ralph E. Griswold

Matthias Heesch\ \ \ \ Charles Hethcoat\ \ \ \ Anthony V. Hewitt

Thomas R. Hicks\ \ \ \ Clinton L. Jeffery\ \ \ \ Jere K?pyaho

Justin Kolb\ \ \ \ \ \ Tim Korb\ \ \ \ \ \ Frank J. Lhota

Nevin J. Liber\ \ \ \ \ \ William P. Malloy\ \ \ \ C. Scott McArthur

Will Menagarini\ \ \ \ Joe van Meter\ \ \ \ \ \ William H. Mitchell

Rich Morin\ \ \ \ \ \ Jerry Nowlin\ \ \ \ \ \ Mark Otto

Robert Parlett\ \ \ \ \ \ Jan P. de Ruiter\ \ \ \ Randal L. Schwartz

Charles Shartsis\ \ \ \ David J. Slate\ \ \ \ \ \ John D. Stone

Chris Tenaglia\ \ \ \ Phillip L. Thomas\ \ \ \ Gregg M. Townsend

Kenneth Walker\ \ \ \ Stephen B. Wampler\ \ \ \ Beth Weiss

Robert C. Wieland\ \ \ \ Cheyenne Wills\ \ \ \ David Yost

