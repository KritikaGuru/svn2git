
#
# breakpoint.icn
# It handles UDB's breakpoints related tasks
# Author: Ziad Al-Sharif
# Date:   7-15-2008
#

$include "evdefs.icn"
$include "defaults.icn"

#
# For every file that has a breakpoint
# we will create a new breakPt in a list inside a table.
#
record breakPt(
   id,    # a unique identification number
   fname, # The file name that has the breakpoint
   line,  # The exact line number where the breakpoint is
   code   # a copy of the actual source code of that line
   )

class BreakPoint(
   DState,       # (Alias) object of type State class
   breakPoints,  # A table maps files to their list of breakpoints 
   count,        # An integer counts the total number of breakpoints
   msg           # a string with latest message from this class 
   )

#
# Check the Monitored file for a breakpoint
#
method checkBreakPoint()
   local  cur_file, cur_line, L, x, id

   cur_file := keyword("file", Monitored)
   if member(breakPoints, cur_file) then{
      cur_line := keyword("line", Monitored)
      L := breakPoints[cur_file]
      every x := !L do
         if cur_line = x.line & id:=isBreakExist(cur_file,cur_line) then{
            DState.State := PAUSE
            # this delete will help "next" and "step" operate well
            # jut remove the the breakMask set from the valueMask 
            # table temporarly until the continue command comes on
            delete(DState.valueMask,E_Line) 
            msg   :="\n   Breakpoint #"||id||" at : "||
                    cur_file||":"||cur_line||"."
            msg ||:="\n   "||cur_line||":"|| #???"\nb->"
                    DState.srcFile.getSrcLine(cur_file, cur_line) 
            DState.Write(msg)
            return
            }
      }
end

#
# prints out a list of the existing breakpoints used by cmdBreak
#
method printBreakPoints(fname)
   local x, L, bp

   msg := ""
   if /fname then{
      every x := key(breakPoints) do {
         L := breakPoints[x]
         every bp := !L do
            msg ||:= "\n   Breakpoint #"|| bp.id||" at : file "||bp.fname||
                     ", line "||bp.line||". Source code"||" : "||bp.code
         }
      }
   else{
      L := breakPoints[fname]
      every bp := !L do
         msg ||:= "\n   Breakpoint #"||bp.id||" at : file "||bp.fname||
                  ", line "||bp.line||". Source code"||" : "||bp.code
      }
   DState.Write(msg)
end

#
# check to see whether a breakpoint is pre-exist or not
#
method isBreakExist(fname, line)
   local L, bp

   if member(breakPoints, fname) then {
      L := breakPoints[fname]
      every bp := !L do
         if bp.line = line then
            return bp.id
      }
   fail
end

#
# used to add a new breakpoint into the 
# breakPoints table and the breakMask set
#
method addBreakPoint(fname, bp)
   
   if member(breakPoints,fname) then
      put(breakPoints[fname], bp)
   else
      breakPoints[fname] := [bp]

   insert(DState.breakMask,bp.line)
end

#
# used it clear breakpoints, is used by cmdClear()
#
method deleteBreakPoint(fname, line)
   local L, x, i
   
   L := breakPoints[fname]
   every i := 1 to *L do{
      x := L[i]
      if x.line = line then
         delete(L,i)
      } 
   if *L = 0 then
      delete(breakPoints, fname)

   delete(DState.breakMask,line)
end

#
# Sets Breakpoints on line numbers or procedure names
# [b linenum], [b ProcName], [b file linenum]
#
method cmdBreak(cmd)
   local code, line, fname, arg, break_point, i

   msg := ""
   if not (DState.State = (LOAD | PAUSE)) then {
      DState.State := ERROR
      msg := "\n   No Program is Loaded_
              \n   Type \"help\" for assistance"
      DState.Write(msg)
      return
      }
   DState.State := SKIP

   # if cmd is only "break"; will print all of the preset breakpoints info
   if *cmd = 1 then{
      printBreakPoints()
      return
      } 
 
   if *cmd = 2 then {
      fname := DState.srcFile.procMainFile #exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then {
      fname := cmd[2]
      arg   := cmd[3]
      }

   #fname := addExtension(fname)
   if not find(".icn", fname) then
      fname ||:= ".icn"

   if DState.srcFile.isLoaded(fname) then{
      if line := integer(arg) then{
         if DState.srcFile.isInFile(fname, line) then{
            if code := DState.srcFile.searchFileLines(fname, line) then{
               break_point := breakPt(count +:= 1, fname, line, code)
               }
            else{
               msg := "\n   Line number was not found,_
                       \n   Please try a different line number"
               DState.Write(msg)
               return
               }
            }
         else{
            msg := "\n   Line number "||line||" out of range; "||fname||
                   " has "||DState.srcFile.getFileTotalLines(fname)||" lines." 
            DState.Write(msg)
            return
            }
         }
      else{
         if line := DState.srcFile.searchFileProcs(fname, arg) then
            break_point := breakPt(count +:= 1, fname,line,
                                   DState.srcFile.getSrcLine(fname, line))
         else{
            msg := "\n   Procedure not found_
                    \n   Make sure the procedure/method name is correct!"
            DState.Write(msg)
            return
            }
         } 
      }      
   else{
      msg := "\n   Source file \""||fname||"\" is not loaded !!!"
      if line := integer(arg) then
         break_point := breakPt(count +:= 1, fname , line, "?")
      }
      
   # record breakPt(fname, linenum, code)
   line := break_point.line
   if isBreakExist(fname, line) then{
      msg ||:= "\n   The breakpoint is already exist,_
                \n   Type \"break\" to see all breakpoints"
      }
   else{
      addBreakPoint(fname, break_point)
      msg ||:= "\n   Breakpoint #"||
                break_point.id||" at : file "||fname||", line "||line||"."||
               "\n   Source code:"||DState.srcFile.getSrcLine(fname, line) 
      } 
   DState.Write(msg)
end

#
# It clears pre-set breakpoints
#
method cmdClear(cmd)
   local line, x, fname, arg, id, i

   # clears all of the preset breakpoints
   if *cmd = 1 then{
      DState.breakMask := set()
      every x := key(breakPoints) do
          delete(breakPoints, x)
      msg := "\n   All breakpoints are deleted."
      DState.Write(msg)
      return
      }

   if *cmd = 2 then{
      fname := DState.srcFile.procMainFile #exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then{
      fname := cmd[2]
      arg   := cmd[3]
      }

   #fname := addExtension(fname)
   if not find(".icn", fname) then
      fname ||:= ".icn"

   if line := integer(arg) then{
      if id := isBreakExist(fname, line) then{
         deleteBreakPoint(fname, line)
         msg  :="\n   Deleted breakpoint #"||id||" at : file "||fname||
                ", line "||line ||"."
         msg||:="\n   Source code:"||DState.srcFile.getSrcLine(fname, line)
         }
      else{
         msg  :="\n   No breakpoint at : file "||fname||", line "||line ||"."
         msg||:="\n   Source code: "||DState.srcFile.getSrcLine(fname, line)
         }
      }
   else{ 
      if line := DState.srcFile.searchFileProcs(fname, arg) then{
         if id := isBreakExist(fname, line) then{
            deleteBreakPoint(fname,line)
            msg  :="\n   Deleted breakpoint #"||id||" at : file "||fname||
                   ", line "||line ||"."
            msg||:="\n   Source code:"||DState.srcFile.getSrcLine(fname, line)
            }
         else{
            msg  :="\n   No breakpoint at : file "||fname||", line "||line||"."
            msg||:="\n   Source code : "||DState.srcFile.getSrcLine(fname, line)
            }
         }
      else{
         msg := "\n   Procedure not found_
                 \n   Make sure the method name is correct!"
         }
      }
   DState.Write(msg)
end

#
# Initialization
#
initially()
   
   breakPoints := table(0)
   count := 0
   msg :="\n   "
end
