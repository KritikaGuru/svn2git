
#
# breakpoint.icn
# It handles UDB's break points related tasks
# Author: Ziad Al-Sharif
# Date:   7-15-2008
#

$include "evdefs.icn"
$include "defaults.icn"

#
# For every file that has a break point
# we will create a new breakPt in a list inside a table.
#
record breakPt(
   id,    # a unique identification number
   fname, # The file name that has the break point
   line,  # The exact line number where the breakpoint is
   code   # a copy of the actual source code of that line
   )

class BreakPoint(
   DState,       # (Alias) object of type State class
   breakPoints,  # A table maps files to their list of break points 
   count,        # An integer counts the total number of break points
   msg           # a string with latest message from this class 
   )

#
# Check the Monitored file for a break point
#
method checkBreakPoint()
   local  cur_file, cur_line, L, x

   cur_file := keyword("file", Monitored)
   if member(breakPoints, cur_file) then{
      cur_line := keyword("line", Monitored)
      L := breakPoints[cur_file]
      every x := !L do
         if cur_line = x.line then{
            DState.State := PAUSE
            # this delete will help "next" and "step" operate well
            # jut remove the the breakMask set from the valueMask 
            # table temporarly until the continue command comes on
            delete(DState.valueMask,E_Line) 
            msg   :="\n\tBreak point:\n\t"||cur_file||"("||cur_line||"): "
            msg ||:= DState.srcFile.getSrcLine(cur_file, cur_line) 
            DState.Write(msg)
            return
            }
      }
end

#
# prints out a list of the existing break points used by cmdBreak
#
method printBreakPoints(fname)
   local x, L, bp

   msg := "\n\t "
   if /fname then{
      every x := key(breakPoints) do {
         L := breakPoints[x]
         every bp := !L do
            msg ||:= "\n\t "|| bp.id||"#  "|| bp.fname ||
                     "(" || bp.line ||")"|| ": " || bp.code
         }
      }
   else{
      L := breakPoints[fname]
      every bp := !L do
         msg ||:= "\n\t "|| bp.id||"#  "|| bp.fname ||
                  "(" || bp.line ||")"|| ": " || bp.code
      }
   DState.Write(msg)
end

#
# check to see whether a break point is pre-exist or not
#
method isBreakExist(fname, line)
   local L, bp

   if member(breakPoints, fname) then {
      L := breakPoints[fname]
      every bp := !L do
         if bp.line = line then
            return
      }
   fail
end

#
# used to add a new break point into the 
# breakPoints table and the breakMask set
#
method addBreakPoint(fname, bp)
   
   if member(breakPoints,fname) then
      put(breakPoints[fname], bp)
   else
      breakPoints[fname] := [bp]

   insert(DState.breakMask,bp.line)
end

#
# used it clear break points, is used by cmdClear()
#
method deleteBreakPoint(fname, line)
   local L, x, i
   
   L := breakPoints[fname]
   every i := 1 to *L do{
      x := L[i]
      if x.line = line then
         delete(L,i)
      } 
   if *L = 0 then
      delete(breakPoints, fname)

   delete(DState.breakMask,line)
end

#
# Sets Break points on line numbers or procedure names
# [b linenum], [b ProcName], [b file linenum]
#
method cmdBreak(cmd)
   local code, line, fname, arg, break_point

   msg := ""
   if not (DState.State = (LOAD | PAUSE)) then {
      DState.State := ERROR
      msg := "\n\t No Program is Loaded_
              \n\t Type \"help\" for assistance"
      DState.Write(msg)
      return
      }
   DState.State := SKIP

   # if cmd is only "break"; will print all of the preset breakpoints info
   if *cmd = 1 then{
      printBreakPoints()
      return
      } 
 
   if *cmd = 2 then {
      fname := DState.srcFile.exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then {
      fname := cmd[2]
      arg   := cmd[3]
      }

   #fname := addExtension(fname)
   if not find(".icn", fname) then
      fname ||:= ".icn"

   if DState.srcFile.isLoaded(fname) then{
      if line := integer(arg) then{
         if DState.srcFile.isInFile(fname, line) then{
            if code := DState.srcFile.searchFileLines(fname, line) then{
               break_point := breakPt(count +:=1, fname, line, code)
               }
            else{
               msg := "\n\t Line number was not found,_
                       \n\t Please try a different line number"
               DState.Write(msg)
               return
               }
            }
         else{
            msg := "\n\t Line number is not within the \""||fname||"\""
            DState.Write(msg)
            return
            }
         }
      else{
         if line := DState.srcFile.searchFileProcs(fname, arg) then
            break_point := breakPt(count +:=1, fname,line,
                                   DState.srcFile.getSrcLine(fname, line))
         else{
            msg := "\n\t Procedure not found_
                    \n\t Make sure the method name is correct!"
            DState.Write(msg)
            return
            }
         } 
      }      
   else{
      msg := "\n\t Source File \""||fname||"\" is not loaded !!!"
      if line := integer(arg) then
         break_point := breakPt(count +:=1, fname , line, "?")
      }
      
   # record breakPt(fname, linenum, code)
   line := break_point.line
   if isBreakExist(fname, line) then
      msg ||:= "\n\t The break point is already exist,_
                \n\t Type \"break\" to see all breakpoints"
   else{
      addBreakPoint(fname, break_point)
      msg ||:= "\n\t Breakpoint set successfully in:\n\t "||
                break_point.id||"#  "||fname ||"("||line||"): " ||
                DState.srcFile.getSrcLine(fname, line) 
      } 
   DState.Write(msg)
end

#
# It clears pre-set break points
#
method cmdClear(cmd)
   local line, x, fname, arg

   # clears all of the preset break points
   if *cmd = 1 then{
      DState.breakMask := set()
      every x := key(breakPoints) do
          delete(breakPoints, x)
      msg := "\n\t All break points are cleared!!!"
      DState.Write(msg)
      return
      }

   if *cmd = 2 then{
      fname := DState.srcFile.exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then{
      fname := cmd[2]
      arg   := cmd[3]
      }

   #fname := addExtension(fname)
   if not find(".icn", fname) then
      fname ||:= ".icn"

   if line := integer(arg) then{
      if isBreakExist(fname, line) then{
         deleteBreakPoint(fname, line)
         msg := "\n\t The break point is cleared at :\n\t "||fname||
                "("||line ||"): "||DState.srcFile.getSrcLine(fname, line)
         }
      else
         msg := "\n\t There is no break point at : \n\t "||fname||
                "("||line ||"): "||DState.srcFile.getSrcLine(fname, line)
      }
   else{ 
      if line := DState.srcFile.searchFileProcs(fname, arg) then{
         if isBreakExist(fname, line) then{
            deleteBreakPoint(fname,line)
            msg := "\n\t The break point is cleared at :\n\t "||fname||
                   "("||line ||"): "||DState.srcFile.getSrcLine(fname, line)
            }
         else
            msg := "\n\t There is no break point at : \n\t "||fname||
                   "("||line ||"): "||DState.srcFile.getSrcLine(fname, line)
         }
      else
         msg := "\n\t Procedure not found_
                 \n\t Make sure the method name is correct!"
      }
   DState.Write(msg)
end


initially()
   
   breakPoints := table(0)
   count := 0
   msg :="\n\t "
end
