
#
# data.icn
# Handles the print debugging faclities found in debuggers such as GDB
# Author  : Ziad Al-Sharif
# Date    : Feb 24, 2008
#

$include "evdefs.icn"
$include "defaults.icn"

#
# This class contains the classical/standard debugging techniqies
#
class Data(
   DState,  # (Alias) object of type State class
   Keywords,# a set of the valid unicon keywords used in UDB
   Message  # a string formated with the current message
   )

#
# prints out all of the Global Variables state in some level
#
method printGlobals(level)
   local x, i
        
   /level := DState.cur_Frame # 0 if no up/down involved
   
   Message := ""
   every x := !DState.global_vars do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# prints out all of the Local Variables for some Level  
#
method printLocals(level)
   local x, i

   /level := DState.cur_Frame # 0 if no up/down involved

   Message := ""
   every x := localnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# prints out all of the Formal Parameters for some Level  
#
method printParams(level)
   local x, i

   /level := DState.cur_Frame # 0 if no up/down involved

   Message := ""
   every x := paramnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# returns the expression value or fails
# used by cmdPrint() and assignVar()  
#
method getVarValue(expr, level)
   local Value, ref, var, Var, index:=[]

   index := parsePrintExpression(expr)
   if *index = 0 then fail

   var := get(index)
   if Var := variable(var, Monitored, level) then{
      if (ref := getVarReference(Var, index, level)) & *index = 0 then{
         Value := if integer(ref) = ref then integer(ref) 
                  else if real(ref) = ref then real(ref)
                  else ref
         return Value
         }
      else fail 
      }
   else{
      if *index = 0 then{
         Value := if integer(expr) = expr then integer(expr) 
                  else if real(expr) = expr then real(expr)
                  else string(expr)
         return Value
         }
      else fail 
      } 
   return Value
end


#
# getVarReference is used by printVar and cmdPrint to 
# get a reference for an element of a structure
#
method getVarReference(Var, index, level)
   local v, j, i1, i2, x, fld

   if *index = 0 then return Var

   case type(Var) of{
      "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
      "procedure"|"co-expression"|"external":{
           return Var
           }
      "string":{
           x := get(index)
           if j := find(":",x) then{
              i1 := integer(x[1:j])
              i2 := integer(x[j+1:0])
              Var := Var[i1:i2]
              return Var
              }
           else if v := variable(x, Monitored, level, 1) | integer(x) then{
              Var := Var[v]
              return Var
              }
           fail
           }
      "list":{
           x := get(index)
           if v := variable(x, Monitored, level, 1) | integer(x) then{
              if type(v) == "integer" & member(Var, v) then{
                 Var := Var[v]
                 return getVarReference(Var, index, level)
                 }
              }
           fail
           }
      "table":{
           x := get(index)
           if v := variable(x, Monitored, level, 1) |
                                      integer(x) | string(x[2:-1]) then{
              if member(Var, v) then{
                 Var := Var[v]
                 return getVarReference(Var, index, level)
                 }
               } 
           fail
           }
      # "record" & "object" do not have the word "record" in their type
      default:{
           x := get(index)
           every fld := fieldnames(Var) do{
              if x === fld then{
                 Var := Var[string(x)]
                 return getVarReference(Var, index, level)
                 }
              }
           fail
           }
      }
end

#
# setVarReference is used by assignVar() and cmdPrint()
# to assign a value to any variable or element of a structure
#
method setVarReference(lvar, index, level, value)
   local v, j, i1, i2, x, fld, Var

   DState.Write("value = ",value)

   if *index = 0 then{
      if variable(lvar, Monitored, level) then{
         variable(lvar, Monitored, level, 1) := value
         return
         }
      else fail
      } 
   
   Var := variable(lvar, Monitored, level, 1)
   if \Var then{
      if *index ~= 0 then{
      while *index > 0 do{
      x := get(index)
      case type(Var) of{
        "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
        "procedure"|"co-expression"|"external":{
           if *index = 0 then{
              #variable(lvar, Monitored, level, 1) := value 
              Var := value
              return 
              } 
           else fail
           }
        "string":{
           if *index = 0 then{
              if j := find(":",x) then{
                 # what if either of i1 or i2 were variables??
                 i1 := integer(x[1:j])
                 i2 := integer(x[j+1:0])
                 variable(lvar, Monitored, level, 1) := 
                          Var[1:i1]|| string(value) ||Var[i2:0]
                 }
              else if v := variable(x, Monitored, level, 1) | integer(x) then{
                    variable(lvar, Monitored, level, 1) := 
                             Var[1:v]||string(value) || Var[v+1:0]
                 } 
              return
              }
           else{
              fail
              }
           }
        "list":{
           if v := variable(x, Monitored, level, 1) | integer(x) then{
              if type(v) == "integer" & member(Var, v) then{
                 if *index = 0 then{
                    Var[v] := value
                    return
                    } 
                 else Var := Var[v]
                 }
              else fail
              }
           else fail
           }
        "table":{
           if v := variable(x, Monitored, level, 1) |
                                      integer(x) | string(x[2:-1]) then{
              if member(Var, v) then{
                 if *index = 0 then{
                    Var[v] := value
                    return
                    }
                 else Var := Var[v]
                 }
              else fail
              } 
           else fail
           }
        # "record" & "object" do not have the word "record" in their type
        default:{
           every fld := fieldnames(Var) do{
              if x === fld then{
                 if *index = 0 then{
                    Var[string(x)]:= value
                    return 
                    }
                 else{
                    Var := Var[string(x)]
                    break
                    } 
                 }
              }#end every 
           }#end default 
      }#end case
      }#end while
      }#end if *index ~= 0 then
      else{
         variable(lvar, Monitored, level, 1) := value
         DState.Write("hmmmm!!!!")
         return
         }
      }
   else fail
end

#
# finds the var reference and prints its value acording
# to the action such as */! or the value itself
#
method printVar(expr, level)
   local Var, var, index
   local x, j, action, ref

   if j:=find("*"|"!",expr) then{
      action := expr[j]
      expr := expr[j+1:0]
      }

   index := parsePrintExpression(expr)
   if *index = 0 then{
      Message :="\n   \""||expr||"\" is Unkown Expression !!!"
      DState.Write(Message)
      return
      }
   
   var := get(index)
   if Var := variable(var, Monitored, level) then
      if (ref := getVarReference(Var, index, level)) & *index = 0 then{
         Message := "\n   " || expr || " = "
         case action of{
            "*" :{ Message ||:= *ref }
            "!" :{ Message ||:="{ "
                   every x := !ref do
                      Message ||:= image(x)||", "
                   Message:=Message[1:-2] || " }"
                 }
             default:{
                 #DState.Write("---type of ",expr," is : ", type(ref))
                 if (type(ref) == ("list" | "table" | "set" | "foreign-local" )|
                     find("record",image(ref))) & *ref > 1 then
                        Message ||:= ximage(ref)
                 else{
                        Message ||:= image(ref)
                        #Message ||:= "\n   ..................!"
                     }
                 }
             }
         }
      else Message :="\n   \""||expr||"\" is Unkown Expression !!!"
   else Message := "\n   The variable \""|| var ||
                   "\" is not within the current frame"
   DState.Write(Message)
end

#
# changes the var value according to the user input
#
method assignVar(expr, level)
   local j, lexpr, rexpr, lhs, lvar , rvalue

   if j := find(":=", expr) then{
       lexpr := expr[1:j]
       rexpr := expr[j+2:0]
       }
   else if j := find("=", expr) then{
       lexpr := expr[1:j]
       rexpr := expr[j+1:0]
       }

   lhs := parsePrintExpression(lexpr)
   if *lhs = 0 then{
      Message :="\n   The expression \""||expr||"\" is Unkown !!!"
      DState.Write(Message)
      return
      }

   if rvalue := getVarValue(rexpr, level) then{
      lvar := get(lhs)
      if setVarReference(lvar, lhs, level, rvalue) then
         Message :="\n   Assigning \""||lexpr||"\" with \""||
                    rexpr||"\" has been succeeded"
      else
         Message :="\n   Assigning \""||lexpr||"\" with \""||
                    rexpr||"\" has been failed"
      }
   else 
      Message := "\n   The RHS expr \""||rexpr||"\" is Unknown !!!"

   DState.Write(Message)
end

#
# Prints out a variable and it's current value. Variables from previous
# procedures that are still in the stack can also be viewed.
#
method cmdPrint(cmd)
   local level, expr, i

   if DState.State ~= PAUSE then{
      DState.State := ERROR
      Message := "\n   The program is not being run._
                  \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(Message)
      return
      }

   if cmd[3] then  level := integer(cmd[3]) | 0 
   else            level := DState.cur_Frame 
      
   if \cmd[2] & expr := cmd[2] then{
      if expr == ("-g" |"-G" | "-globals") then{
         printGlobals()
         return
         }
      else if expr == ("-l" | "-L" | "-locals") then{
         printLocals()
         return
         }
      else if expr == ("-p" | "-P" | "-params") then{
         printParams()
         return
         }
      else if i := find("&", expr) then{ # keywords
         handleKeyword(expr, i, level)
         }
      else
         if find("=", expr) then assignVar(expr, level)
         else                    printVar(expr, level)
      }
   else{
      #printFrame(level)
      write("OPSSSSS")
      #Message := ""
      }
end

#
# handles keywords in the print expression
#
method handleKeyword(expr, i, level)
   local lexpr, rexpr, data, j

   if j := find(":=",expr) then{ # p &pos:=10
      lexpr := expr[i:j]
      rexpr := expr[j+2:0]
      if validKeyword(lexpr[2:0]) then{
         data := getVarValue(rexpr,level)
         variable(lexpr, Monitored, 0, 1) := data 
         return
         }
      else{
         Message := "\n   "||lexpr ||" : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
   else if j := find("=", expr) then{ # p &pos=10
      lexpr := expr[i:j]
      rexpr := expr[j+1:0]
      if validKeyword(lexpr[2:0]) then{
         data := getVarValue(rexpr,level)
         variable(lexpr, Monitored, 0, 1) := data
         return
         }
      else{
         Message := "\n   "||lexpr ||" : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
   else{ # p &pos 
      if validKeyword(expr[2:0]) then{
         data := keyword(expr, Monitored)
         if not (type(data) == ("string"|"integer"|"real")) then
            data := image(data)
         Message :="\n   "|| expr ||" = "|| data
         DState.Write(Message)
         return
         }
      else{
         Message :="\n   "|| expr || " : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
end

#
# check whether keyword is valid or not  
#
method validKeyword(expr)

   if member(Keywords, expr) then 
      return 
   fail
end

#
# parse the expression into tokens, mainVar is tokens[1]
# ie L[2], L[3][4], L[1].x, S[5:-5]
#
method parsePrintExpression(expr)
   local x, old_x, j, valid_char, tokens := []
   
   valid_char := CHARACTER ++ cset('-_:\"') 
   
   expr ? {
        if x := tab(many(valid_char)) then{
           put(tokens, x)
           while (j := move(1)) ==("["|"]"|"."|",") do{
               if j == "." & old_x := integer(x) then{
                 if x := tab(many(valid_char)) then{
                    if integer(x) then{
                       old_x := pop(tokens)
                       old_x ||:="."||x
                       put(tokens, old_x)
                       old_x := &null
                       }
                    else 
                       put(tokens,x)
                    } 
                 }
              else if x := tab(many(valid_char)) then
                    put(tokens,x)
              }
           } 
        }

#   every x:=!tokens do
#      write("-----x=",x)
   return tokens
end

#
# used by cmdList to print a bunch of src lines
#
method printSrcLines(cur_file, cur_line, offset)
   local i, line, max_line

   /offset := 10
   max_line := DState.srcFile.getFileTotalLines(cur_file)

   if cur_line <= 5 then
      line := 1
   else if cur_line <= max_line then
      line := cur_line - 5
   else if cur_line > max_line then{
      Message := "\n   Line number "||cur_line||" out of range; "||
                  cur_file||" has "||max_line||" lines."
      DState.Write(Message)
      fail
      }

   Message :="" 
   every i:= 1 to offset do{
      if line = cur_line then
         Message ||:="\n-->"||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      else
         Message ||:="\n   "||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      line +:= 1
      }
   DState.Write(Message)
end

#
# The list command from gdb, as in gdb defaults are 10 lines from
# the current file are printed centered around the curent line 
#
method cmdList(cmd)
   static cur_line, cur_file, max_line
   local name, line
   
   if DState.RunCode ~= LIST then{
      DState.RunCode := LIST
      if DState.State = LOAD then{
         cur_file := DState.srcFile.procMainFile
         cur_line := DState.srcFile.procMainLine
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         } 
      else if DState.State = PAUSE then{
         cur_file := keyword("file", Monitored)
         cur_line := keyword("line", Monitored)
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         }
      else{
         DState.RunCode := DState.State := ERROR
         Message := "\n   No Program is Loaded nor Running_
                     \n   Type \"help\" for assistance"
         DState.Write(Message)
         return
         }
      }
   else if *cmd = 1 then{
      if (cur_line + 10) < max_line then  cur_line +:= 10
      else if cur_line < max_line   then  cur_line := max_line
      else if cur_line = max_line   then  cur_line := max_line + 1
      }

   if *cmd >= 2 then{
      if line := integer(cmd[2]) then{
         if line > 0 then 
            cur_line := line
         else if line < 0 then{
            cur_line := max_line + line
            }
         }
      else if cmd[2] == "+" then{
         if (cur_line + 10) < max_line then  cur_line +:= 10
         else if cur_line < max_line   then  cur_line := max_line
         else if cur_line = max_line   then  cur_line := max_line + 1
         }
      else if cmd[2] == "-" then{
         if (cur_line - 10) >= 1 then  cur_line -:= 10
         else                          cur_line := 1
         }
      else{
         name := cmd[2]
         if line := DState.srcFile.searchFileProcs(cur_file, name) then{
            cur_line := line
            }
         else{
            name ||:=".icn"          
            if DState.srcFile.isSrcFile(name) then{
               cur_file := name
               max_line := DState.srcFile.getFileTotalLines(cur_file)
               if *cmd = 2 then
                  cur_line := 1
               else if line := integer(cmd[3]) then{
                  if line > 0 then
                     cur_line := line
                  else if line < 0 then
                     cur_line := max_line
                  }
               }
            else{
               DState.RunCode := DState.State := ERROR
               Message  := "\n   "||name||" is not a source file in: \""||
                           DState.TP[1]||"\"."
               Message||:= "\n   Try \"src\", or Type \"help\" for assistance."
               DState.Write(Message)
               return
               } 
            }
         }
      }

   if DState.srcFile.isLoaded(cur_file) then{
      printSrcLines(cur_file, cur_line)
      }
   else{
      Message := "\n   Source File \""||cur_file||"\" is NOT loaded !!!"
      DState.Write(Message)
      }
end

#
# prints the found/missing source files
#
method cmdSource(cmd)
   local op, files

   if cmd[3] then{
      Message := DState.srcFile.getSrcCode(cmd[3])
      DState.Write(Message)
      return
      }

   op := cmd[2] | ""
   case op of{
      "-f" | "-found":{
           if files := DState.srcFile.getFoundFiles() then{
              Message := "\n    Found Source Files are:\n   "
              Message ||:= files
              }
           else
              Message := "\   nNo file(s) found !!"
           }
      "-m" | "-missing":{
           if files := DState.srcFile.getMissingFiles() then{
              Message   := "\n   Missing Source Files are:\n"
              Message ||:= files
              }
           else
              Message := "\n   No file(s) missing !!"
           }
      "-a" | "-all":{
           if files := DState.srcFile.getSourceFiles() then{
              Message   := "\n   All Source Files are:\n"
              Message ||:= files
              }
           else
              Message := "\n   No file(s) loaded !!"
           }
      default:{
           if files := DState.srcFile.getFoundFiles() then{
              Message   := "\n   Found Source Files are:\n"
              Message ||:= files
              }
           if files := DState.srcFile.getMissingFiles() then{
              Message ||:= "\n   Missing Source Files are:\n"
              Message ||:= files
              }
           } 
      } 
   DState.Write(Message)
end

#
# Initialization
#
initially()

   Keywords := 
      set("allocated","clock","collections","column","current",
          "date","now","dateline","digits","e","error",
          "errornumber","errortext","errorvalue","errout","fail",
          "eventcode","eventsource","eventvalue","features",
          "file","host","input","lcase","letters","level",
          "line","main","null","output","phi","pi","pos",
          "progname","random","regions","source","storage",
          "subject","time","trace","dump","ucase","version",
          "errno","window","col","row","x","y","interval",
          "control","shift","meta","lpress","mpress","rpress",
          "lrelease","mrelease","rrelease","ldrag","mdrag",
          "rdrag","resize","ascii","cset"
          )

   Message := ""
end

 
