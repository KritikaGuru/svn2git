#  
#  srcfile.icn
#  Handles the collected Source Files from the Icode
#  Author : Ziad Al-Sharif
#  Date   : Feb 24, 2008
# 

link bincvt
link strings

$define CHARACTER &letters++&digits

#
# It is used to index the loaded source files in the srcText list
# 
record fileIndex(
   fbegin, # where the source file index starts in srcText
   fend    # where the source file index ends in srcText
   )

#
# Contains all of the source files issues such as found files and so  
#
class SourceFile(
   procMainFile, # The Source File that has the procedure main
   procMainLine, # The Source Line that has the procedure main
   exeName,      # The executable file name
   exeSize,      # The executable file size
   sourcePath,   # String of paths that will be searched for source files
   sourceFiles,  # List with all source file names that are in the binary
   sourceText,   # List holds all source files text
   srcIndex,     # Table of our position in the source file; fname is the key
   foundFiles,   # Set with all file names that were found - loaded
   missingFiles  # Set with all file names that were not found - not loaded 
   )

#
# Extracts the file name from its path, it is different from
# getSourceFile() name by not keeping the path in sourcePath
#
method getFileName(f)
   local i, j:=0, path:=" "

   # what if the f is not in the current directory
   # such f = ../ipl/fname

   every j:= find("/",f)
   if (j+1) > *f then   fail
   else   return f[j+1:0]
end

#
# Extracts the file name from its path, it is only used by 
# loadSourceFiles()
#
method getSourceFileName(f)
   local i, j:=0, path:=" "
   local fname :="?"

   # what if the TP is not in the current directory of the UDB
   # such as ./udb ./test/t1/t2/t

   every j:= find("/",f)

   path ||:= f[1:j+1]
   sourcePath ||:= path ||" "
   if (j+1) > *f then   fail
   else   fname := f[j+1:0]

   return fname
end

#
# Obtains the file size from its name and path
#
method getSourceFileSize(f)
  local s:="", p, cmd :="du -h "
  local fsize:=-1, i

  # what about MS Windows ???     
  cmd ||:= f 
  p := open(cmd,"p")
  while s ||:=  read(p) || "\n"
  close(p)

  i := find("\t",s)
  fsize := s[1:\i]

  return fsize 
end

#
# Load the program Source File(s)
#
method loadSourceFiles(fname, src)
   local i, j, s, f, b, e

   exeName := getSourceFileName(fname)
   exeSize := getSourceFileSize(fname)
   sourceFiles := src
 
   # loads the source files that we can find and keep a 
   # list of the ones that we could not find. Note a source file
   # can be opened more that once so we need to be careful !!!
   every i := 1 to *sourceFiles do{
      f := getSourceFileName(sourceFiles[i])
      if not member(foundFiles, f) then{
         if s := dopen( sourceFiles[ i ] ) then {
            b := *sourceText
            while( put( sourceText, read( s ) ) )
            close( s )
            e := *sourceText
            insert( foundFiles, f )
            srcIndex[ f ] := fileIndex(b,e)
            if /procMainFile then
               if procMainLine := searchFileProcs(f,"main") then
                  procMainFile := f
            }
         else
            put(missingFiles, sourceFiles[ i ])# keep it as it is
         }
      #else
         #write("File is already found:",f)
      }
   return
end

#
# Used by cmdBreak
# Searchs the fname for a specific linenum, and make sure it is applicable
# for a breakpoint condition, if it is , it returns that line source code.
#
method searchFileLines(fname, linenum)
   local temp, temp1, wSpace, punct

   wSpace := cset( " \t\n\^m" )
   punct := (",<>?~`!@$#^&*-_:=+|[]\'./;(){} \t\^m\"")
   temp := sourceText[linenum + srcIndex[fname].fbegin]

   temp ? {
      tab(many(wSpace))
      if (temp1 := move(1)) then {
         if temp1 == "#" then {
            fail
            }
         return temp1 ||:= tab(many(CHARACTER ++ punct))
         }
      else{
         fail
         }
      }
end

#
# Used by cmdBreak
# Searchs the Fname for a specific ProcName and returns its linenum
#
method searchFileProcs(Fname, ProcName)
   local wSpace, other_char
   local temp, temp1, linenum

   if \Fname & \ProcName then{
      linenum := 1
      other_char := ("_")
      wSpace := cset( " \t\n\^m" )
      
      while temp := sourceText[linenum + srcIndex[Fname].fbegin] do{
         temp ? {
            tab(many(wSpace))
            if(temp1 := tab(many(&letters))) == ("method"|"procedure") then{
              tab(many(wSpace))
              temp1 := tab(many(CHARACTER ++ other_char))
              if temp1 == ProcName then {
                 return linenum
                 }
              }
            }
         linenum +:= 1
         }
      }
   else
      fail
end

#
# returns the executable name
#
method getExeName()
   if exeName =="?" then
      fail
   return exeName 
end

#
# returns the File Name that has the procedure main 
#
method getMainFileName()
   if /procMainFile then
      fail
   return procMainFile
end

#
# returns the total number of lines in a file.
#
method getFileTotalLines(fname)
   /fname := procMainFile
    
   return srcIndex[fname].fend - srcIndex[fname].fbegin #+ 1
end

#
# checks whether fname is a source file or not
#
method isSrcFile(fname)
  if member(foundFiles, fname) | member(missingFiles, fname) then
     return
  fail
end

#
# check to see if file is loaded or not
# loaded files are those that opend and placed in sourceText
#
method isLoaded(fname)
   if member(foundFiles, fname) then
      return
   fail
end

#
# checks to see whether a line number is in the file limits or not
#
method isInFile(fname, line)
   local b, e
   
   if line > 0 & isLoaded(fname) then{
      b := srcIndex[fname].fbegin
      e := srcIndex[fname].fend
      if (b + line <= e) & ( e - line >= b ) then
         return
      }
   fail
end

#
# returns an image of the current source line
#
method getSrcLine(fname, line)
    local f

    /fname := keyword("file", Monitored)
    /line  := keyword("line", Monitored)
    f := getFileName(fname)

    if isLoaded(fname) then #& isInFile(f, line) then       
       return sourceText[line + srcIndex[ f ].fbegin]
    else
       fail
end

#
# returns the file name of a procedure 
#
method getProcFile(pname)
    local fname

    every fname := !foundFiles do
       if searchFileProcs(fname, pname) then
          return fname
    fail
end

#
# returns the line number of a procedure name
#
method getProcLine(pname)
    local pfile, pline

    if pfile := getProcFile(pname) then
       if pline := searchFileProcs(pfile, pname) then
          return pline
    fail
end

#
# prints out the source code
#
method getSrcCode(fname)
   local i, b, e, code:="\n"

   if /fname then fname := keyword("file", Monitored)

   b := srcIndex[fname].fbegin
   e := srcIndex[fname].fend
   every i:= b  to e do
      code ||:= sourceText[i]||"\n"

   return code
end

#
# returns a string of the names of the opend src files 
#
method getFoundFiles()
   local L, x, i, max, fnames:="    "

   if *foundFiles > 0 then{
      i := 1
      L := sortf(foundFiles)
      max := maxlen(L)+2
      every x := !L do{
         fnames ||:=left(x, max)
         if i > 3 then{
            fnames ||:="\n    "
            i := 1    
            }
         else 
            i +:= 1
         } 
      return fnames
      }
   else
      fail  
end

#
# returns a string of the names of the missing src files
#
method getMissingFiles()
   local L, x, i, max, fnames:="    "

   if *missingFiles > 0 then{ 
      i := 1
      L := sortf(missingFiles)
      max := maxlen(L)+2
      every x := !L do{
         fnames ||:=left(x, max)
         if i > 3 then{
            fnames ||:="\n    "
            i := 1    
            }
         else 
            i +:= 1
         } 
      return fnames
      }
   else
      fail
end

#
# returns a string of the names of all source files
#
method getSourceFiles()
   local x, i, max, fnames:="    "
   
   if *sourceFiles > 0 then{
      i := 1
      max := maxlen(sourceFiles)+2
      every x := !sourceFiles do{
         fnames ||:=left(x, max)
         if i > 3 then{
            fnames ||:="\n    "
            i := 1    
            }
         else 
            i +:= 1
         } 
      return fnames
      }
   else
      fail
end

#
# Searchs through the specified source path for the requested file.
#
method dopen(s)
   local File, paths, path, binpath, f

   if File := open(s) then {
      return File          # look in current directory
   }

   paths := sourcePath

   if (binpath := (&features ? (="Binaries at " & tab(0)))) |
      ((f := open((binpath:=getpaths()) ||
                  ("iconx"|"iconx.exe"|"wiconx.exe")))) then {
      close(\f)
      paths ||:= " " || binpath
      paths ||:= " " || binpath || "../ipl/gdata/"
      paths ||:= " " || binpath || "../ipl/gincl/"
      paths ||:= " " || binpath || "../ipl/gprocs/"
      paths ||:= " " || binpath || "../ipl/gprogs/"
      paths ||:= " " || binpath || "../ipl/incl/"
      paths ||:= " " || binpath || "../ipl/lib/" 
      paths ||:= " " || binpath || "../ipl/mincl/" 
      paths ||:= " " || binpath || "../ipl/mprocs/"
      paths ||:= " " || binpath || "../ipl/mprogs/" 
      paths ||:= " " || binpath || "../ipl/procs/"
      paths ||:= " " || binpath || "../ipl/progs/" 
      paths ||:= " " || binpath || "../uni/lib/" 
      paths ||:= " " || binpath || "../uni/gui/" 
   }

   s := "/" || s      # platform-specific
   paths ? {
      while path := tab(find(" ") | 0) do {
         if File := open(path || s) then {
            return File
         }
         tab(many(' ')) | break
         }
      }
   fail
end

#
# Initialization
#
initially()

   exeName     := "?"
   exeSize     := -1
   sourceFiles := []
   sourceText  := []
   srcIndex    := table(0)
   foundFiles  := set()
   missingFiles:= []

   sourcePath   := ". .. ../.."
   #sourcePath||:= " " || getenv( "DPATH" )
   sourcePath ||:= " " || getenv( "LPATH" )
   sourcePath ||:= " " || getenv( "IPATH" )
end
