# 
#  srcfile.icn
#  Handling the collected Source Files from the Icode
# 

link bincvt

$define CHARACTER &letters++&digits

#
# Contains all of the source files issues such as found files and so  
#
class SourceFile(
   exeName,      # The executable file name
   sourcePath,   # String of paths that will be searched for source files
   sourceFiles,  # List with all source file names that are in the binary
   sourceText,   # List holds all the all source files text
   srcIndex,     # Table of our position in the source file; fname is the key
   foundFiles,   # Set with all the files that we have found are here
   missingFiles  # Set with all the files that we did not find
   )

#
# Extracts the executable name
#
method getExeName(f)
   local i, j:=0, path:=" "

   # what if the TP is not in the current directory of the UDB
   # such as ./udb ./test/t1/t2/t
   every i:= 1 to *f do
     if f[i] == "/" then   j := i

   path ||:= f[1:j+1]
   sourcePath ||:= path ||" "

   if (j+1) > *f then   fail
   else   exeName := f[j+1:0]

   return
end

#
# Load the program Source File(s)
#
method loadSourceFiles(fname, src)
   local i, j, s

   getExeName(fname)

   sourceFiles := src
 
   # (sourceFiles := getSrcFileNames(TP[1])) |
   # stop("Cannot open " || TP[1])

   # loads the source files that we can find and keep a 
   # list of the ones that we could not find
   every i := 1 to *sourceFiles do {
      if s := dopen( sourceFiles[ i ] ) then {
         srcIndex[ sourceFiles[ i ] ] := *sourceText
         insert( foundFiles, sourceFiles[ i ] )
         while( put( sourceText, read( s ) ) )
         close( s )
         }
      else
         put( missingFiles, sourceFiles[ i ] )
      }
   return
end

#
# Used by cmdBreak
# Searchs the fname for a specific linenum, and make sure it is applicable
# for a breakpoint condition, if it is , it returns that line source code.
#
method searchFileLines(fname, linenum)
   local temp, temp1, wSpace, punct

   wSpace := cset( " \t\n\^m" )
   punct := (",<>?~`!@$#^&*-_:=+|[]\'./;(){} \t\^m\"")
   temp := sourceText[linenum + srcIndex[fname]]

   temp ? {
      tab(many(wSpace))
      if (temp1 := move(1)) then {
         if temp1 == "#" then {
            return &null
            }
         return temp1 ||:= tab(many(CHARACTER ++ punct))
         }
      else{
         return &null
         }
      }
end

#
# Used by cmdBreak
# Searchs the Fname for a specific ProcName and returns its linenum
#
method searchFileProcs(Fname, ProcName)
   local wSpace, other_char
   local temp, temp1, linenum

   linenum := 1
   other_char := ("_")
   wSpace := cset( " \t\n\^m" )

   while temp := sourceText[linenum + srcIndex[Fname]] do{
      temp ? {
         tab(many(wSpace))
         if(temp1 := tab(many(&letters))) == ("method"|"procedure") then {
            tab(many(wSpace))
            temp1 := tab(many(CHARACTER ++ other_char))
            if temp1 == ProcName then {
	       return linenum
	       }
	    }
	 }
      linenum +:= 1
      }
   return &null
end

#
# prints out the source code
#
method printSourceCode()
   local i

   every i:= 1  to *sourceText do
        write(sourceText[i])
end

#
# returns a string of the names of the opend src files 
#
method getFoundFiles()
   local x, fnames

   every x := !foundFiles do
      fnames ||:=" \""||x||"\", "
   
   return fnames[1:-2]
end

#
# returns a string of the names of the missing src files
#
method getMissingFiles()
   local x, fnames:=""

   every x := !missingFiles do
      fnames ||:= " \""||x||"\", "

   return fnames[1:-2]
end

#
# returns a string of the names of all source files
#
method getSourceFiles()
   local x, fnames:=""
   
   every x := !sourceFiles do
      fnames ||:= " \""||x||"\", "

   return fnames[1:-2]
end

#
# returns an image of the current source line
#
method getSrcLine(line, fname)

    if /fname then
       return image(sourceText[line])
    else
       return image(sourceText[line + srcIndex[fname]])
end

#
# Searchs through the specified source path for the requested file.
#
method dopen(s)
   local File, paths, path, binpath, f

   if File := open(s) then {
      return File          # look in current directory
   }

   paths := sourcePath

   if (binpath := (&features ? (="Binaries at " & tab(0)))) |
      ((f := open((binpath:=getpaths()) ||
                  ("iconx"|"iconx.exe"|"wiconx.exe")))) then {
      close(\f)
      paths ||:= " " || binpath
      paths ||:= " " || binpath || "../ipl/gdata/"
      paths ||:= " " || binpath || "../ipl/gincl/"
      paths ||:= " " || binpath || "../ipl/gprocs/"
      paths ||:= " " || binpath || "../ipl/gprogs/"
      paths ||:= " " || binpath || "../ipl/incl/"
      paths ||:= " " || binpath || "../ipl/lib/" 
      paths ||:= " " || binpath || "../ipl/mincl/" 
      paths ||:= " " || binpath || "../ipl/mprocs/"
      paths ||:= " " || binpath || "../ipl/mprogs/" 
      paths ||:= " " || binpath || "../ipl/procs/"
      paths ||:= " " || binpath || "../ipl/progs/" 
      paths ||:= " " || binpath || "../uni/lib/" 
      paths ||:= " " || binpath || "../uni/gui/" 
   }

   s := "/" || s      # platform-specific
   paths ? {
      while path := tab(find(" ") | 0) do {
         if File := open(path || s) then {
            return File
         }
         tab(many(' ')) | break
         }
      }
   fail
end

initially()

   exeName     := "?"
   sourceFiles := []
   sourceText  := []
   srcIndex    := table(0)
   foundFiles  := set()
   missingFiles:= []

   sourcePath   := ". .. ../.."
   #sourcePath||:= " " || getenv( "DPATH" )
   sourcePath ||:= " " || getenv( "LPATH" )
   sourcePath ||:= " " || getenv( "IPATH" )
end
