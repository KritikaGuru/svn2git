#
# icode.icn - code for handling icode files
#

record header (
   hsize,    # /* size of interpreter code          */
   trace,    # /* initial value of &trace           */
   Records,  # 
   Ftab,     # /* location of record/field table    */
   Fnames,   # /* location of names of fields       */
   Globals,  # /* location of global variables      */
   Gnames,   # /* location of names of globals      */
   Statics,  # /* location of static variables      */
   Strcons,  # /* location of identifier table      */
   Filenms,  # /* location of ipc/file name table   */
   linenums, # /* location of ipc/line number table */
   config    # /* [16];  icode version              */

# #ifdef FieldTableCompression
#    FtabWidth, # /* width of field table entries, 1 | 2 | 4  */
#    FoffWidth, # /* width of field offset entries, 1 | 2 | 4 */
#    Nfields,   # /* number of field names     */
#    Fo,        # /* The start of the Fo array */
#    Bm,        # /* The start of the Bm array */
# #endif        # /* FieldTableCompression     */

)

class Icode(
   exeName,      # The executable file name
   icode,        # A string with the executable file
   hdr,          # An instance of the header() record
   wordSize,     # 4 on a 32-bit and 8 on a 64-bit machine 
   icodeVersion  # String holds the Icode Version 32/64 compressed/uncompressed
   )

#
# Convert binary number (read in as string data) to integer.
# This appears to be unfinished.
#
method littleord(s)
   local o, i, i1, i2
   o := ord(s)
   i1 := 0
   i2 := 0
   every i := 1 to 8 do {
      if iand(o,2^(i-1))>0 then {
         i1 +:= 2^(i-1)
         }
      }
   every i := 1 to 8 do {
      if iand(o,2^(8-i))>0 then {
         i2 +:= 2^(i-1)
         }
      }
   return o
end

#
#
method littleendian(s)
   local i
   i := 0
   s := reverse(s)
   every i := littleord(!s) + i * 256
   return i
end


#
# checks the accessability of the executable and reads the icode 
#
method openIcodeFile(exeFile)
   local statrec, f

   exeName := exeFile

   statrec := stat(exeName) | stop("can't stat ", image(exeName))

   if not (f := open(exeName,"ru")) then {
      write(&errout, "can not open file : ", exeName)
      fail
      }

   # reads all of the executable source file into the icode 
   icode := reads(f, statrec.size)
   close(f)

   if *icode < statrec.size then {
      write("file ", exeName, " is too short")
      fail
      }
end


#
# Initialize the hdr class variable base on the Icode wordSize
#
method readIcodeHeader()
   local i, w

   hdr := header()
   every i := 1 to 11 do {
      w := move(wordSize)
      hdr[i] := littleendian(w)
      }

   hdr.config := move(16 * wordSize)
   #write("config=",image(hdr.config))

end

#
# prints the Icode header information based on the Header Record in the Icode
#
method printIcodeHeader()
   local fn
   
   write("\t Icode Version   : " || icodeVersion)
   every fn := fieldnames(hdr) do
       if fn ~=="config" then
          write("\t header.", left(fn,8," "), " = ", image(hdr[fn])) 
end

#
# Icode Version depends on the size of the Unicon word,
# 4-bytes on a 32-bit machine or 8-bytes on a 64-bit machine 
#
method checkIcodeVersion(p)

   # by default, Assume a 32-bit machine with word size 4
   wordSize := 4
   readIcodeHeader()

   if find("I9.U.00",hdr.config) ~= 1 then{
      &pos := p   # start over as a 64-bit machine
      wordSize := 8

      readIcodeHeader()
      icodeVersion := "64-bit"
      }
   else{
      icodeVersion := "32-bit"
      }
end

#
# UnComprees the Icode in case if it is Compressed
#
method readCompressedIcode()
   local ftmp

   # we need to uncompress the rest brute force means: 
   # write it out and then read it in an uncompress mode
   ftmp := open("tmpfilename","w") |  stop("can not open a tmpfilename")
   writes(ftmp, tab(0))
   close(ftmp)

   if ftmp := open("tmpfilename","rz") then {
      &subject := reads(ftmp, hdr.hsize) |
                  stop("can't read compressed icode")
      close(ftmp)
      }
   else 
      stop("can not open a tmpfilename")

end

#
# Unicon I code will be in a Compressed format if it exceds the 1Mag limit 
#
method checkCompressedIcode()
   local Z, size

   # check whether it is a compressed icode or not
   hdr.config ? {
      tab(find("/")+1) | stop("can't find /")
      size := integer(tab(many(&digits)))
      Z := move(1)
      }

   if Z == "Z" then {
      readCompressedIcode()
      icodeVersion ||:= " Compressed Icode"
      }
   else
      icodeVersion ||:= " Uncompressed Icode"
  
end


#
# Collect the Source files from the executable Icode
#
method getSrcFileNames(exename)
   local fNames, LLL,
         p1, x, i, j

   openIcodeFile(exename)

   # look at header information
   icode ? {
      if find(".exe", exeName) then {
         tab(find("exit\^m\nrem [executable Icon binary follows]"))
         }
      tab((x := find("\^l"))+3) # \^l\n\0 terminate shell header
      p1 := &pos

      checkIcodeVersion(p1)
      checkCompressedIcode()

      i := hdr.Filenms
      move(i)

      LLL := []
      fNames := []
      while i < hdr.linenums do {
         move(wordSize)
         put(LLL, j := littleendian(move(wordSize)))
         i +:= (wordSize * 2)
         }
      every i := 1 to *LLL do  {
         move(LLL[i] + hdr.Strcons - hdr.linenums) &
             x := tab(find("\0")\1) &
             put( fNames, x ) & &fail
         }
      }
   return fNames
end

initially()
   icodeVersion := "NONE"
end
