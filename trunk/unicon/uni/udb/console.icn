#
# console.icn
# Handles the main console based command interpreter
# Author : Ziad Al-Sharif
# Date   : Feb 24, 2008 
#

$include "defaults.icn"

class Console : Session(
   cmdHistory, # list keeps all of the UDB's cmd Session History
   wchar,      # a cset of valid characters used in the command line
   UP,         # The up arrow control key
   DOWN,       # The down arrow control key
   ENTER,      # The enter key
   BkSp,       # The Back Space key
   RIGHT,      # The right arrow control key
   LEFT        # The left arrow control key
   )

#
# It is OK on Linux, needs to be tested on Windows???.
#
method my_getch()
   local e1, e2, e3

$ifdef _UNIX
   e1 := getch()
   if e1 === "\e" then {
      if kbhit() then {
         e2 := getch()
         e3 := getch()
         if e3 === !"2356" then e3 ||:= getch()
         return e1 || e2 || e3
         }
      }
   else{
      writes(e1)
      return e1
      }
$else
   e1 := getch()
   return e1
$endif

end

#
# Puts the last command in the right place in cmdHistory List
#
method update_cmdHistory(line)
   local i

   every i:=2 to *cmdHistory do
      if line == cmdHistory[i] then{
         delete(cmdHistory,i)    
         break
      }
   put(cmdHistory,line)
end

#
# Reads an inout string char by char,and parse the
# collected line to tokens and put them in cmdlist.
#
method get_CommandLine()
   local line, words, word
   local ch, i, c

   # make sure that cmdIgnore is set with &null for the next command
   line :=""
   words := list()

   i := 0
   writes(PROMPT)

   while ch := my_getch() do{
$ifdef _UNIX
      case ch of{
        UP:{
           if i > 1 then  
              i-:=1
           else if i = (1|0) then
              i := *cmdHistory
           else
              i := 1
           line := cmdHistory[i]
           }
        DOWN:{
           if i < *cmdHistory then
              i+:=1
           else if i = *cmdHistory then
              i := 1
           else
              i := *cmdHistory
           line := cmdHistory[i]
           }
        BkSp | LEFT :{
           line := line[1:-1] 
           }
        ENTER:{
           break 
           }
        default:{
           if ch[1] ~==="\e" then
              line ||:=ch         
           }
        }#end of case
$else       
      case ch of{
        BkSp:{
           line := line[1:-1] 
           }
        ENTER:{
           write()
           break
           } 
        default:{
           line ||:= ch
           } 
        } #end case
$endif
      writes("\r")
      every c := 1 to 10 do writes("      ")
      writes("\r")
      writes(PROMPT || line)
      }#end of while
      
   # if Eneter hit it will take the last cmdx
   if *line = 0 then{
      i:= *cmdHistory
      line := cmdHistory[i]
      } 
   if *line > 0 then{  
      update_cmdHistory(line)
      # analyize that cmd line
      line ? while tab(upto(wchar))do {
           word := tab(many(wchar))
           put(words, word)
      }
      return words
   }else
      return &null
end

#
# Here where we start a UDB Console Session and have
# most of the user control debugging interface
#
method startConsole(argv)
   local ans, cmd, old_State:=NONE

   DState.initializeState(argv)

   while DState.State ~= QUIT do{
     case DState.State of{
       RUN:{
          # everything is fine, file is louded and ready to run TP
          # when the program is PAUSED, we can make use of cmds such as:
          # [run: re-execute],[break],[step],[next],[cont],[quit],[up],[down]
          # [frame], [print], [where]
          DState.RunCode := RUN
          every startSession() do{
             old_State := DState.State
             while DState.State ~= RUN do{
               case DState.State of {
                 END | 
                 QUIT:    { break break next 
                            #-- TEST: for The Sake of getting the Time right
                            ###break break break 
                          }
                 CONTINUE:{ DState.State   := RUN
                            DState.RunCode := CONTINUE    
                            next                       }
                 STEP:    { DState.State   := RUN
                            DState.RunCode := STEP        
                            next                       }
                 NEXT:    { DState.State   := RUN
                            DState.RunCode := NEXT        
                            next                       }
                 RERUN:   { DState.State   := RUN
                            break break next           }
                 SKIP:    { DState.State := old_State  }
                 ERROR:   { DState.State := old_State
                            Write(Message)             }
               }# end of case
               cmd := get_CommandLine()
               if \cmd then    parse_Command(cmd)
               else            DState.State := SKIP
             }# end of while
          }#end of every
          }
       END:{
          # if debugging finished OK
          DState.State := LOAD #important for re-run
          }
       ERROR:{
          # if there is a Console Error, handle it, 
          # and go back to the old state
          DState.State := old_State 
          }
       SKIP:{
          DState.State := old_State
          }
       QUIT:{
          return
          }
       default:{
          # for anyything else ???, like when DState.State = NONE
          # write("udb_Console Default!!!!!")
          }
     } # end case DState.State
    old_State := DState.State
    cmd := get_CommandLine()
    if \cmd then   parse_Command(cmd)
    else           DState.State := SKIP
   }# end while DState.State
end

#
#  Initialization
#
initially()
   
   self.Session.initially()

   cmdHistory := [""]
   wchar := CHARACTER ++ '\'\\/-+.*:=,\_n&?[]\"!<>~'

   # Constant Keys used with the command history
$ifdef _UNIX 
   UP    := "\e[A"
   DOWN  := "\e[B"
   RIGHT := "\e[C" # not used
   LEFT  := "\e[D" # ???
   ENTER := "\n"
   BkSp  := "\d"
$else
   #UP    := "\e[A"
   #DOWN  := "\e[B"
   #RIGHT := "\e[C" # not used
   #LEFT  := "\e[D" # ???
   ENTER := "\r"
   BkSp  := "\b"
$endif
end
