#
# commands.icn
# March 16, 2007
#

$include "defaults.icn"
$include "evdefs.icn"

class Commands : Debug()

#
# Parse a command
#
method parse_Command(cmd)

   case cmd[1] of{
     "l"     |
     "load"  :{  cmdLoad(cmd)      }
     "r"     |
     "run"   :{  cmdRun(cmd)       }
     "q"     |
     "quit"  :{  cmdQuit()         }
     "p"     |
     "print" :{  cmdPrint(cmd)     }
     "w"     |
     "where" :{  cmdWhere()        }
     "b"     |
     "break" :{  cmdBreak(cmd)     }
     "watch" :{  cmdWatch(cmd)     }
     "s"     |
     "step"  :{  cmdStep(cmd)      }
     "n"     |
     "next"  :{  cmdNext(cmd)      }
     "f"     |
     "frame" :{  cmdFrame(cmd)     }
     "up"    :{  cmdUp()           }
     "down"  :{  cmdDown()         }
     "?"     |
     "h"     |
     "help"  :{  cmdHelp(cmd)      }
     "c"     |
     "cont"  :{  cmdContinue()     }
     "bt"    :{  cmdBacktrace()    }
      #-cmds that are not in gdb
     "tree"  :{  cmdTree(cmd)      }
     "ihdr"  :{  cmdIcodeHeader()  }
     "level" :{  cmdLevel()        }
     "trace" :{  cmdTrace(cmd)     }
     "gui"   :{  cmdGUI(cmd)       }
     default :{   
        # anything else
        State := ERROR
        Message   := "\n\t Undefined Command: \""|| cmd[1] ||"\"" ||
                     "\n\t Try \"help\" for assistance."
        Write(Message)
     }
   }
end


#
# Loads a file after running the UDB Session 
#
method cmdLoad(cmd)

   init_Debugging(cmd[2:0])
end

#
# Runs the pre-loaded file, it can be used to re-run the program again
#
method cmdRun(cmd)
   local i, args:=[]

   if *cmd >= 2 then{
      if State = (LOAD | PAUSE | END) then{
         put(args, TP[1])
         every i:=2 to *cmd do
            put(args, cmd[i])
         TP := args
      }
   }

   if State = (LOAD | END | PAUSE) then{ 
      if State = PAUSE then  State := RERUN
      else                   State := RUN
      if not member(valueMask, E_Line) & *breakMask > 0 then{
         valueMask[E_Line] := breakMask
         eventMask := eventMask ++ cset(E_Line) 
         #write("------E_Line added")
         }
      if not member(valueMask, E_Assign) & (*watchMask | *traceVarMask) >0 then{
         valueMask[E_Assign] := watchMask ++ traceVarMask
         eventMask := eventMask ++ cset(E_Assign)
         #write("------E_Assign added")
         }
   }
   else{
      State := ERROR
      Message   := "\n\t No program to RUN, load program first_
                    \n\t Type \"help\" for assistance"
      Write(Message)
   }
end

#
# Allows you to quit the program.
#
method cmdQuit()
   local ans

   # check whether a program is running or not, Paused, etc??????
   # do not exit directlly if the program is in the running state
   if State = (RUN | PAUSE) then
      Write("\t A Program is currently running")

   # always ask the user if he realy wants to quit!!!
   writes("\t Are you sure you want to Quit?, (Y/N )? :")
   ans := read()
   if ans[1] == ("y"|"Y") then
      State := QUIT
   else{
      #make udb console takes no actions 
      State := SKIP
   }
end


#
# prints out all of the Global Variables state in some level
#
method printGlobals(level)
   local x, i
        
   if /level then
      level := top_Frame.level - cur_Frame.level
   
   Message := ""
   every x := !global_vars do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# prints out all of the Local Variables for some Level  
#
method printLocals(level)
   local x, i

   if /level then
      level := top_Frame.level - cur_Frame.level

   Message := ""
   every x := localnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# prints out all of the Formal Parameters for some Level  
#
method printParams(level)
   local x, i

   if /level then
      level := top_Frame.level - cur_Frame.level

   Message := ""
   every x := paramnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# writes down the current frame information, 
# used by cmdPrint, cmdFrame, cmdUp, cmdDown
#
method printFrame(level)
     
   if /level then
      level := top_Frame.level - cur_Frame.level
   Message := "\n\t Frame: "|| level            ||
              ", File: "|| cur_Frame.fname      ||
              ", Line: "|| cur_Frame.linenum    ||
              ", Proc: "|| image(cur_Frame.node)||
              "\n\t -- Locals :"
   Write(Message)
   printLocals(level)
   printParams(level)

end

#
# Prints out a variable and it's current value. Variables from previous
# procedures that are still in the stack can also be viewed.
#
method cmdPrint(cmd)
   local x,    # is the dummy variable that we are looking for
         i,    # is the index when x is a table or list
         var,  # is the actual variable that we got from variable()
         level,# stack frame level, 0: current level, biger level means older
         i1,i2,temp

   if State = PAUSE then{ 
      if x := temp := cmd[2] then{
         if temp == ("-G" | "-globals") then{
            printGlobals()
            return
	    }
	 else if temp == ("-L" | "-locals") then{
            printLocals()
            return
	    }
	 else if temp == ("-P" | "-params") then{
            printParams()
            return
	    }

         #--To be able to print things like T[1], T["a"], L[10], etc.
         if (i1:= find("[",temp)) & (i2:= find("]", temp)) then{
            x := temp[1:i1]
            i := temp[i1+1:i2]
            if *i > 0 then
               if find("\"",i) then  i := string(i[2:*i])
               else                  i := integer(i)
            else
               i := &null             
         }

         if cmd[3] then  level := integer(cmd[3]) | 0  #(level | current level) 
         else            level := top_Frame.level - cur_Frame.level
         
         if var := variable(x, Monitored, level) then{
            if type(var) == ("table" | "list" | "string" ) & \i  then
               Message := "\n\t "||x||" = "||var[i]
            else
               Message := "\n\t "||x||" = "||image(var)
	    }
	 else
            Message := "\n\t "||x||" : Is not in the current frame !!"
	 }
      else {
         level := top_Frame.level - cur_Frame.level
         printFrame(level)
	 }
      }
   else{
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      }
   Write(Message)
end

#
# Prints out the current stack frame info,
# It can be used to jump into a specific frame, [f n]
#
method cmdFrame(cmd)
   local x, level 

   if State = PAUSE then{ 
      level := top_Frame.level - cur_Frame.level 
      if *cmd = 1 then {
         printFrame(level)
	 }
      else
         Write("cmdFrame, What ???")
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Moves one frame up on the execution stack
#
method cmdUp()
   local x, level

   if State = PAUSE then {
      if /cur_Frame.parent.node then
         Write("\t No more Frames up !!!")
      else {
         cur_Frame := cur_Frame.parent
         level := top_Frame.level - cur_Frame.level
         printFrame(level)
	 }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Moves one frame down on the execution stack
#
method cmdDown()
   local x, level

   if State = PAUSE then {
      if cur_Frame === top_Frame then
         Write("\t No more Frames Down !!!")
      else {
         cur_Frame := cur_Frame.children[-1]
         level := top_Frame.level - cur_Frame.level 
         printFrame(level)
	 }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Prints out where you are in the code, what file, and what line.
#
method cmdWhere()
   local cur_file, cur_line, level

   if State = PAUSE then{
      cur_file := cur_Frame.fname
      cur_line := keyword("line", Monitored)
      level := top_Frame.level - cur_Frame.level 
      Message := "\n\t File: " || cur_file ||
                 ", Proc: "    || image(proc(Monitored,level)) ||
                 ", Line: "    || cur_line ||
                 "\n\t Code: " || sourceText[cur_line + srcIndex[cur_file]]
      }
   else {
      State := ERROR
      Message := "\n\t No program is running !!!_
                  \n\t Try \"run\", or Type \"help\" for assistance"
      }
   Write(Message)
end

#
# Used from cmdBacktrace 
#
method print_Backtrace(frame)
   local t, i

   Message   := "\n\t Frame: "|| frame.level   ||
                ", File: "|| frame.fname       ||
                ", Line: "|| frame.linenum     ||
                ", proc: "|| image(frame.node)
   Write(Message)

   t := frame.children
   if *t < 1 then
      return
   every print_Backtrace(!t)
end

#
# To back trace the executin in the stack
# [bt]
#
method cmdBacktrace()

   if State = PAUSE then
      print_Backtrace(treeRoot)
   else {
      State := ERROR
      Message := "\n\t EvalTree is empty, try \"run\" first"
      Write(Message)
      }
end

#
# Continue the full speed execution after a PAUSE
# [cont]
#
method cmdContinue()

   if State = PAUSE & RunCode ~= ERROR then {
      State := CONTINUE
      if not member(valueMask, E_Line) & *breakMask > 0 then
         valueMask[E_Line] := breakMask
      else{
         # when there is no break point the E_Line 
         # will not be in the original eventMask
         if *breakMask = 0 then
            eventMask --:= cset(E_Line)
         }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Steps only on line of execution
# [step], [step n]; n's default value is one
#
method cmdStep(cmd)
   local count

   if State = PAUSE & RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1
      State := STEP
      if RunCode = WATCH then{
         # if *breakMask>0 then E_Line is already in eventMask
         # and we need to remove delete(valueMask,E_Line) until continu
         if *breakMask > 0 then  delete(valueMask, E_Line)
         else                    eventMask ++:= cset(E_Line)
         }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Steps only one line of execution, treats procedure call as one operation
# [next], [next n]; n's default value is one  
#
method cmdNext(cmd)
   local count

   if State = PAUSE & RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
	 next_count := count
      else
	 next_count := 1
      State := NEXT
      if RunCode = WATCH then{
         # if *breakMask>0 then E_Line is already in eventMask
         # and we need to remove delete(valueMask,E_Line) until continu
         if *breakMask > 0 then  delete(valueMask, E_Line)
         else                    eventMask ++:= cset(E_Line)
         }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end


#
# watches for a variable
#
method cmdWatch(cmd)
   local x, var, procName, i, old_State := State

   if not (State = (LOAD | PAUSE)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help\" for assistance"
      Write(Message)
      return
      }
   State := SKIP
   
   # if cmd is only "watch"; will print all of the pre-set watch points info
   if *cmd = 1 then{
      Message :="\n\t " || cmd[1]
      every x := !watchMask do {
         Message ||:= "\n\t Watch for : " || x
	 }
      Write(Message)
      return
      }

   var := cmd[2]
   if member(watchMask, var) then {
      Message := "\n\t There is already an existing watch point on: " || var
      Write(Message)
      return
      }
   
   # Note: we have to be smart about the scope of the watched variable
   if cmd[3] then {
      var ||:= "-" || cmd[3] # cmd[3] is the procedure name
      }
   else if old_State = LOAD then {
      # we would assume that the watched variable is a global one  
      var ||:="+"  # + is the global scope character
      }
   else if old_State = PAUSE then {
      # assume? that the watched variable is local to where it is paused
      procName := image(top_Frame.node)
      i := find(" ",procName)
      var ||:= "-" || procName[i+1:0]
      }
   insert(watchMask, var)
   #???if not member(valueMask, E_Assign) then
   #???   valueMask[E_Assign] := watchMask
   Message := "\n\t Watchkpoint successfully set for: "||var
   Write(Message)
end

#
# Sets Break points on line numbers or procedure names
# [b linenum], [b ProcName], [b file linenum]
#
method cmdBreak(cmd)
   local code, line, arg1, arg2, i, j, x, f
   local list_ptr             # List of records of type breakPt
   local break_point, temp_bp # record of type breakPt

   if not (State = (LOAD | PAUSE)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help\" for assistance"
      Write(Message)
      return
      }
   State := SKIP

   # if cmd is only "break"; will print all of the preset breakpoints info
   if *cmd = 1 then {
      Message := "\n\t " || cmd[1]
      every x := key(breakPoints) do {
         list_ptr := breakPoints[x]
         i := 1
         while i <= *list_ptr do {
            break_point := list_ptr[i]
            Message ||:= "\n\t File: " || break_point.file_name ||
                         ", Line: " || break_point.line_num ||
                         ", Code: " || break_point.code
            i +:= 1
	    }
	 }
      Write(Message)
      return
      }
 
   if *cmd = 2 then {
      j:= 0
      f := TP[1]
      every i:= 1 to *f do
         if f[i] == "/" then   j := i

      arg1 := f[j+1:0]    #file_argv[1]
      arg2 := cmd[2]
      }
   else if *cmd > 2 then {
      arg1 := cmd[2]
      arg2 := cmd[3]
      }

   arg1 := add_extension(arg1)
   if member(foundFiles, arg1) then {
      if line := integer(arg2) then {
         if 0 < line <= *sourceText then {
            code := search_file_lines(arg1, line)
            if \code then {
               break_point := breakPt(arg1, line, code)
	       }
            else {
               Message   := "\n\t Line number was not found,_
                             \n\t Please try a different line number"
               Write(Message)
               return
	       }
	    }
         else {
            Message := "\n\t Line number is not within the sourcefile"
            Write(Message)
            return
	    }
	 }
      else {
         line := search_file_procs(arg1, arg2)
         if \line then {
            break_point := breakPt(arg1,line,sourceText[line + srcIndex[arg1]])
	    }
         else {
            Message   := "\n\t Procedure not found_
                          \n\t Make sure the method name is correct!"
            Write(Message)
            return
	    }
	 }
      
      # record breakPt(file_name, line_num, code)
      line := break_point.line_num
      if member(breakPoints, arg1) then {
         list_ptr := breakPoints[arg1]
         i := 1
         while i <= *list_ptr do {
            temp_bp := list_ptr[i]
            if temp_bp.line_num = break_point.line_num then {
               Message   := "\n\t The break point is already exist,_
                             \n\t Type \"break\" to see all breakpoints"
               Write(Message)
               return
	       }
            i +:= 1
	    }
         put(list_ptr, break_point)
	 }
      # put and pull
      else {
         list_ptr := []
         put(list_ptr, break_point)
         breakPoints[arg1] := list_ptr
	 }

      # Important for the sake of valuemask 
      insert(breakMask,line)
      #????if not member(valueMask, E_Line) then
      #????   valueMask[E_Line] := breakMask
      Message   := "\n\t Breakpoint set successfully in "|| arg1 ||
                   "\n\t at "|| sourceText[line + srcIndex[arg1]]
      Write(Message)
      return
      }
   Message   := "\n\t File not found,_
                 \n\t Make sure the file name is correct."
   Write(Message)
end

#
# Used by cmdBreak
#
method add_extension(arg1)
   local temp1, temp2

   arg1 ? {
      temp1 := tab(many(CHARACTER ++ '_-'))
      repeat {
	 if (temp2 := move(1)) then {
	    temp1 := temp1 || temp2
            }
	 else {
	    temp1 := temp1 || ".icn"
            return temp1
            }
	 temp2 := tab(many(CHARACTER))
         if temp2 == "icn" then {
	    return arg1
            }
         }
      }
end

#
# Used by cmdBreak
# Searchs the fname for a specific linenum, and make sure it is applicable
# for a breakpoint condition, if it is , it returns that line source code.
#
method search_file_lines(fname, linenum)
   local temp, temp1, wSpace, punct

   wSpace := cset( " \t\n\^m" )
   punct := (",<>?~`!@$#^&*-_:=+|[]\'./;(){} \t\^m\"")
   temp := sourceText[linenum + srcIndex[fname]]

   # write("temp is == to empty line")
   temp ? {
      tab(many(wSpace))
      if (temp1 := move(1)) then {
         if temp1 == "#" then {
            #Message := "\n\t Cannot place a breakpoint at a comment."
            #write(Message)
            return &null
         }
         return temp1 := temp1 || tab(many(CHARACTER ++ punct))
      }
      else {
         #Message := "\n\t Cannot place breakpoint on empty line."
         #write(Message)
         return &null
      }
   }
end

#
# Used by cmdBreak
# Searchs the Fname for a specific ProcName and returns its linenum
#
method search_file_procs(Fname, ProcName)
   local wSpace, other_char
   local temp, temp1, linenum

   linenum := 1
   other_char := ("_")
   wSpace := cset( " \t\n\^m" )

   while temp := sourceText[linenum + srcIndex[Fname]] do {
      # write(temp)
      temp ? {
         tab(many(wSpace))
         if(temp1 := tab(many(&letters))) == ("method"|"procedure") then {
            tab(many(wSpace))
            temp1 := tab(many(CHARACTER ++ other_char))
            if temp1 == ProcName then {
	       return linenum
	       }
	    }
	 }
      linenum +:= 1
      }
   return &null # not NULL
end

#------ Commands that are not in gdb,thay need Dr.J's approval

#
# a method to print the Icode Header
#
method cmdIcodeHeader()

   printIcodeHeader()

end

#
# Used by the cmdTree method, leaf initial value is "treeRoot".  
#
method printT(leaf)
   local t, i

   Message ||:= "\n\t num of leaf:" || *leaf.children ||
                "\n\t Proc  : " || image(leaf.node)   ||
                "\n\t Level : " || leaf.level
   Write(Message)

   t := leaf.children
   if *t < 1 then  return
   #every i := 1 to *t do
   every printT(!t)
end

#
# Prints out the current execution tree, very simelar to bt cmd
#
method cmdTree(cmd)
   # evalTree can not be printed unless the TP ran for a while.
   if State = (PAUSE | LOAD | END) then{ # needs a fix when state=END ?
      if *cmd = 1 then
         printT(treeRoot)
      else{
         if cmd[2] == "on" then{
            # it is on by default until it is set to be off
            treeFlag := &null
            Write(Message:="\n\t the evaltree is ON.")
            }
         else{ # cmd[2] == "off"
            treeFlag := 1
            Write(Message:="\n\t the evaltree is Off.")
            }
         }
      }
   else{
      State := ERROR
      Message := "\n\t EvalTree is empty, try \"run\" first"
      Write(Message)
      }
end

#
# prints out the current depth level in the calling stack 
#
method cmdLevel()

   Message := "Current level is " || keyword("level",Monitored)
   Write(Message)

end

#
# set a trace on a variable
#
method traceVar(cmd)
   local L, var, r, procName, i, old_State := State
   
   # Note: we have to be smart about the scope of the traced variable
   # find the real var first, then find the action
   var := cmd[2]
   if not cmd[3] then{
      if old_State = LOAD then {
         # we would assume that the watched variable is a global one  
         var ||:="+"  # + is the global scope character
         }
      else if old_State = PAUSE then {
         # assume? that the watched variable is local to where it is paused
         procName := image(top_Frame.node)
         i := find(" ",procName)
         var ||:= "-" || procName[i+1:0]
         }
      else{
         Message:= "\n\t unknown action_
                    \n\t Try \"help trace\" for assistance"
         Write(Message)
         return
         }
      }
   else if not (cmd[3] == ("on"|"off")) then{
      var ||:= "-" || cmd[3] # cmd[3] is the procedure name
      }
   else if cmd[3] == ("on"|"off") then{
      if cmd[4] then {
         var ||:= "-" || cmd[4] # cmd[4] is the procedure name
         }
      else if old_State = LOAD then {
         # we would assume that the watched variable is a global one  
         var ||:="+"  # + is the global scope character
         }
      else if old_State = PAUSE then {
         # assume? that the watched variable is local to where it is paused
         procName := image(top_Frame.node)
         i := find(" ",procName)
         var ||:= "-" || procName[i+1:0]
         }
      }

   # here var := real var
   # write("------var= ",var)
   if member(traceVarMask, var) then{
      if cmd[3] == "on" then
         Message := "\n\t Trace for \""||var||"\" is already ON"
      else if cmd[3] == "off" then{
         Message := "\n\t Trace for \""||var||"\" is set to be OFF"
         delete(traceVarMask, var)
         }
      else{ #$trace var proc, or $trace var, are used to print the var info 
         if member(traceVarTable, var) then {
            L := traceVarTable[var]
            if *L > 0 then{
               Message := "\n\t--trace var: "||var
               every r := !L do{
                  Message ||:="\n\t----" || r.fname || ", " || r.line ||
                              ": "|| r.var||" = "||r.value
                  }
               }# end if *L > 0
            else{
               Message:= "\n\t Var: "||var||" has no trace info yet!"
               }
            }
         else{
            Message:= "\n\t Var: "||var||" has no trace info yet!"
            }
         }# end else
      }
   else{# if not member(traceVarMask, var)
      if cmd[3] == "on" then{
         insert(traceVarMask, var)
         Message := "\n\t Trace for \""||var||"\" is set to be ON"
         }
      else if cmd[3] == "off" then{
         Message := "\n\t Trace for \""||var||"\" is not ON to set it OFF"
         }
      else{
         Message:= "\n\t unknown action_
                    \n\t Try \"help trace\" for assistance"
         }
      }
   Write(Message)
end

#
# prints the execution behavior tracer info
# it is used by traceBehavior()
#
method printTraceBehavior(ecodeSet)
   local x, L, e, traced

   every e := !ecodeSet do{
      if member(traceState, e) then{
         Message := "\n\t---Printing the trace info for "||evnames(e)||":"
         L := traceTable[e]
         if type(L) ~== "list" then next
         #Message := "\n-"|| evnames(e) ||":"
         if e === E_Pcall then{
            every x := !L do{
               Message ||:= "\n\t --"||x.level ||", "||x.fname||", "||x.line||
                            ": "||x.proc  ||"("||x.param||")."
               }
            } 
         else{
            every x := !L do
               Message ||:= "\n\t --"||x.fname||", "||x.line||": "||x.code
            }
         }
      else{
         Message:="\n\t No trace is ON for \""||evnames(e)||"\" to print._
                   \n\t Try \"help trace\" for assistance"
         } 
      Write(Message)
      }
end

#
# get what action to do for the trace command
# it is used by the traceBehavior()
#
method traceBehaviorAction(cmd)
   local action
 
   if *cmd = 2 then{
      action := "print"
      }
   else if *cmd >=3 then{
      case cmd[3] of{
        "call"         :{ action   := "print" }
        "fail"         :{ action   := "print" }
        "suspend"      :{ action   := "ptint" }
        "resume"       :{ action   := "print" }
        "on"|"enable"  :{ action   := "on"    }
        "off"|"disable":{ action   := "off"   }
         }
      if *cmd = 4 then{
         if cmd[4] == ("on"|"enable") then{
            action := "on"
            }
         else if cmd[4] == ("off"|"disable") then{
                 action := "off"
            }
         }
      }
   return action
end

#
# Process the trace behavior command
# it isused by cmdTrace()
#
method traceBehavior(cmd)
   local e, ecodeSet, action, ename

   case cmd[2] of{
   "-proc" :{
       ecodeSet := ProcMask
       eventMask ++= ProcMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Pcall)  }
         "fail"   :{ ecodeSet := cset(E_Pfail)  }
         "suspend":{ ecodeSet := cset(E_Psusp)  }
         "resume" :{ ecodeSet := cset(E_Presum) }
       }} 
   "-func" :{
       ecodeSet := FncMask
       eventMask ++:= FncMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Fcall)  }
         "fail"   :{ ecodeSet := cset(E_Ffail)  }
         "suspend":{ ecodeSet := cset(E_Fsusp)  }
         "resume" :{ ecodeSet := cset(E_Fresum) }
       }}
   "-oper" :{
       ecodeSet := OperMask
       eventMask ++:= OperMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Ocall)  }
         "fail"   :{ ecodeSet := cset(E_Ofail)  }
         "suspend":{ ecodeSet := cset(E_Osusp)  }
         "resume" :{ ecodeSet := cset(E_Oresum) }
       }}
   "-scan" :{
       ecodeSet := ScanMask
       eventMask ++:= ScanMask
       case cmd[3] of{
         "new"    :{ ecodeSet := cset(E_Snew)   }
         "fail"   :{ ecodeSet := cset(E_Sfail)  }
         "suspend":{ ecodeSet := cset(E_Ssusp)  }
         "resume" :{ ecodeSet := cset(E_Sresum) }
       }}
   default:{ action := "error" }
   }# end case
   
   #if action ~== "error" then
   action := traceBehaviorAction(cmd)
   
   ename := ""
   every e := !ecodeSet do
     ename ||:= evnames(e)||", "
   ename := ename[1:-2]
   
   case action of{
     "print" :{ printTraceBehavior(ecodeSet) }
     "on"    :{ traceState ++:= ecodeSet    
                Message := "\n\t The traceState has a new trace code: "||ename
                Write(Message)
              }
     "off"   :{ traceState --:= ecodeSet    
                Message := "\n\t The traceState lost a trace code: "||ename
                Write(Message)
              }
     default :{ Message := "\n\t unknown trace action_
                            \n\t Try \"help trace\" for assistance"
                Write(Message)
              }
     }# end case
end

#
# build Variable(s) and/or Behavior(s) tracer  
#
method cmdTrace(cmd)
   local ecodeSet, traced, action

   if not (State = (LOAD | PAUSE | END)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help trace\" for assistance"
      Write(Message)
      return
      }

   if *cmd >= 2 then{
      if find("-",cmd[2]) then traceBehavior(cmd)
      else                     traceVar(cmd)
      }
   else{
      Message := "\n\t unknown trace action !!?_
                  \n\t try \"help trace\" for assistance"
      Write(Message)
      }
   State := SKIP
end

#
# to skip the infinite loop that goes in the gui stuff waitting for an event
#
method cmdGUI(cmd)
   if cmd[2]=="on" then{
#      guiFlag:=1
      Write(Message := "\n\t The guiFlag is set to be on") 
   }
   else if cmd[2]=="off" then{
#      guiFlag := &null
      Write(Message := "\n\t The guiFlag is set to be off") 
   }
   else
      Write(Message := "\n\t cmdGUI: No Action specified")
end

#---------- end commands that are not in gdb

#         
# General Help Command
#
method cmdHelp(cmd)

   #write("\t This is command " || cmd[1])
   if *cmd = 1 then {
   case State of {
    NONE | LOAD | END:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t load f: loads a program file named f_
      \n\t run   : runs the pre-loaded program under UDB_
      \n\t break : sets a break point in the source code_
      \n\t trace : to trace some of the program behaviors_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
    PAUSE:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t cont  : continue on a ful speed execution after a PAUSE_
      \n\t step  : stepping one or more lines in the source code_
      \n\t next  : same as step command except treating a \n\t\t_
      \n\t         procedure call as one command or one line of code_
      \n\t run   : restarts the execution from the begining_
      \n\t where : shows the current location info_
      \n\t frame : shows the current stack frame info_
      \n\t up    : moves up one ore more stack frame_
      \n\t down  : moves down one or more stack frame_
      \n\t print : prints out the value of a var in current frame_
      \n\t bt    : prints out the back trace_
      \n\t break : sets a break point in the source code_
      \n\t trace : to trace some of the program behaviors_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
    ERROR:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t where : shows the current location info_
      \n\t bt    : prints out the back trace_
      \n\t print : prints out the value of a var in current frame_
      \n\t run   : restarts the execution from the begining_
      \n\t break : sets a break point in the source code_
      \n\t trace : to trace some of the program behaviors_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
   }# end of case   
   }
   else{
   case cmd[2] of {
    "load":{
      Message:="_
      \n\t Loads a program into UDB. Use: \"load program\"_
      \n\t load p     : loads program (p)_
      \n\t load p arg : loads program (p) with argument (arg)"
      }
    "step":{
      Message:="_
      \n\t Steps into the next line in the source code_
      \n\t step   : steps one line_
      \n\t step n : steps (n) lines"
      }
    "run":{
      Message:="_
      \n\t Starts (or restarts) program execution_
      \n\t run      : runs current loaded program_
      \n\t run args : args list passed to program"
      }
    "next":{
      Message:="_
      \n\t next steps to next line even on function calls_
      \n\t treats function call as only one operation_
      \n\t next   : steps one line_
      \n\t next n : steps (n) lines"
      }
    "frame":{
      Message:="_
      \n\t Prints out the Stack Frame info_
      \n\t frame   : prints current stack frame info_
      \n\t frame n : prints info about stack frame number (n)_
      \n\t n=0: current frame, oldest frame has the bigest number_
      \n\t look for \"help up\" and \"help down"
      }
    "up":{
      Message:="_
      \n\t Moves current frame pointer up in the execution stack_
      \n\t up   : moves current frame pointer one frame up_
      \n\t up n : moves current frame pointer (n) frames up_
      \n\t look for \"help down\" and \"help frame\""
      }
    "down":{
      Message:="_
      \n\t Moves current frame pointer down in the stack_
      \n\t down   : moves current frame pointer one frame down_
      \n\t down n : moves current frame pointer (n) frames down_
      \n\t look for \"help up\" and \"help frame\""
      }
    "quit":{
      Message:="\n\t quit: Exits UDB. Use: \"quit\""
      }
    "help":{
      Message:="\n\t help: for more help. Try \"help command\""
      }
    "print":{
      Message:="_
      \n\t Prints variable information:_
      \n\t print       : prints globals and locals of current frame_
      \n\t print var   : prints the var value from current frame_
      \n\t print var i : prints tha var value from frame number i_
      \n\t print -G    : prints all global vars_
      \n\t print -L    : prints all local vars in current frame_
      \n\t print -P    : prints all Formal Parameters"
      }
    "where":{
      Message:="_
      \n\t Prints the current position in the Source Code_
      \n\t where_
      \n\t look for \"help break\""
      }
    "cont":{
      Message:="_
      \n\t Continue to run at full speed after a break point_
      \n\t continue_
      \n\t look for \"help cont\""
      }
    "break":{
      Message:="_
      \n\t Sets a break point_
      \n\t break      : prints all of the pre-set break points_
      \n\t break num  : Sets a break at line number (num)_
      \n\t break Proc : Sets a break at procedure named \"Proc\""
      }
    "watch":{
      Message:="_
      \n\t Sets a watch point on some var_
      \n\t watch          : prints a list of all pre-set watch vars_
      \n\t watch var      : break at every line the var can change,_
      \n\t                  if the program is running, it watche for_ 
      \n\t                  var in the local scope, otherwize it_
      \n\t                  assumes that var is a global variable_
      \n\t watch var proc : watch for local var in procedure proc"
      }
    "trace":{
      Message:="_
      \n\t Sets a tracer on any variable or execution behavior of the program:_
      \n\t trace var | var=[on|off]_
      \n\t       -proc | -proc=[on | off] |_
      \n\t       -proc [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -func | -func=[on | off] |_
      \n\t       -func [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -oper | -oper=[on | off] |_
      \n\t       -oper [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -scan | -scan=[on | off] |_
      \n\t       -scan [ new  | fail | suspend | resume ]=[on | off]_
      \n\t \"on\" and \"off\" are used to turn the tracer on and off_
      \n\t when there is no on/off then the action is printing info_
      \n\t ----------------------_
      \n\t trace var             : prints the traced var info_
      \n\t                         if the program is running, it assumes the_ 
      \n\t                         var is in the local scope, otherwise it_
      \n\t                         assumes that var is a global variable_
      \n\t trace var p           : prints traced var info that is local to p_
      \n\t trace var=[on|off]    : traces every value the var can have,_
      \n\t trace var=[on|off] p  : traces a local var in procedure p_
      \n\t --In oreder to set any of the following behavior tracers ON,_
      \n\t   it must be set before the program is running/rerunning_
      \n\t trace -proc           : prints all the traced procedure info_
      \n\t trace -proc=[on|off]  : Sets the procdure tracer on/off _
      \n\t trace -proc call      : prints the traced procedure calls_
      \n\t trace -proc call=on   : Sets a tracer ON on every procedure call_
      \n\t trace -proc call=off  : Sets a tracer OFF on every procedure call_
      \n\t and the rest ar going in the same fashion"
      }
    default:{
      Message:="\n\t Command not found. Type \"help\" for assistance"
      } 
   }#end of case
   }# end of else
   #make udb console takes no actions 
   State := SKIP
   Write(Message)
end

# Just make sure that the base class is initialized
initially()

   self.Debug.initially()

end
