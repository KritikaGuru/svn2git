#
# stepping.icn
# It handles UDB's stepping and continuing related tasks
# Author: Ziad Al-Sharif
# Date:   7-15-2008
# e-mail: zsharif@gmail.com
#

$include "evdefs.icn"
$include "defaults.icn"
$include "patdefs.icn"

class Stepping(
   DState,      # (Alias) object of type State class
   step_count,  # the cmdStep optional counter, initial value 0, default 1
   next_count,  # the cmdNext optional counter, initial value 0, default 1
   nex_level,   # used with the next command to skip over a call
   msg,         # a string with latest message from this class
   pat,         # store the current pstep pattern 	       
   pline,       # stores the previous pattern line number
   oldLen,      # stores the old match length
   totalMatch,  # stores the total match
   assignVal    # stores the value of a variable assignment in a pattern	       
   )	
	       
#
# while next_count > 0, keep next until it is 0,
# then stop there and change the state to step
#
method checkNext()
   local  level
   static once:=0 # To help not coming back to the calling line

   level := keyword("level", Monitored)

   if level > nex_level & once = 0 then{
      next_count +:=1
      once := 1
      } 

   if level = nex_level then{
      if next_count > 1 then{
         next_count -:= 1
         }
      else if next_count = 1 then{
         next_count := 0
         step_count := 1
         DState.State := PAUSE
         DState.RunCode := STEP
         once := 0
         }
      }
end

#
# Steps only one line of execution, treats procedure call as one operation
# [next], [next n]; n's default value is one  
#
method cmdNext(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
	 next_count := count
      else
	 next_count := 1

      nex_level := keyword("level", Monitored)
      DState.Update(NEXT)
      DState.Write("   Nexting.")
      }
   else {
      DState.State := ERROR
      msg   := "\n   The program is not being run._
                \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# helps return from the current procedure level to the previous level
#
method cmdReturn(cmd) 

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      #if count := integer(cmd[2]) then
      #   next_count := count
      #else
      next_count := 1

      nex_level := keyword("level", Monitored) -1
      DState.Update(NEXT)
      DState.Write("   Returning.")
      }
   else {
      DState.State := ERROR
      msg   := "\n   The program is not being run._
                \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end
#
# while step_count > 0, keep step until it is 0,
# then stop there and make State := STEP
#
method checkStep()
   local cur_line, cur_file

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)

   if DState.RunCode = PSTEP then {
      pline := 0 
      msg := "\n   No pattern event detected before: " || cur_file ||
             ", line " || cur_line
      msg||:= "\n   Stepping \n"
      DState.Write(msg)
      }

   if step_count > 1 then {
      step_count -:= 1
      DState.State := RUN
      DState.RunCode := STEP
      }
   else if step_count = 1 then {
      if cur_file == "__faux.icn" then {
	 DState.State := RUN
	 DState.RunCode := STEP
	 return
	 }

      step_count -:= 1

      msg:="\n   file "||cur_file||", line "||cur_line||"."
      msg||:="\n   "||cur_line-1||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line-1)
      msg||:="\n-->"||cur_line||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line)
      msg||:="\n   "||cur_line+1||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line+1)
      DState.Write(msg)

      DState.State := PAUSE
      DState.RunCode := STEP
   }
end

#
# Steps only on line of execution
# [step], [step n]; n's default value is one
#
method cmdStep(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1

      DState.Update(STEP)
      DState.Write("   Stepping.")
      }
   else {
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# while step_count > 0, keep step until it is 0,
# then stop there and make State := PSTEP
#
method checkPStep()
   local cur_line, cur_file

   ## the way patterns are organized sometimes
   ## the ipc is associated the pattern creation
   ## line rather than the line the match happens at
   ## to avoid this we use a member variable pline to
   ## store the current pattern match line

   cur_file := keyword("file", Monitored)
   if pline = 0 then {
      cur_line := keyword("line", Monitored)
      pline := cur_line
   }
   else cur_line := pline
   pos := keyword("pos", Monitored)
   sub := keyword("subject", Monitored)

   if step_count > 1 then {
      step_count -:= 1
      DState.State := RUN
      DState.RunCode := PSTEP
      }
   else if step_count = 1 then {
      if cur_file == "__faux.icn" then {
	 DState.State := RUN
	 DState.RunCode := PSTEP
	 return
	 }

      step_count -:= 1

      if &eventcode === E_PatAttempt then {
         ppos := 1
         pat := &eventvalue
         msg := "\n   Pattern match started"
         msg ||:="\n   file "||cur_file||", line "||cur_line||"."
         msg||:="\n   "||cur_line-1||":"||
                DState.srcFile.getSrcLine(cur_file, cur_line-1)
         msg||:="\n-->"||cur_line||":"||
                DState.srcFile.getSrcLine(cur_file, cur_line)
         msg||:="\n   "||cur_line+1||":"||
         DState.srcFile.getSrcLine(cur_file, cur_line+1)
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         return
      }
      else if &eventcode === E_PelemFail then {

         index := keyword("patindex", Monitored)

         case &eventvalue of {
            PC_Unanchored | PC_Assign | PC_Fence_X |
            PC_R_Enter | PC_R_Remove | PC_R_Restore | PC_EOP :{ 
               DState.State := RUN
               DState.RunCode := PSTEP
               if step_count > 1 then return
               else {
                  step_count := 1
                  return
                  }
            }
            default :{
               msg := "\n   file "||cur_file||", line "||cur_line||", pattern:"
               msg ||:= "\n   " || image(pat)
               msg ||:= "\n\n   Pattern Element Failed to Match "
               msg ||:= "\n   Total Match: "||image(totalMatch)
               msg ||:= "\n   Failed Pattern Element: "
               msg ||:= "\n   " || pindex_image(pat, index)
               DState.Write(msg)
               DState.State := PAUSE
               DState.RunCode := PSTEP
               return
               }
            }
         }
      else if &eventcode === E_PelemMatch then {

         index := keyword("patindex", Monitored)

         if oldLen = *totalMatch then    { curMatch := &null      }
         else if oldLen = 0 then {
            curMatch := totalMatch
            oldLen := *totalMatch
            }
         else if *totalMatch > 0 then {
            totalMatch ? {
               tab(oldLen + 1)
               curMatch := tab(0)
               }
            oldLen := *totalMatch
            }

         msg := "\n   file "||cur_file||", line "||cur_line||", pattern:"
         msg ||:= "\n   "||image(pat)||"\n"
         msg ||:= "\n   Total Matched String: "||image(totalMatch)

         case &eventvalue of {
            PC_RTab_Nat | PC_RTab_NF  | PC_RTab_NP  | PC_RTab_NMF : {
               msg ||:= "\n   Matched String: "||image(curMatch) 
               }
            PC_Pos_Nat | PC_Pos_NF | PC_Pos_NP | PC_Pos_NMF |
            PC_RPos_Nat | PC_RPos_NF | PC_RPos_NP | PC_RPos_NMF : {
               msg ||:= "\n   "||"Cursor Position: "||keyword("pos", Monitored)                }   
            PC_Assign_Imm | PC_Assign_OnM : {
               assignVal := totalMatch   #in this case the event value returned the assign val
               msg ||:= "\n   Assignment Value: "||image(totalMatch)
               msg ||:= "\n   Assigned Pattern Element: "
               msg ||:= "\n   "||pindex_image(pat, index)
               DState.Write(msg)
               DState.State := PAUSE
               DState.RunCode := PSTEP
               return 
               }
            PC_Unanchored | PC_Assign | PC_Fence_X |
            PC_R_Enter | PC_R_Remove | PC_R_Restore | PC_EOP: { 
               DState.State := RUN
               DState.RunCode := PSTEP
               if step_count > 1 then return
               else {
                  step_count := 1
                  return
                  }
               }   
            default :{
               msg ||:= "\n   Matched String: "||image(curMatch)
               }
            }
         msg ||:= "\n   Matched Pattern Element: "
         msg ||:= "\n   " ||pindex_image(pat, index)  
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         }
   }
end

#
# Steps during pattern execution or on line if a
# E_Line event has been triggered. 
# [pstep], [pstep n]; n's default value is one
#
method cmdPStep(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1
         DState.Update(PSTEP)
         DState.Write("   Pattern Stepping.")
         }
   else {
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

# Concludes the pattern step environment
# when a pattern recieves either a pattern failure
# or pattern success event

method pEnd()

   if DState.RunCode = PSTEP then {
      if &eventcode = E_PatMatch then{
         msg := "\n   Pattern matched on string"
         msg ||:= "\n   Total Matched String: "||totalMatch
         msg ||:= "\n   Resuming normal stepping..."
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := STEP
         }
      else{
         msg := "\n   Pattern failed to match on string"
         msg ||:= "\n   Resuming normal stepping..."
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := STEP
         }
}

   pat := &null
   pline := 0
   oldLen := 0
   totalMatch := &null
end

#
# Continue the full speed execution after a PAUSE
# [cont]
#
method cmdContinue()

   if DState.State = PAUSE & DState.RunCode ~= ERROR then{
      DState.Update(CONTINUE)
      DState.Write("   Continuing.")
      }
   else{
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# Initialization
#
initially()
   
   step_count := 0
   next_count := 0
   pline := 0
   oldLen := 0
   nex_level  := &null
   pat   := &null
   totalMatch := &null
end
