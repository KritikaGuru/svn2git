#
# stepping.icn
# It handles UDB's stepping and continuing related tasks
# Author: Ziad Al-Sharif
# Date:   7-15-2008
# e-mail: zsharif@gmail.com
#

$include "evdefs.icn"
$include "defaults.icn"
$include "patdefs.icn"

class Stepping(
   DState,      # (Alias) object of type State class
   step_count,  # the cmdStep optional counter, initial value 0, default 1
   next_count,  # the cmdNext optional counter, initial value 0, default 1
   nex_level,   # used with the next command to skip over a call
   msg,         # a string with latest message from this class
   pat,         # store the current pstep pattern
   assignVal,   # assignment value	       
   curPelem,    # the current pelem we are on
   pPos         # stores the previous position of the current total match       
   )	
	       
#
# while next_count > 0, keep next until it is 0,
# then stop there and change the state to step
#
method checkNext()
   local  level
   static once:=0 # To help not coming back to the calling line

   level := keyword("level", Monitored)

   if level > nex_level & once = 0 then{
      next_count +:=1
      once := 1
      } 

   if level = nex_level then{
      if next_count > 1 then{
         next_count -:= 1
         }
      else if next_count = 1 then{
         next_count := 0
         step_count := 1
         DState.State := PAUSE
         DState.RunCode := STEP
         once := 0
         }
      }
end

#
# Steps only one line of execution, treats procedure call as one operation
# [next], [next n]; n's default value is one  
#
method cmdNext(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
	 next_count := count
      else
	 next_count := 1

      nex_level := keyword("level", Monitored)
      DState.Update(NEXT)
      DState.Write("   Nexting.")
      }
   else {
      DState.State := ERROR
      msg   := "\n   The program is not being run._
                \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# helps return from the current procedure level to the previous level
#
method cmdReturn(cmd) 

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      #if count := integer(cmd[2]) then
      #   next_count := count
      #else
      next_count := 1

      nex_level := keyword("level", Monitored) -1
      DState.Update(NEXT)
      DState.Write("   Returning.")
      }
   else {
      DState.State := ERROR
      msg   := "\n   The program is not being run._
                \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end
#
# while step_count > 0, keep step until it is 0,
# then stop there and make State := STEP
#
method checkStep()
   local cur_line, cur_file

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)

   if DState.RunCode = PSTEP & step_count = 1 then {
      msg := "\n   No pattern event detected before: " || cur_file ||
             ", line " || cur_line
      msg||:= "\n   Stepping \n"
      DState.Write(msg)
      }
   else if DState.RunCode = PSTEP & step_count > 1 then {
      return ##do nothing... still checking for pattern events 
      }

   if step_count > 1 then {
      step_count -:= 1
      DState.State := RUN
      DState.RunCode := STEP
      }
   else if step_count = 1 then {
      if cur_file == "__faux.icn" then {
	 DState.State := RUN
	 DState.RunCode := STEP
	 return
	 }

      step_count -:= 1

      msg:="\n   file "||cur_file||", line "||cur_line||"."
      msg||:="\n   "||cur_line-1||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line-1)
      msg||:="\n-->"||cur_line||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line)
      msg||:="\n   "||cur_line+1||":"||
             DState.srcFile.getSrcLine(cur_file, cur_line+1)
      DState.Write(msg)

      DState.State := PAUSE
      DState.RunCode := STEP
   }
end

#
# Steps only on line of execution
# [step], [step n]; n's default value is one
#
method cmdStep(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1

      DState.Update(STEP)
      }
   else {
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# while step_count > 0, keep step until it is 0,
# then stop there and make State := PSTEP
#
method checkPStep()
   local cur_line, cur_file

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)
 
   if step_count > 1 then {
      silentStep()
      DState.State := RUN
      DState.RunCode := PSTEP
      }
   else if step_count = 1 then {
      if cur_file == "__faux.icn" then {
	 DState.State := RUN
	 DState.RunCode := PSTEP
	 return
         }  

      step_count -:= 1

      if &eventcode === E_PatAttempt then {
         pat := &eventvalue
         msg := "\n   Pattern match started"
         msg||:="\n   file "||cur_file||", line "||cur_line||"."
         msg||:="\n   "||cur_line-1||":"||
                DState.srcFile.getSrcLine(cur_file, cur_line-1)
         msg||:="\n-->"||cur_line||":"||
                DState.srcFile.getSrcLine(cur_file, cur_line)
         msg||:="\n   "||cur_line+1||":"||
         DState.srcFile.getSrcLine(cur_file, cur_line+1)
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         return
         }
      else if &eventcode === E_PelemAttempt then { handle_pstep_attempt() }
      else if &eventcode === E_PelemFail then    { handle_pstep_fail();   }
      else if &eventcode === E_PelemMatch then   { handle_pstep_match()   }
      }
end

method handle_pstep_fail()
   local cur_line, cur_file, cur_index

   cur_index := keyword("patindex", Monitored)
   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)

   case &eventvalue of {
      PC_Assign | PC_R_Remove | PC_R_Restore | PC_Arbno_Y :{
         step_count := 1     ##Restore Stepping, not really a "step"
         DState.State := RUN
         DState.RunCode := PSTEP
         return
         }
   default :{
         msg := "\n   ?? at "||cur_file||":"||cur_line||", failed to match at "
         msg ||:= "pos:"||keyword("pos", Monitored)|| " out of string length "
         msg ||:= *keyword("subject", Monitored)
         msg ||:= "\n   Sub: " || truncateLine()
         msg ||:= "\n" || getUnderlined()
         patElem := getPatElem(pat, cur_index)
         msg ||:= "\n   Pat: "||patElem[1]
         msg ||:= "\n" || patElem[2]
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         return
         }
      }
end

## several pcodes related to pushing and popping
## require special handling before they hit
## node_fail. This is where they are handled. 

method handle_pstep_attempt()
   local cur_line, cur_file

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)
   curPelem := &eventvalue

   if curPelem = PC_R_Restore | curPelem = PC_R_Remove then {
      if curPelem = PC_R_Restore then 
         msg := "\n   Pattern Element Failed, Entering Nest Pattern... "
      else
         msg := "\n   Nested Pattern Failed to Match, Exiting... "
      step_count := 1
      DState.Write(msg)
      DState.State := RUN
      DState.RunCode := PSTEP
      return 
      }
   else if curPelem = PC_Arbno_X | curPelem = PC_Arbno_S then {
      cur_index := keyword("patindex", Monitored)
      msg := "\n\n   Placing Arbno on the pattern stack, Continuing... "
      msg ||:= "\n   "||pindex_image(pat, cur_index)
      step_count := 1
      DState.Write(msg)
      DState.State := RUN
      DState.RunCode := PSTEP
      }
   else if curPelem = PC_Arb_X then {
      cur_index := keyword("patindex", Monitored)
      msg := "\n\n   Placing Arb on the pattern stack, Continuing... "
      msg ||:= "\n   "||pindex_image(pat, cur_index - 1)
      step_count := 1
      DState.Write(msg)
      DState.State := RUN
      DState.RunCode := PSTEP
      }
   else if curPelem = PC_R_Enter then {
      step_count := 1
      assignPos := keyword("pos", Monitored)
      return  #keep track of assign position begins
      }

   step_count := 1 ##could get here via other pelem_attempts
end

method handle_pstep_match()
   local cur_line, cur_file, cur_index, cur_match, assign_match
   local patElem

   cur_index := keyword("patindex", Monitored)
   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)

   msg := "\n   ?? at "||cur_file||":"||cur_line||", matched "
   msg ||:= pPos||":"||keyword("pos", Monitored)|| " out of string length "
   msg ||:= *keyword("subject", Monitored)

   case curPelem of {
      PC_Pos_Nat | PC_Pos_NF | PC_Pos_NP | PC_Pos_NMF |
      PC_RPos_Nat | PC_RPos_NF | PC_RPos_NP | PC_RPos_NMF : {
         msg ||:= "\n   Total Matched String: "||image(totalMatch)
         msg ||:= "\n   "||"Cursor Position: "||keyword("pos", Monitored)
         }
      PC_Setcur : {
         msg ||:= "\n   Total Matched String: "||image(totalMatch)
         msg ||:= "\n   "||"Cursor Position on Assignment: "
         msg ||:= keyword("pos", Monitored)
         msg ||:= "\n   Assigned Pattern Element: "
         msg ||:= "\n   "||pindex_image(pat, cur_index)
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         return
      }
      PC_Assign_Imm | PC_Assign_OnM : {
         msg ||:= "\n   Total Matched String: "||image(totalMatch)
         if curPelem = PC_Assign_Imm then
            msg ||:= "\n   Assignment Value: "
         else
            msg ||:= "\n   Assignment Value if Match: "
         msg ||:= image(assignVal)
         msg ||:= "\n   Assigned Pattern Element: "
         msg ||:= "\n   "||pindex_image(pat, cur_index)
         DState.Write(msg)
         DState.State := PAUSE
         DState.RunCode := PSTEP
         return 
         }
      PC_Fence_X | PC_R_Enter | PC_EOP |PC_Arbno_Y : { ## no ops 
         step_count := 1
         DState.State := RUN
         DState.RunCode := PSTEP
         return 
         }
      PC_Unanchored : { ## Match is retrying. Set new position,reset totalMatch
         msg := "\n   Match has failed with no alternatives,"
         msg ||:= " starting from the beginning..."
         pPos := keyword("pos", Monitored) 
         step_count := 1
         DState.Write(msg) 
         DState.State := RUN
         DState.RunCode := PSTEP
         return 
         }
      default : {
         msg ||:= "\n   Sub: " || truncateLine()
         msg ||:= "\n" || getUnderlined()
         }
      }
      patElem := getPatElem(pat, cur_index)
      msg ||:= "\n   Pat: "||patElem[1]
      msg ||:= "\n" || patElem[2]
      DState.Write(msg)
      DState.State := PAUSE
      DState.RunCode := PSTEP
end

method getUnderlined()
   local buff_len := 8         ##"   Sub: <string>"
   local image_max := 72
   local ellipse := 6
   local underlined := ""
   local cur_pos := keyword("pos", Monitored)
   local sub := keyword("subject", Monitored)

   line_max := image_max + buff_len

   if cur_pos >= (image_max - ellipse) then {
      sub ? {
         every 1 to buff_len do underlined ||:= " " 

         if pPos < (image_max - ellipse) then {
            underlined ||:= "..."
            tab(cur_pos - ((image_max - ellipse)/2))

            while &pos ~= cur_pos do {
               move(1)
               underlined ||:= "."
               }
             }
         else {
            underlined ||:= "   "
            tab(cur_pos - ((image_max - ellipse)/2))

            while &pos ~= pPos do{
               move(1)
               underlined ||:= " "
               }
            while &pos ~= cur_pos do {
               move(1)
               underlined ||:= "."
               }
            }
         }
      underlined ||:= "^"
      return underlined
      }
   else{
      every 1 to (buff_len +(pPos - 1)) do underlined ||:= " "
      every pPos to cur_pos - 1 do underlined ||:= "."
      underlined ||:= "^"
      }

   return underlined

end

method truncateLine()
   local sub := keyword("subject", Monitored)
   local cur_pos := keyword("pos", Monitored)
   local image := ""
   local image_max := 72
   local ellipse := 6
   local count := 1

   if *sub + 1 > image_max then {
      sub ? {
         if cur_pos >= (image_max - ellipse) then {
            image := "..."
            tab(cur_pos - ((image_max - ellipse)/2))
            }
         image ||:= tab(cur_pos)
         while(&pos < (*sub + 1) & *image < (image_max - ellipse)) do{
            image ||:= move(1)
            count +:= 1
            }
         if &pos ~= *sub + 1 then image ||:= "..."
         }
      return image
      }
   else
      return sub
end

method getPatElem(pat, index)
   local patImage, patImageB
   local elemStart, elemEnd
   local final_image := ""
   local under_image := "        "
   local image_max := 72
   local ellipse := 6

   patImage := pindex_image(pat, -1)
   patImageB := pindex_image(pat, index)
  
   ##Do a character by character comparison on a bracketed images and a non-
   ##bracketed images. The positions that are different mark the start
   ##and end to the pattern element we are looking for

   patImage ? {
      while &pos < *patImage + 2 do {
         if (patImage[&pos:&pos+1] ~== patImageB[&pos:&pos+1]) then{
            elemStart := &pos
            break
            }
         if &pos = 0 then write("Error: No indicated element before EOP")
         move(1)
         }

      while &pos < *patImage + 2 do {
      if (patImage[&pos:&pos+1] ~=== patImageB[&pos+1:&pos+2] |
          (&pos = *patImage + 1 & patImageB[&pos+1:&pos+2] == ']')) then{
            elemEnd := &pos
            break
            }
         move(1)
         }
     }

   patImage ? {
      if elemStart > (image_max/2) then { ##if start pos is greater than 1/2
         final_image ||:= "..."           ##of the available space then truncate
         under_image ||:= "   "
         tab(elemStart - ((image_max - ellipse)/2))
         while(&pos ~= elemStart) do {
            final_image ||:= move(1)
            under_image ||:= " "
            }
         }
      else {                              ##else tab to the element and then   
         add_image := tab(elemStart)      ##allocate white space underneath line
         every 1 to *add_image do under_image ||:= " "
         final_image ||:= add_image
         }

     ##While the image hasn't been fully processed move through
     ##while allocating dots until the endElem position has been reached
     ##Go to the end of the line. If that exceeds available, truncate
      write("here")
      while(&pos < *patImage + 1) do {
         final_image ||:= move(1)
         if &pos <= elemEnd then         under_image ||:= "."
         else if &pos = elemEnd + 1 then under_image ||:= "^"
         if *final_image >= (image_max - (ellipse/2)) then {
            final_image ||:= "..."
            if &pos < elemEnd then under_image ||:= ".^ "
            return L := [final_image, under_image]
            }
         }
      }
   return L := [final_image, under_image]
end

method silentStep()

   if &eventcode == E_PatAttempt then {
      pat := curPelem
      step_count -:= 1
      }
   else {
    case curPelem of {
       PC_Fence_X | PC_R_Enter | PC_EOP | PC_Arbno_X | PC_Arbno_S | 
       PC_Assign | PC_Arb_X | PC_R_Remove | PC_R_Restore : {
          return
          }
       PC_Unanchored :{
          totalMatch := null
          pPos := keyword("pos", Monitored)
          return 
          }
       default : {
          step_count -:= 1
          }
       }
   }
end

#
# Steps during pattern execution or on line if a
# E_Line event has been triggered. 
# [pstep], [pstep n]; n's default value is one
#

method cmdPStep(cmd)
   local count

   if DState.State = PAUSE & DState.RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1
         DState.Update(PSTEP)
         }
   else {
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

# Concludes the pattern step environment
# when a pattern recieves either a pattern failure
# or pattern success event

method pEnd()

   if DState.RunCode = PSTEP  & step_count = 1 then {
      step_count -:= 1
      if &eventcode = E_PatMatch then{
         msg := "\n   Pattern matched on string"
         msg ||:= "\n   Resuming normal stepping..."
         }
      else{
         msg := "\n   Pattern failed to match on string"
         msg ||:= "\n   Resuming normal stepping..."
         }
      DState.Write(msg)
      DState.State := PAUSE
      DState.RunCode := STEP
      }

   pPos := 1 
   pat := &null
   assignVal := &null
   curPelem := &null
end

#
# Continue the full speed execution after a PAUSE
# [cont]
#
method cmdContinue()

   if DState.State = PAUSE & DState.RunCode ~= ERROR then{
      DState.Update(CONTINUE)
      DState.Write("   Continuing.")
      }
   else{
      DState.State := ERROR
      msg := "\n   The program is not being run._
              \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(msg)
      }
end

#
# Initialization
#
initially()
   
   step_count := 0
   next_count := 0
   pPos := 1 
   nex_level  := &null
   pat   := &null
   assignVal := &null
   curPelem := &null
end
