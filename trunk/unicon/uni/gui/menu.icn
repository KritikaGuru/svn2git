#
# $Id: menu.icn,v 1.2 2004-01-12 20:17:42 rparlett Exp $
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui
link graphics


$include "guih.icn"

#
# This class encapsulates a drop down menu, or a sub-menu.
#
# The left, centre and right labels/images of the elements
# within it are formatted within the menu automatically.
#
class Menu : SubMenu(
   w,                       #         
   h,                       #         
   max_label_left_w,        #                        
   max_label_mid_w,         #                       
   max_label_right_w,       #                         
   temp_win,                #                
   which_open,              #                  
   children                 #
   )

   method set_parent_component(x)
      self.MenuComponent.set_parent_component(x)
      every (!self.children).set_parent_component(x)
      return
   end

   #
   # Add the given component to the Menu.
   #
   method add(c)
      put(self.children, c)
      c.set_parent(self)
   end

   method get_which_open()
      return self.which_open
   end

   method resize()
      cw := self.parent_component.cwin

      self.h := self.max_label_left_w := self.max_label_right_w := self.max_label_mid_w := 0

      dy := BORDER_WIDTH

      every m := !self.children do {
         #
         # Set x, y of label position for sub items.
         #
         m.set_label_pos(self.x + BORDER_WIDTH, self.y + dy)
         #
         # Set their label size.
         #
         m.size_label()
         #
         # Increment height; compute maximum label element widths.
         #
         self.h +:= m.label_h
         self.max_label_left_w <:= m.label_left_w
         self.max_label_right_w <:= m.label_right_w
         self.max_label_mid_w <:= m.label_mid_w

         dy +:= m.label_h
      }

      #
      # Height of object is height of total labels within, plus top and bottom border widths.
      #
      self.h +:= 2 * BORDER_WIDTH

      #
      # Width is total of all maximum label elements, plus left and right border widths.
      #
      self.w := self.max_label_left_w + self.max_label_mid_w + self.max_label_right_w + 2 * BORDER_WIDTH

      #
      # Compute x, y positions of sub-menus and descend recursively.
      #
      every m := !self.children do
         if m.is_sub_menu() then {
            m.set_abs_coords(self.x + self.w, m.label_y - BORDER_WIDTH)
            m.resize()
         }
   end

   #
   # Deduce which label is under pointer, if any
   #
   # @p
   method which_item()
      every m := !self.children do {
         if /m.is_shaded_flag & (m.label_y <= &y < m.label_y + m.label_h) then
            return m
      }
   end

   method display()
      if /self.temp_win then {
         #
         # Open a temporary area for the menu and copy.
         #
         self.temp_win := WOpen("canvas=hidden", "size=" || self.w || "," || self.h)
         CopyArea(self.parent_component.get_parent_win(), self.temp_win, self.x, self.y, self.w, self.h, 0, 0)
      }

      cw := self.parent_component.cbwin

      #
      # Clear area and draw rectangle around whole
      #
      EraseRectangle(cw, self.x, self.y, self.w, self.h)
      DrawRaisedRectangle(cw, self.x, self.y, self.w, self.h)

      #
      # Draw individual items, with rectangle around open sub-item
      #
      every c := !self.children do {
         c.display_label(self.max_label_left_w, self.max_label_mid_w, self.max_label_right_w)
         if c === \self.which_open then 
            DrawRaisedRectangle(cw, c.label_x, c.label_y, self.w - 2 * BORDER_WIDTH, c.label_h)
      }
      CopyArea(cw, self.parent_component.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # If the presently selected item is a sub-menu, don't unselect it;
   # just close any non-sub-menu in it by calling recursively.
   #
   # @p
   method drag_off()
      if (\self.which_open).is_sub_menu() then
         return self.which_open.drag_off()
      else
         return self.set_which_open()
   end

   #
   # Set the selected sub item to x, whether or not it's a sub-menu
   #
   # @p
   method set_which_open(x)
      if self.which_open ~=== x then {
         if (\self.which_open).is_sub_menu() then
            self.which_open.hide()
         self.which_open := x
         if (\self.which_open).is_sub_menu() then
            self.which_open.display()
         self.display()
      }
      return x
   end

   #
   # Test whether pointer within label area.  Top and bottom borders are outside this region.
   #
   # @p
   method in_button_region()
      return (self.x <= &x < self.x + self.w) &  (self.y + BORDER_WIDTH <= &y < self.y + self.h - BORDER_WIDTH)
   end

   method handle_event(e)
      if self.in_button_region() then {
         if e === (&lpress | &rpress | &mpress) then
            #
            # Mouse press in region.  Open the item where the pointer is
            # or set to null (eg if over a shaded item).
            #
            self.set_which_open(self.which_item() | &null)
         else if e === (&lrelease | &rrelease | &mrelease) then {
            #
            # Mouse released over region
            #
            if \self.which_open then {
               #
               # If item selected and not a sub-menu, return its selected
               # event.  If sub-menu, this will just stay open.
               #
               if not(self.which_open.is_sub_menu()) then
                  self.which_open.succeed(e)
            } else
               #
               # Close completely, don't pass on event. 
               #
               close_all(1)
         } else if e === (-12 | &ldrag | &rdrag | &mdrag) then {
            #
            # Drag over region.
            #
            if t := self.which_item() then {
               if t === self.which_open then {
                  #
                  # Drag over label of open sub-item.  If a menu unselect any
                  # items, except sub menus.
                  #
                  if t.is_sub_menu() then
                     t.drag_off()
               } else
                  #
                  # Open the selected item.
                  #
                  self.set_which_open(t)
            } else
               #
               # Not over an item (eg shaded item).  Clear selection.
               #
               self.set_which_open()
         }
      } else {
         #
         # Not in region. 
         #
         if e === (-12 | &ldrag | &rdrag | &mdrag) then {         
            if (\self.which_open).is_sub_menu() then
               #
               # Pass event on to open sub menu.
               #
               self.which_open.handle_event(e)
            else
               #
               # Clear present selection, except sub-menus.
               #
               self.drag_off()        
         } else if e === (&lpress | &rpress | &mpress) then {
            if (\self.which_open).is_sub_menu() then
               #
               # Try open sub-menu.
               #
               self.which_open.handle_event(e)
            else
               #
               # Fail completely, pass on event to other objects.
               #
               close_all()
         } else if e === (&lrelease | &rrelease | &mrelease) then {
            if (\self.which_open).is_sub_menu() then
               #
               # Try open sub-menu.
               #
               self.which_open.handle_event(e)
            else
               #
               # Fail completely, don't pass on event.
               #
               close_all(1)
         }
      } 
   end

   #
   # Close this menu.
   #
   # @p
   method hide()
      #
      # Recursively close open sub-menu.
      #
      if (\self.which_open).is_sub_menu() then
         self.which_open.hide()
      self.which_open := &null

      #
      # Restore window area.
      #
      cw := self.parent_component.cwin
      EraseRectangle(cw, self.x, self.y, self.w, self.h)
      CopyArea(self.temp_win, self.parent_component.get_parent_win(), 0, 0, self.w, self.h, self.x, self.y)
      WClose(self.temp_win)
      self.temp_win := &null
   end

   initially(a[])
      self.SubMenu.initially()
      self.children := []
      self.set_img_right(img_style("arrow_right"))
      set_fields(a)
end
