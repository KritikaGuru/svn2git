#
# Standard (legacy) dialogs.
#
# These are primitive legacy Notice/TextDialog compatibility functions.
# They need to be improved/polished/expanded.
#

package gui

global dialog_value, dialog_button

$define ButtonWidth	 50	# minimum button width
$define ButtonHeight	 30	# button height
$define FieldWidth	 20	# default field width
$define OpenWidth	 50	# default field width for Open/SaveDialog

$define XOff		  0	# offset for text vidgets
$define XOffButton	 85	# initial x offset for buttons
$define XOffIncr	 15	# space between buttons

class vdialog : Dialog(captions, labels, buttons, textfields,
		       defaults, myanswer, label_width)
   method component_setup()
      self.setup()
   end

   method end_dialog()
   end

   method init_dialog()
   local maxw
      maxw := 0
      every maxw <:= TextWidth(win, !captions)
      maxw +:= 40
      maxw <:= 220
      self.resize_win(maxw, (32 * (*captions + *labels +2)))
      if textfields[1] then {
	 Enqueue(\win, &lpress, textfields[1].x+2, textfields[1].y+2)
	 }
   end

   method setup()
   local i, cap
   local nlines := *captions + *labels + 2
   local label_2, text_button_1, text_field_1

      self.set_attribs("size=220," || (32 * nlines))
      every i := 1 to *captions do {
	 cap := Label()
	 cap.set_pos("20", integer(i *100 / nlines)|| "%-5")
	 cap.set_internal_alignment("l")
	 cap.set_label(captions[i])
	 self.add(cap)
	 }
      every i := 1 to *labels do {
	 label_2 := Label()
	 label_2.set_pos(20, integer((*captions + i)*100/nlines) || "%")
	 label_2.set_internal_alignment("l")
	 label_2.set_label(labels[i])
	 self.add(label_2)
	 }
      every i := 1 to *labels do {
	 text_field_1 := TextField()
	 text_field_1.set_pos(20+label_width,
			      integer((*captions + i)*100/nlines) || "%-10")
	 text_field_1.set_size(180, 30)
	 text_field_1.set_contents((\defaults)[i])
	 text_field_1.set_draw_border()
         if \dialogFor == "find" then
	    text_field_1.set_contents(findstr)
         else if \dialogFor == "goto" then
	    text_field_1.set_contents(gotoln)
         else if \dialogFor == "compile" then
	    text_field_1.set_contents(targs)
         else if \dialogFor == "run" then
	    text_field_1.set_contents(xargs)
         else text_field_1.set_contents("")
	 text_field_1.connect(self, "on_keypress", ACTION_EVENT)

	 self.add(text_field_1)
	 put(textfields, text_field_1)
	 }
      every i := 1 to *buttons do {
	 text_button_1 := TextButton()
	 text_button_1.set_pos( integer(i * 100 / (*buttons+1)) || "%-20",
			       integer((*captions + *labels + 1)*100/nlines) ||
			       "%" )
	 text_button_1.connect(self, "on_button", ACTION_EVENT)
	 text_button_1.clear_toggles()
	 text_button_1.set_label(buttons[i])
	 text_button_1.set_internal_alignment("c")
	 self.add(text_button_1)
	 }
   end

   method on_button(ev)
      if ev.param === -12 then fail # do not trigger on mouse moves
      myanswer := ev.source.label
      dispose()
   end

   method on_keypress(ev)
      if ev.param === -12 then fail # do not trigger on mouse moves
      myanswer := buttons[1]
      if ev.param === "\r" then
	 dispose()
   end

initially(caps, labs, btns, dflts, labwid)
   captions := caps
   labels := labs
   buttons := btns
   defaults := dflts
   label_width := labwid
   textfields := []
   self.Dialog.initially()
end


procedure TextDialog(			#: text dialog
   win, captions, labels, defaults, widths, buttons, index
   )
local default_width, default_button, maxl, id, label_width, maxb, lead, pad,
      cwidth, dialog, maxw, y, temp_win

   if type(win) ~== "window" then {
      win :=: captions :=: labels :=: defaults :=: widths :=: buttons :=:
         index
      win := &window
      /win := temp_win := WOpen("canvas=hidden", "bg=gray")
      }

   /captions := []
   /labels := []
   /defaults := []
   /widths := []
   /buttons := ["Okay", "Cancel"]
   /index := 1

   if type(captions) ~== "list" then captions := [captions]
   if type(labels) ~== "list" then labels := ([\labels] | [])
   if type(defaults) ~== "list" then defaults := ([\defaults] | [])
   if type(widths) ~== "list" then widths := ([\widths] | [default_width])
   if type(buttons) ~== "list" then buttons := [buttons]

   default_button := buttons[index] 		# null if out of bounds
   default_width := widths[-1] | FieldWidth

   maxl := 0
   every maxl <:= *(labels | defaults | widths)
   until *labels = maxl do put(labels, labels[-1] | "")
   until *defaults = maxl do put(defaults, defaults[-1] | "")
   until *widths = maxl do put(widths, widths[-1] | 10)

   id := 0

   label_width := 0
   every label_width <:= TextWidth(win, !labels)
   if label_width > 0 then label_width +:= 15

   maxb := 0
   every maxb <:= TextWidth(win, !buttons)
   maxb +:= 10
   maxb <:= ButtonWidth

   lead := WAttrib(win, "leading")
   pad := 2 * lead
   cwidth := WAttrib(win, "fwidth")

   dialog := vdialog(captions, labels, buttons, defaults, label_width)

   maxw := 0
   every maxw <:= TextWidth(win, !captions)

   y := -lead

   dialog.show_modal()
   dialog_button := dialog.myanswer
   dialog_value := []
   every put(dialog_value, (!(dialog.textfields)).get_contents())
   return dialog_button
end

procedure Notice(captions[])		#: notice dialog
   local win, temp_win, p
   static type

   initial type := proc("type", 0)	# protect attractive name

   if type(captions[1]) == "window" then
      win := get(captions)
   else {
      win := &window
      /win := temp_win := WOpen("canvas=hidden", "bg=gray")
      }

   # use built-in if available
   if \is_MSWindows & (p := proc("WinSelectDialog", 0)) then {
      p(win, captions)
      dialog_button := "Okay"
      }
   else
      TextDialog(win, captions, , , , "Okay")

   dialog_value := &null
   WClose(\temp_win)
   return dialog_button
end
