#####################################################################
#
# Unicon Profiler v0.7
# Author: Leah Wegner
# Maintainer: Clinton Jeffery, Gigi Young
# March 20, 2018
#
# Notes:
#  The granularity of the timing mechanism on classic Linux was 10 milliseconds,
#  and even after improvements to the code, &time uses 1ms units and can't do better.
#  This causes inaccurate timing results for procedures that typically complete in
#  0ms, 1ms, or only a few milliseconds. For such procedures, it might be more
#  beneficial to look only at procedure counts instead of run-time.
#
# To Do:
#  Check and correct profiling for programs with co-expressions
#  Design and implement higher-resolution timing mechanisms.
#
####################################################################


link evinit
link evnames
link evsyms
link options
link printf
$include "evdefs.icn"

global Proc_stack
global Call_time_stack
global keys
global keys2
record lkey(keyval, timeval)

procedure main(args)
   #Declarations
   local opts
   local output
   local symmap
   local val

   local Proc_calls := table(0)
   local Proc_fails := table(0)
   local Proc_returns := table(0)
   local Proc_suspends := table(0)
   local Proc_resumes := table(0)

   local Proc_time := table(0)
   local Proc_alone_time := table(0)
   local proc_start_time := 0
   local proc_end_time := 0
   local mask := ProcMask
   local lastline, lines
   local line_time := table(0), line_count := table(0)
   local longest_filename_length := 0
   
   if (*args=0) | (args[1] == ("--help"|"-help")) then
       stop("usage: uprof [-l] uniconprogram args\n",
	    "  (the -l option enables line-level time sampling)")

   if args[1] == "-o" then { pop(args); output := pop(args) }
   else if match("-o", args[1]) then output := pop(args)[3:0]
   else output := &errout

   if args[1] == "-l" then { pop(args); lines := 1; mask ++:= E_Line }

   #initializations
   symmap := evsyms()
   Proc_stack := list()
   Call_time_stack := list()

   EvInit(args) | stop("*** cannot open program to monitor")

   while EvGet(mask) do {
      val := &eventvalue

   #Build the tables
      case &eventcode of {
	 E_Line: {
	     linetime := keyword("time", Monitored)
	     linefile := keyword("file", Monitored)
	     longest_filename_length <:= *linefile
	     line_count[linefile||":"||&eventvalue] +:= 1
	     if delta := (0 < linetime-\last_linetime) then {
		 line_time[linefile||":"||&eventvalue] +:= delta
	     }
	     last_linetime := linetime
	 }

         #CALL
         E_Pcall: {
            push(Proc_stack, val)
            push(Call_time_stack, (keyword("&time", Monitored)))
	    Proc_calls[val] +:= 1
         }

         #FAIL
         E_Pfail: {
            Current_proc := pop(Proc_stack)
            proc_start_time := pop(Call_time_stack)
            proc_end_time := keyword("&time", Monitored)

            Proc_fails[val] +:= 1

            curr_proc_time := proc_end_time - proc_start_time
            Proc_time[Current_proc] +:= curr_proc_time

            if *Proc_stack > 0 then {
                # subtract this proc's runtime from next proc on stack 
                Proc_time[Proc_stack[1]] -:= curr_proc_time 
            }
         }

         #RETURN
         E_Pret: {
            Current_proc := pop(Proc_stack)
            proc_start_time := pop(Call_time_stack)
            proc_end_time := keyword("&time", Monitored)

            Proc_returns[Current_proc] +:= 1

            curr_proc_time := proc_end_time - proc_start_time
            Proc_time[Current_proc] +:= curr_proc_time

            if *Proc_stack > 0 then {
                # subtract this proc's runtime from next proc on stack 
                Proc_time[Proc_stack[1]] -:= curr_proc_time
            }
         }

         #SUSPEND
         E_Psusp: {
            Current_proc := pop(Proc_stack)
            proc_start_time := pop(Call_time_stack)
            proc_end_time := keyword("&time", Monitored)

            Proc_suspends[Current_proc] +:= 1

            curr_proc_time := proc_end_time - proc_start_time
            Proc_time[Current_proc] +:= curr_proc_time

            if *Proc_stack > 0 then {
                # subtract this proc's runtime from next proc on stack 
                Proc_time[Proc_stack[1]] -:= curr_proc_time
            }

         }

         #RESUME
         E_Presum: {
            push(Proc_stack, val)
            Proc_resumes[val] +:= 1

            push(Call_time_stack, (keyword("&time", Monitored)))
         }
      }
   }

   if *Proc_stack > 0 then {
      write(output, "Execution left ", *Proc_stack, " frames.")
      while *Proc_stack >= 0 do {
         Current_proc := pop(Proc_stack)
         proc_start_time := pop(Call_time_stack)
         Proc_fails[Current_proc] +:= 1

         proc_end_time := keyword("&time", Monitored)

         curr_proc_time := proc_end_time - proc_start_time
         Proc_time[Current_proc] +:= curr_proc_time 
         if *Proc_stack > 0 then {
             # subtract this proc's runtime from next proc on stack 
             Proc_time[Proc_stack[1]] -:= curr_proc_time 
         }

      }
   }

   # calculate total time
   total := 0
   every y := key(Proc_time) do total +:= Proc_time[y]

   #sort the output
   keys := list()
   every y := key(Proc_time) do {
      x := lkey(y, divimage(Proc_time[y]*100,total))
      push(keys, x)
      }
   keys := reverse(sortf(keys, 2))

   mxname := 15
   every mxname <:= *image((!keys).keyval)[10:0]

   #output
   write(output)

   write(output, 
         left("PROCEDURE",mxname), 
         right("%TIME", 6), 
	 right("TIME", 10), 
         right("CALLS", 12), 
         right("RETS", 12),
	 right("FAILS", 10), 
         right("SUSP", 10), 
         right("RESUM",10), 
         right("TIME/CALL", 12))
   write(output, 
         right("",mxname), 
         right("", 6), 
	 right("(ms)", 10), 
         right("", 12), 
         right("", 12),
	 right("", 10), 
         right("", 10), 
         right("",10), 
         right("(ms)", 12))

   every y := (!keys).keyval do {
      write(output,
	     left((image(y))[10:0], mxname),
	     right(divimage(Proc_time[y]*100,total), 6),
	     right(Proc_time[y], 10),
	     right(Proc_calls[y], 12), 
             right(Proc_returns[y], 12),
	     right(Proc_fails[y], 10), 
             right(Proc_suspends[y], 10),
	     right(Proc_resumes[y],10),
             right(sprintf("%.3r",divimage(Proc_time[y],
		   real(Proc_fails[y]+Proc_returns[y]+Proc_suspends[y]))),12))
   }

   write("\nTOTAL RUNTIME: ",sprintf("%.3r",real(total)*0.001),"s\n")

   if \lines then {
       write(output)
       write(output,
	     printf("%"||(longest_filename_length+1)||"s %8s %8s %8s %8s",
		    "FILE", "LINE", "TIME", "LINE ", "TIME/LN"))
       write(output,
	     printf("%"||(longest_filename_length+1)||"s %8s %8s %8s %8s",
		    "    ", "    ", "(ms)", "COUNT", "  (ms) "))
       L := reverse(sort(line_time,2))
       every le := !L do {
	  write(output,
		printf("%"||(longest_filename_length+1)||"s %8d %8d %8d   %.3r",
		       le[1][1:find(":",le[1])], le[1][find(":",le[1])+1:0],
		       le[2], line_count[le[1]],
		       divimage(le[2], real(line_count[le[1]]))))
       }
   }

end

#
# return an image of a division
#
procedure divimage(num,denom)
    if num = 0 then return 0
    else if denom = 0 then return 0
    else return num/denom
end
