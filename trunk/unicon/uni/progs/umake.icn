#
# umake.icn - Unicon version of the "make" program
#
# UNDER CONSTRUCTION. DOES NOT WORK YET.
#
# Reasons for the existence of this program:
#
# 1. link directly into IDE, do not launch an external process
# 2. do not depend on end user to install a make.exe
# 3. lingo-supremacist hubris. Write a shorter make in your language.

$ifdef MAIN
procedure main(argv)
   make(argv)
end
$endif

global depgraph, macros, filechars, noexec, verbose

procedure make(argv)
   macros := table("")
   noexec := 1 # hardwire to -n for now
   (depgraph := DepGraph("makefile")).make()
end

#
# make is organized around a dependency graph. The nodes are labeled by targets.
#
class DepGraph(targets, initialtarget, marked)
   method mark(s)
      insert(marked, s)
   end
   method ismarked(s)
      return member(marked,s)
   end
   method node(s)
      return \ targets[s]
      if stat(s) then fail # no node for s, but it exists
      stop("no rule to make ", image(s))
   end
   method make(targ)
      /targ := initialtarget
      if /targ then stop("no initial target? can't make.")
      targets[targ].make()
   end
initially(filename)
   filechars := &letters ++ './_%'
   targets := table()
   marked := set()
   fstack := []
   readahead := []
   if f := open(\filename) then {
      while line := (pop(readahead) | read(f) | (close(f) & (f:=pop(fstack)) & read(f))) do {
	 line := macroexpand(line)
         line ? {
	    tab(many(' '))
	    if ="#" then { # skip comment
	       write("comment: ", image(line))
	       continue
	       }
	    else if pos(0) then { # skip empty lines
	       continue
	       }
	    else if (target:=tab(many(filechars))) &
               (tab(many(' '))|"") & =":" then { # build a target
	       tab(many(' '))
	       deps := []
	       buildrules := []
	       while dependency := tab(many(filechars)) do {
		  put(deps,dependency)
		  tab(many(' '))
		  }
	       while (line := read(f)) & (line[1]=="\t") do {
		  put(buildrules, macroexpand(line[2:0]))
		  line := &null
		  }
	       put(readahead, \line)
	       r := Rule(target,deps,buildrules)
	       targets[target] := r
	       if not find("%", target, 1) then
		  /initialtarget := target
	       }
	    else if (macroname:=tab(many(filechars))) &
               (tab(many(' '))|"") & ="=" then { # build a macro
	       macros[macroname] := macroexpand(tab(0))
	       if \verbose then
		  write("macro ", macroname, " defined as ", macros[macroname])
	       }
	    else if ="include" & tab(many(' \t')) &
	       (inclname := tab(many(filechars))) then {
		  push(fstack, f)
		  write("including ", image(inclname))
		  f := open(inclname)
		  }
	    else if ="export" & tab(many(' \t')) &
	       (envname := tab(many(filechars))) & =":=" & (val:=tab(0)) then {
		  #what the heck, let's expand macro names
		  val := macroexpand(val)
		  if \verbose then
		     write("setting ", envname, " to ", image(val))
# if Windows... do we need to map PATH to Path, or is PATH OK?
# need to test.  Mebbe PATH is OK.
		  setenv(envname, val)
		  }
	    else write("??? ", image(line))
	    }
         }
      close(f)
      }
   else if \filename then stop("can't open ", image(filename))
   else stop("usage: umake ... (reads makefile)")
end

class Rule(target, dependencies, buildrules)
   method make()
      if depgraph.ismarked(target) then {
	 write("make ", target, " (already made)")
	 }
      else {
	 write("make ", target)
	 depgraph.mark(target)
	 }
      # first, recursively build dependencies
      every depgraph.node(!dependencies).make()

      # check timestamps of dependencies against my timestamp
      every d := !dependencies do {
	 if newer(d) then {      # if needed, execute build rules
	    exec()
	    return
	    }
	 }
      write("umake: `",target, "' is up to date")
   end
   # check me (target timestamp) against d and succeed if d is newer
   method newer(d)
   local mytimestamp, theirtimestamp
      if not (mytimestamp := stat(target).mtime) then return
      if not (theirtimestamp := stat(d).mtime) then
	 stop(target, " depends on ", d, " but it didn't get built")
      if \verbose then
	 write("   ", target,": ", image(mytimestamp), ", ",
	       d, ": ", image(theirtimestamp))
      if mytimestamp < theirtimestamp then return
   end
   method exec()
      every r := !buildrules do {
	 if \noexec then write(r)
	 else {
	    if not (rv := system(r)) then
	       stop("umake: system(",image(r),") failed")
	    if rv ~=== 0 then stop("umake: ", rv, " exit by ", image(r))
	    }
	 }
   end
   method print()
       writes("target ", image(target), " : ")
       every writes(" ", image(!dependencies))
       write()
       write("built by")
       every write("\t", image(!buildrules))
   end
end

procedure macroexpand(s)
   s ? {
      while tab(i := upto('$')) &
	    ="$(" & (mac := tab(many(filechars))) & =")" do {
	 if not member(macros, mac) then {
	    if val := getenv(mac|initcap(mac)|map(mac)) then
	       macros[mac] := val
	    else write("warning: empty macro ", mac)
	    }
	 s[i +: *mac+3] := macros[mac]
	 &subject := s; &pos := i
	 }
      }
   return s
end

procedure initcap(s)
   return map(s[1],&lcase,&ucase) || map(s[2:0])
end

