#
# $Id: httpclient.icn,v 1.9 2004-09-05 16:08:38 rparlett Exp $
#

package http

import util
import lang
import net
import mail

$include "posix.icn"

global token_char

#
# An http client
#
class HttpClient : NetClient(url,
                             result,
                             open_url,
                             post_data,
                             headers,
                             request_type,
                             data_file,
                             data_out,
                             string_buff,
                             retries,
                             length,
                             read,
                             http_version,
                             http_error,
                             username,
                             password,
                             user_agent,
                             referer,
                             redir_set, 
                             auth_req_count,
                             auth_scheme,
                             basic_auth_header,
                             nonce,
                             nonce_count,
                             cnonce,
                             opaque,
                             ha1,
                             qop,
                             realm,
                             last_method,
                             last_uri,
                             last_post_data
                             )

   #
   # Set the desired url.  NB: setting the URL clears any custom header
   # fields that may have been set.  They must be set again using
   # {set_header()}.
   #
   method set_url(url)
      headers := table()
      return self.url := url
   end

   #
   # Set a filename to send the data part of the response to.  If not
   # set then the data forms part of the HttpPage object returned.
   #
   # @param s the name of the file.
   #
   method set_data_file(s)
      return data_file := s
   end

   #
   # Set the http version to use; by default "1.0"
   #
   method set_http_version(s)
      return http_version := s
   end

   #
   # Set the data to be used in a POST request.
   #
   # @param   post_data    The data to use this may either be a string, in
   # @        which case it represents raw data, or it may be
   # @        be a table in which case it represents a table of
   # @        cgi parameters, which will be converted appropriately.
   #
   method set_post_data(post_data)
      return self.post_data := post_data
   end

   #
   # Set the request type.  The default is {GET}, unless post data is set, in which
   # case the default is {POST}.
   #
   method set_request_type(request_type)
      return self.request_type := request_type
   end

   #
   # Set the user-agent identification
   #
   method set_user_agent(s)
      return self.user_agent := s
   end

   #
   # Set the referer page.
   #
   method set_referer(s)
      return self.referer := s
   end

   #
   # Set the username to use for authentication
   #
   method set_username(s)
      return self.username := s
   end

   #
   # Set the password to use for authentication
   #
   method set_password(s)
      return self.password := s
   end

   #
   # Set a header variable to the desired value.
   #
   method set_header(key, value)
      return headers[map(key)] := value
   end

   #
   # @p
   method write_headers()
      every e := !sort(headers) do {
         e[1][1] := map(e[1][1], &lcase, &ucase)
         write_line(e[1] || ": " || e[2]) | fail
      }
      return
   end

   #
   # Set the number of retries to use.  The default is two.
   #
   method set_retries(retries)
      return self.retries := retries
   end

   #
   # Setup a temporary file for the {GetHttpProcessControl} object to use
   # as a data file.  On success, this will be returned as a field in the
   # {HttpPage} object.
   #
   method set_use_temporary_data_file()
      set_data_file("/tmp/gethttp." || curr_time_millis() || ".bin")
   end

   #
   # This method invokes retrieve_page, but only returns the page if
   # its status was 200 OK - otherwise it fails and sets the failure
   # reason appropriately.  It also handles redirection and authentication
   # request responses.
   #
   method retrieve()
      auth_req_count := 0
      redir_set := set()
      repeat {
         http_error := &null

         retrieve_page() | fail
         if find("200"|"206", result.get_status()) then
            return result

         remove(\data_file)

         if find("401", result.get_status()) then
            handle_authentication() | fail
         else if find("302"|"303"|"307", result.get_status()) then
            handle_redirect() | fail
         else
            return on_http_error(result.get_status())
      }
   end

   #
   # @p
   method handle_redirect()
      local l
      #
      # A redirection, so extract the URL if possible.
      #
      l := \result.get_header("Location") | return on_http_error("No Location in a redirect response")
      if member(redir_set, l) then
         return on_http_error("Circular redirection detected:" || l)
      insert(redir_set, l)
      url := URL(l) | return on_http_error("Invalid Location in a redirect response:" || l)
      auth_req_count := 0
      return
   end

   #
   # @p
   method handle_authentication()
      local s, t
      if /(username | password) then
         return on_http_error("Authentication requested - please set username, password")

      if auth_req_count > 0 then
         return on_http_error("Failed to authenticate - correct username, password")
      auth_req_count +:= 1

      s := \result.get_header("www-authenticate") | 
         return on_http_error("No WWW-Authenticate in a 401 response")

      t := parse_generic_header(s)
      if member(t, "Basic") then {
         auth_scheme := "Basic"
         return setup_basic_authentication()
      }
      if member(t, "Digest") then {
         auth_scheme := "Digest"
         return setup_digest_authentication()
      }

      return on_http_error("WWW-Authenticate header contained unknown authentication method.")
   end

   #
   # @p
   method setup_basic_authentication(t)
      local b64h, s
      b64h := Base64Handler()
      # Strip of any \r\n in result.
      s := ""
      b64h.encode_data(&null, username || ":" || password) ? repeat {
         s ||:= tab(find("\r\n") | 0)
         if pos(0) then
            break
         move(2)
      }
      basic_auth_header := "Basic " || s
      return
   end

   #
   # @p
   method setup_digest_authentication(t)
      local algorithm, md5, qop_options

      self.realm := \t["realm"] | 
         return on_http_error("WWW-Authenticate digest header didn't contain a realm")
      self.nonce := \t["nonce"] | 
         return on_http_error("WWW-Authenticate digest header didn't contain a nonce")
      self.opaque := t["opaque"] 

      algorithm := \t["algorithm"] | "MD5"
      self.nonce_count := 0
      self.cnonce := "0a4f113b"
      
      #
      # Calculate HA1
      #
      md5 := MD5()
      md5.update(unq(username) || ":" || unq(realm) || ":" || password)
      if map(unq(algorithm)) == "md5-sess" then {
         md5.update(":" || unq(nonce) || ":" || unq(cnonce))
      }
      self.ha1 := md5.final_str()

      #
      # Get the available qop values and select a qop.
      #
      qop_options := set()
      \t["qop"] ? {
         while(tab(upto(token_char))) do 
            insert(qop_options, map(tab(many(token_char))))
      }
      self.qop := member(qop_options, "auth-int" | "auth") | &null
   end

   #
   # @p
   method create_digest_authorization_header()
      local md5, nc, h

      self.nonce_count +:= 1
      nc := map(format_int_to_string(self.nonce_count, 16, 8))
      md5 := MD5()
      #
      # Calculate HA2
      #
      md5.update(last_method || ":" || last_uri)
      if \qop == "auth-int" then {
         # Calculate H(entity)
         t := MD5()
         t.update(last_post_data)
         hentity := t.final_str()
         md5.update(":" || hentity)
      }

      ha2 := md5.final_str()

      md5.update(ha1 || ":" || unq(nonce) || ":")
      if \self.qop then
         md5.update(nc || ":" || unq(cnonce) || ":" || unq(qop) || ":")

      md5.update(ha2)

      h := "Digest username=\"" || username || "\",\r\n\t" ||
         "realm=" || realm || ",\r\n\t" ||
         "nonce=" || nonce || ",\r\n\t" ||
         "uri=\"" || last_uri || "\",\r\n\t"
      if \qop then {
         h ||:= "qop=" || qop || ",\r\n\t" ||
            "nc=" || nc || ",\r\n\t" ||
            "cnonce=" || cnonce || ",\r\n\t"
      }
      if \opaque then
         h ||:= "opaque=" || opaque || ",\r\n\t"
      h ||:= "response=\"" || md5.final_str() || "\""

      return h
   end

   #
   # @p
   method unq(s)
      if s[1] == "\"" then 
         s[1] := ""
      if s[-1] == "\"" then 
         s[-1] := ""
      return s
   end

   #
   # @p
   method parse_generic_header(s)
      local t, k, v

      t := table()
      s ? repeat {
         tab(upto(token_char)) | break
         k := tab(many(token_char))
         if ="=" then {
            if any('\"') then
               v := parse_quoted_string()
            else
               v := tab(many(token_char))
         } else
            v := &null
         insert(t, k, v)
      }
      return t
   end

   #
   # @p
   method parse_quoted_string()
      local res
      res := ""
      res ||:= ="\""
      repeat {
         res ||:= tab(upto('\\\"') | 0)
         if pos(0) then
            break
         if res ||:= ="\"" then
            break
         if any('\\') then {
            res ||:= move(2)
         }
      }
      return res
   end

   #
   # @p
   method create_authorization_header()
      case auth_scheme of {
         "Basic":
            return create_basic_authorization_header()
         "Digest":
            return create_digest_authorization_header()
         default:
            fail
      }
   end

   #
   # @p
   method create_basic_authorization_header()
      return basic_auth_header
   end

   #
   # @p
   method on_http_error(s)
      http_error := s
      return error(s)
   end

   #
   # After invoking retrieve(), this method can be used to determine
   # whether a failure was caused by a network failure or an HTTP failure
   # (for example 404 not found).  In the former case, &null is returned; in
   # the latter case the error string is returned.
   #
   method get_http_error()
      return http_error
   end

   #
   # @p
   method maybe_open()
      if /connection | /open_url | open_url.get_address() ~== url.get_address() |
         open_url.get_port() ~= url.get_port() then 
      {
         close()
         set_server(url.get_address())
         set_port(url.get_port())
         open() | fail
         open_url := url.clone()
      }
      return
   end

   #
   # Retrieve the given url.  A {HttpPage} object is returned upon success.
   # Failure occurs if the url could not be retrieved.
   #
   method retrieve_page()
      local i

      i := retries

      self.read := self.length := &null

      repeat {
         if tryone() then {
            fire("Complete")
            return result
         }

         close()

         if (i -:= 1) < 0 then {
            remove(\data_file)
            fire("Failed")
            if retries = 0 then
               fail
            else
               return error("Gave up after " || (1+retries) || " attempts - last reason:" || get_reason())
         }

         fire("Retrying")
      }
   end

   #
   #
   # Retrieve the given url.  A {HttpPage} object is returned upon success.
   # Failure occurs if the url could not be retrieved.
   #
   method tryone()
      #
      # Open the connection
      #
      maybe_open() | fail

      #
      # Write the request
      #
      write_request() | fail

      #
      # Create a result
      #
      result := HttpPage()
      result.set_url(url)
      result.set_status(read_line()) | fail

      #
      # Read the response.
      #
      read_headers() | fail

      if request_type ~=== "HEAD" then
         read_data() | fail
      else
         maybe_close()

      return
   end

   #
   # @p
   method maybe_close()
      #
      # Close if told to do so.
      #
      if map(\result.get_header("connection")) == "close" then
         close()
   end

   #
   # @p
   method write_request()
      headers["user-agent"] :=  user_agent
      headers["host"] := url.get_address()
      headers["referer"] := \referer
      /headers["connection"] := "Keep-Alive"

      if \self.read > 0 then
         headers["range"] := "bytes=" || self.read || "-"
      else
         delete(headers, "range")

      last_method := \request_type | if \post_data then "POST" else "GET"
      last_uri := url.get_file()

      write_line(last_method || " " || last_uri || " HTTP/" || http_version) | fail

      if /post_data then {
         last_post_data := ""
         headers["authorization"] := create_authorization_header()
         write_headers() | fail
         write_line() | fail
      } else {
         #
         # Add the post data, convert from table if necessary
         #
         if lang::get_type(post_data) == "table" then {
            #
            # Convert from table in exactly the same way as for a GET parameter string.
            # In this case always use the standard content-type encoding.
            #
            last_post_data := URL().make_cgi_string(post_data)
            headers["content-type"] := "application/x-www-form-urlencoded"
         } else {
            #
            # Allow user content-type encoding if specified for this arbitrary data.
            #
            last_post_data := post_data
            /headers["content-type"] := "application/x-www-form-urlencoded"
         }
         headers["content-length"] := *last_post_data
         headers["authorization"] := create_authorization_header()
         write_headers() | fail
         write_line() | fail
         write_str(last_post_data) | fail
      }

      return
   end

   #
   # @p
   method read_headers()
      local s, key, val
      repeat {
         s := read_line() | fail
         if *s = 0 then
            break
         s ? {
            #
            # A continuation line starts with a space or a tab.
            #
            if any(' \t') then
               result.get_header(\key) ||:= tab(0)
            else {
               key := tab(upto(':') | 0)
               =": "
               val := tab(0)
               result.get_header(key) := val
            }
         }
      }
      return
   end

   #
   # @p
   method read_data()
      if find("206", result.get_status()) then {
         #
         # Continue a partial read.  The self.read and self.length values
         # continue from the previous attempt.
         #
         if \data_file then
            data_out := ::open(data_file, "a") | stop("Couldn't open ", data_file)
      } else {
         #
         # Set up either a new data file or a string buffer, and reset
         # the self.read and self.length values.
         #
         if /data_file then
            string_buff := StringBuff()
         else
            data_out := ::open(data_file, "w") | stop("Couldn't open ", data_file)

         self.length := integer(result.get_header("content-length")) | &null
         self.read := 0
      }

      if not read_data_impl() then {
         if \data_file then
            ::close(\data_out)
         fail
      }

      #
      # Close the result
      #
      if /data_file then 
         result.set_data(string_buff.get_string())
      else {
         ::close(\data_out)
         result.set_data_file(data_file)
      }

      return
   end

   #
   # @p
   method read_data_impl()
      #
      # Read the data.
      #
      if map(\result.get_header("transfer-encoding")) == "chunked" then
         return read_chunked()
      else if /length then
         return read_to_eof()
      else
         return read_length()
   end

   #
   # @p
   method read_chunked()
      local l, chunk, s
      repeat {
         l := read_line() | fail
         l ? {
            chunk := integer("16r" || tab(many('0987654321abcdefABCDEF'))) |
               return error("Expected chunk-length specifier; got " || l)
         }
         if chunk = 0 then
            break
         while chunk > 0 do {
            s := read_str(min(1024, chunk)) | fail
            add_some(s)
            chunk -:= *s
         }
         l := read_line() | fail
         if *l > 0 then
            return error("Expected empty line at end of chunk")
      }
      #
      # Read any trailing lines, upto an empty line.
      #
      repeat {
         l := read_line() | fail
         if *l = 0 then
            break
      }

      maybe_close()

      return
   end

   #
   # @p
   method read_to_eof()
      #
      # No content length.  Read until eof, then close.
      #
      while s := read_str(1024) do
         add_some(s)

      #
      # Check for errors that may have caused read_str to fail.
      #
      if &errno ~= 0 then {
         close()
         fail
      }

      close()

      return
   end

   #
   # @p
   method read_length()
      #
      # Got a content length.  Read len bytes and leave the connection
      # open - unless told to close it.
      #
      while self.read < length do {
         s := read_str(min(1024, length - self.read)) | fail
         add_some(s)
      }

      maybe_close()

      return
   end

   #
   # Return the length of the current download, or &null if unknown
   #
   method get_length()
      return self.length
   end

   #
   # Return the number of bytes read so far.
   #
   method get_read()
      return self.read
   end

   #
   # @p
   method add_some(s)
      self.read +:= *s
      fire("Progress")
      if /data_file then
         string_buff.add(s)
      else
         writes(data_out, s)
   end

   method set_one(attr, val)
      local s, u
      case attr of {
         "url": {
            s := string_val(attr, val)
            u := URL(s) | stop("Bad URL:" || s)
            set_url(u)
         }
         "data_file": set_data_file(string_val(attr, val))
         "http_version": set_http_version(string_val(attr, val))
         "request_type": set_request_type(string_val(attr, val))
         "retries": set_retries(int_val(attr, val))
         default: self.NetClient.set_one(attr, val)
      }
   end

   initially(a[])
      initial {
         token_char := &ascii[33:128] -- '()<>@,;:\\\"/[]?={} \t'
      }
      self.NetClient.initially()
      headers := table()
      timeout := 12000
      retries := 2
      http_version := "1.1"
      user_agent := "gethttp.icn [en] (" || &host || ")"
      set_fields(a)
end
