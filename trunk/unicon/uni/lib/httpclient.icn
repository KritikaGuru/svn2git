package http

import util
import lang
import net

$include "posix.icn"

#
# An http client
#
class HttpClient : NetClient(url,
                             result,
                             open_url,
                             post_data,
                             headers,
                             request_type,
                             data_file,
                             data_out,
                             string_buff,
                             retries,
                             length,
                             read,
                             http_version,
                             http_error
                             )

   #
   # Set the desired url
   #
   method set_url(url)
      headers := table()
      return self.url := url
   end

   #
   # Set a filename to send the data part of the response to.  If not
   # set then the data forms part of the HttpPage object returned.
   #
   # @param s the name of the file.
   #
   method set_data_file(s)
      return data_file := s
   end

   #
   # Set the http version to use; by default "1.0"
   #
   method set_http_version(s)
      return http_version := s
   end

   #
   # Set the data to be used in a POST request.
   #
   # @param   post_data    The data to use this may either be a string, in
   # @        which case it represents raw data, or it may be
   # @        be a table in which case it represents a table of
   # @        cgi parameters, which will be converted appropriately.
   #
   method set_post_data(post_data)
      return self.post_data := post_data
   end

   #
   # Set the request type.  The default is {GET}, unless post data is set, in which
   # case the default is {POST}.
   #
   method set_request_type(request_type)
      return self.request_type := request_type
   end

   #
   # Set a header variable to the desired value.
   #
   method set_header(key, value)
      return headers[map(key)] := value
   end

   #
   # @p
   method write_headers()
      every e := !sort(headers) do {
         e[1][1] := map(e[1][1], &lcase, &ucase)
         write_line(e[1] || ": " || e[2]) | fail
      }
      return
   end

   #
   # Set the number of retries to use.  The default is two.
   #
   method set_retries(retries)
      return self.retries := retries
   end

   #
   # Setup a temporary file for the {GetHttpProcessControl} object to use
   # as a data file.  On success, this will be returned as a field in the
   # {HttpPage} object.
   #
   method set_use_temporary_data_file()
      set_data_file("/tmp/gethttp." || curr_time_millis() || ".bin")
   end

   #
   # This method invokes retrieve_page, but only returns the page if
   # its status was 200 OK - otherwise it fails and sets the failure
   # reason appropriately.  It also handles redirection responses.
   #
   method retrieve()
      local res, l, redir_set
      redir_set := set()
      repeat {
         http_error := &null

         res := retrieve_page() | fail
         if res.status_okay() then
            return res

         remove(\data_file)
         if find("302"|"303"|"307", res.get_status()) then {
            #
            # A redirection, so extract the URL if possible.
            #
            l := \res.get_header("Location") | return on_http_error("No Location in a redirect response")
            if member(redir_set, l) then
               return on_http_error("Circular redirection detected:" || l)
            insert(redir_set, l)
            url := URL(l) | return on_http_error("Invalid Location in a redirect response:" || l)
            delete(headers, "host")
         }
         else
            return on_http_error(res.get_status())
      }
   end

   #
   # @p
   method on_http_error(s)
      http_error := s
      return error(s)
   end

   #
   # After invoking retrieve(), this method can be used to determine
   # whether a failure was caused by a network failure or an HTTP failure
   # (for example 404 not found).  In the former case, &null is returned; in
   # the latter case the error string is returned.
   #
   method get_http_error()
      return http_error
   end

   #
   # @p
   method maybe_open()
      if /connection | /open_url | open_url.get_address() ~== url.get_address() |
         open_url.get_port() ~= url.get_port() then 
      {
         close()
         set_server(url.get_address())
         set_port(url.get_port())
         open() | fail
         open_url := url.clone()
      }
      return
   end

   #
   # Retrieve the given url.  A {HttpPage} object is returned upon success.
   # Failure occurs if the url could not be retrieved.
   #
   method retrieve_page()
      local i, res

      i := retries
      repeat {
         if res := tryone() then {
            fire("Complete")
            return res
         }

         remove(\data_file)
         close()

         if (i -:= 1) < 0 then {
            fire("Failed")
            if retries = 0 then
               fail
            else
               return error("Gave up after " || (1+retries) || " attempts - last reason:" || get_reason())
         }

         fire("Retrying")
      }
   end

   #
   #
   # Retrieve the given url.  A {HttpPage} object is returned upon success.
   # Failure occurs if the url could not be retrieved.
   #
   method tryone()
      #
      # Open the connection
      #
      maybe_open() | fail

      #
      # Write the request
      #
      write_request() | fail

      #
      # Create a result
      #
      result := HttpPage()
      result.set_url(url)
      result.set_status(read_line()) | fail

      #
      # Read the response.
      #
      read_headers() | fail

      if request_type ~=== "HEAD" then
         read_data() | fail
      else
         maybe_close()

      return result
   end

   #
   # @p
   method maybe_close()
      #
      # Close if told to do so.
      #
      if map(\result.get_header("connection")) == "close" then
         close()
   end


   #
   # @p
   method write_request()
      /headers["user-agent"] :=  "gethttp.icn [en] (" || &host || ")"
      /headers["host"] := url.get_address()
      /headers["connection"] := "Keep-Alive"

      s := \request_type | if \post_data then "POST" else "GET"

      write_line(s || " " || url.get_file() || " HTTP/" || http_version) | fail

      if /post_data then {
         write_headers() | fail
         write_line() | fail
      } else {
         #
         # Add the post data, convert from table if necessary
         #
         if lang::get_type(post_data) == "table" then {
            #
            # Convert from table in exactly the same way as for a GET parameter string.
            # In this case always use the standard content-type encoding.
            #
            s := URL().make_cgi_string(post_data)
            headers["content-type"] := "application/x-www-form-urlencoded"
         } else {
            #
            # Allow user content-type encoding if specified for this arbitrary data.
            #
            s := post_data
            /headers["content-type"] := "application/x-www-form-urlencoded"
         }
         headers["content-length"] := *s
         write_headers() | fail
         write_line() | fail
         write_str(s) | fail
      }

      return
   end

   #
   # @p
   method read_headers()
      local s, key, val
      repeat {
         s := read_line() | fail
         if *s = 0 then
            break
         s ? {
            #
            # A continuation line starts with a space or a tab.
            #
            if any(' \t') then
               result.get_header(\key) ||:= tab(0)
            else {
               key := tab(upto(':') | 0)
               =": "
               val := tab(0)
               result.get_header(key) := val
            }
         }
      }
      return
   end

   #
   # @p
   method read_data()
      #
      # Set up either a data file or a string buffer.
      #
      if /data_file then
         string_buff := StringBuff()
      else
         data_out := ::open(data_file, "w") | stop("Couldn't open ", data_file)

      if not read_data_impl() then {
         if \data_file then
            ::close(\data_out)
         fail
      }

      #
      # Close the result
      #
      if /data_file then 
         result.set_data(string_buff.get_string())
      else {
         ::close(\data_out)
         result.set_data_file(data_file)
      }

      return
   end

   #
   # @p
   method read_data_impl()
      self.length := integer(result.get_header("content-length")) | &null
      self.read := 0

      #
      # Read the data.
      #
      if map(\result.get_header("transfer-encoding")) == "chunked" then
         return read_chunked()
      else if /length then
         return read_to_eof()
      else
         return read_length()
   end

   #
   # @p
   method read_chunked()
      local l, chunk, s
      repeat {
         l := read_line() | fail
         l ? {
            chunk := integer("16r" || tab(many('0987654321abcdefABCDEF'))) |
               return error("Expected chunk-length specifier; got " || l)
         }
         if chunk = 0 then
            break
         while chunk > 0 do {
            s := read_str(min(1024, chunk)) | fail
            add_some(s)
            chunk -:= *s
         }
         l := read_line() | fail
         if *l > 0 then
            return error("Expected empty line at end of chunk")
      }
      #
      # Read any trailing lines, upto an empty line.
      #
      repeat {
         l := read_line() | fail
         if *l = 0 then
            break
      }

      maybe_close()

      return
   end

   #
   # @p
   method read_to_eof()
      #
      # No content length.  Read until eof, then close.
      #
      while s := read_str(1024) do
         add_some(s)

      #
      # Check for errors that may have caused read_str to fail.
      #
      if &errno ~= 0 then {
         close()
         fail
      }

      close()

      return
   end

   #
   # @p
   method read_length()
      #
      # Got a content length.  Read len bytes and leave the connection
      # open - unless told to close it.
      #
      while self.read < length do {
         s := read_str(min(1024, length - self.read)) | fail
         add_some(s)
      }

      maybe_close()

      return
   end

   #
   # Return the length of the current download, or &null if unknown
   #
   method get_length()
      return self.length
   end

   #
   # Return the number of bytes read so far.
   #
   method get_read()
      return self.read
   end

   #
   # @p
   method add_some(s)
      self.read +:= *s
      fire("Progress")
      if /data_file then
         string_buff.add(s)
      else
         writes(data_out, s)
   end

   method set_one(attr, val)
      local s, u
      case attr of {
         "url": {
            s := string_val(attr, val)
            u := URL(s) | stop("Bad URL:" || s)
            set_url(u)
         }
         "data_file": set_data_file(string_val(attr, val))
         "http_version": set_http_version(string_val(attr, val))
         "request_type": set_request_type(string_val(attr, val))
         "retries": set_retries(int_val(attr, val))
         default: self.NetClient.set_one(attr, val)
      }
   end

   initially(a[])
      self.NetClient.initially()
      headers := table()
      timeout := 12000
      retries := 2
      http_version := "1.1"
      set_fields(a)
end
