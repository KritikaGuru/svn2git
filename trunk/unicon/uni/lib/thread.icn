#
# Jafar Al-Gharaibeh
#
#  June/15/2012
#


package threads


#
# create a communication channel with thread x
#
# Note : chTable is a table of tables of all private comunication
#        channels in the aplication that are waiting for the second
#        end of the channel to respond and pick the call from the table
#

class Shared_Variable(value)
   method lock()
      static builtin_lock
      initial builtin_lock := proc("lock", 0)

      return builtin_lock(self)
   end

   method trylock()
      static builtin_trylock
      initial builtin_lock := proc("trylock", 0)

      return builtin_trylock(self)
   end

   method unlock()
      static builtin_unlock
      initial builtin_lock := proc("unlock", 0)

      return builtin_unlock(self)
   end
   
   initially(x, mtx)

      value := x

      if \mtxx then 
         mutex(self, mtx)
      else
         mutex(self)
end


procedure channel(x)
   local ce, T, L
   static chTable
   initial chTable := mutex(table())
   
   ce := &current
   
   critical chTable:{
       if not(member(chTable, ce)) then chTable[ce] := table() 
       if not(member(chTable, x)) then chTable[x] := table() 
       
       T := chTable[ce]

       if member(T, x) then{
          L := T[x]
	  delete(T, x)
          }
       else
          chTable[x][ce] :=  L := condvar([])
       }
    return L
end


procedure milliseconds()
  local t
  t := gettimeofday()
  return t.sec*1000 + t.usec/1000
end


procedure microseconds()
  local t
  t := gettimeofday()
  return t.sec*1000000 + t.usec
end
