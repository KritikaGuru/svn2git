#
# Jafar Al-Gharaibeh
#
#  June/15/2012
#


package threads


#
# create a communication channel with thread x
#
# Note : chTable is a table of tables of all private comunication
#        channels in the aplication that are waiting for the second
#        end of the channel to respond and pick the call from the table
#

class Shared_Variable(value)
   method lock()
      static builtin_lock
      initial builtin_lock := proc("lock", 0)

      return builtin_lock(self)
   end

   method trylock()
      static builtin_trylock
      initial builtin_trylock := proc("trylock", 0)

      return builtin_trylock(self)
   end

   method unlock()
      static builtin_unlock
      initial builtin_unlock := proc("unlock", 0)

      return builtin_unlock(self)
   end
   
   initially(v, mtx)

      value := v

      if \mtx then 
         mutex(self, mtx)
      else
         mutex(self)
end


procedure channel(x, port)
   local ce, T, L, chnl, TP
   static chTable, chTableP, chTableN
   initial{ 
          chTable  := mutex(table())
          chTableP := mutex(table())
	  chTableN := mutex(table())
      	  }
   
   if string(x) then{ # the name of the channel is what matters
       critical chTableN:
          if member(chTableN, x) then 
             chnl :=  chTableN[x]
          else
	     chTableN[x] := chnl := condvar([])

       return chnl
      }
   else if /port then {   # connect channels based on order they were received
      ce := &current
      critical chTable:{
         if not(member(chTable, ce)) then chTable[ce] := table() 
         if not(member(chTable, x)) then chTable[x] := table() 

	 if \(L := chTable[ce][x]) & chnl := get(L) then{
	    if *L=0 then delete(chTable[ce], x)
	    }
	 else if \(L := chTable[x][ce]) then
	       put(L, chnl := condvar([]))
         else{
	    L := []
            put(L, chnl := condvar([]))
            chTable[x][ce] := L
	    }
         } # critical
      return chnl
      }
   else{
      ce := &current
      critical chTableP:{    # connect channels based on the supplied port
         if not(member(chTableP, ce)) then chTableP[ce] := table() 
         if not(member(chTableP, x)) then chTableP[x] := table() 
	 
	 if \(TP := chTableP[ce][x]) & \(chnl := TP[port]) then{
	    delete(TP, port)
	    if *TP=0 then delete(chTableP[ce], x)
	    }
	 else if \(TP := chTableP[x][ce]) then{
	    TP[port] := chnl := condvar([])
            }
         else{
	    TP := table()
            TP[port] := chnl := condvar([])
            chTableP[x][ce] := TP
	    }
         } # critical
      return chnl
     }
end


procedure milliseconds()
  local t
  t := gettimeofday()
  return t.sec*1000 + t.usec/1000
end


procedure microseconds()
  local t
  t := gettimeofday()
  return t.sec*1000000 + t.usec
end
