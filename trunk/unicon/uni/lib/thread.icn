#
# Jafar Al-Gharaibeh
#
#  June/15/2012
#


package threads


#
# create a communication channel with thread x
#
# Note : chTable is a table of tables of all private comunication
#        channels in the aplication that are waiting for the second
#        end of the channel to respond and pick the call from the table
#

class Shared_Variable(value)
   method lock()
      static builtin_lock
      initial builtin_lock := proc("lock", 0)

      return builtin_lock(self)
   end

   method trylock()
      static builtin_trylock
      initial builtin_trylock := proc("trylock", 0)

      return builtin_trylock(self)
   end

   method unlock()
      static builtin_unlock
      initial builtin_unlock := proc("unlock", 0)

      return builtin_unlock(self)
   end
   
   initially(v, mtx)

      value := v

      if \mtx then 
         mutex(self, mtx)
      else
         mutex(self)
end


procedure channel(x, port)
   local ce, T, L, chnl
   static chTable, chTableP, chTableN
   initial{ 
          chTable  := mutex(table())
          chTableP := mutex(table())
	  chTableN := mutex(table())
      	  }
   
   if string(x) then{ # the name of the channel is what matters
       if member(chTableN, x) then 
          chnl :=  chTableN[x]
       else
	  chTableN[x] := chnl := condvar([])

       return chnl
      }
   else if /port then {   # connect channels based on order they were received
      ce := &current
      critical chTable:{
         if not(member(chTable, ce)) then chTable[ce] := table() 
         if not(member(chTable, x)) then chTable[x] := table() 
       
         T := chTable[ce]
         if member(T, x) then{
	    L := T[x]
            if chnl := get(L) then{
	       if *L=0 then delete(T, L)
	       }
	    else
	       put(L, chnl := condvar([]))
            }
         else{
	    L := []
            put(L, chnl := condvar([]))
            chTable[x][ce] := L
	    }

         } # critical
      return chnl
      }
   else{
      critical chTableP:{    # connect channels based on the supplied port
         ce := &current

         if not(member(chTableP, ce)) then chTableP[ce] := table() 
         if not(member(chTableP, x)) then chTableP[x] := table() 
       
         T := chTableP[ce]
         if member(T, x) then{
	    TP := T[x]
            if member(TP, port) then{
               chnl := TP[port]
	       delete(TP, port)
	       if *TP=0 then delete(T, TP)
	       }
	    else
	       TP[port] := chnl := condvar([])		
            }
         else{
	    TP := table()
            TP[port] := chnl := condvar([])
            chTableP[x][ce] := TP
	    }

         } # critical
      return chnl
     }
end


procedure milliseconds()
  local t
  t := gettimeofday()
  return t.sec*1000 + t.usec/1000
end


procedure microseconds()
  local t
  t := gettimeofday()
  return t.sec*1000000 + t.usec
end
