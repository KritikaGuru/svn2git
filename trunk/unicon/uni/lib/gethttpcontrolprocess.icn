#
# $Id: gethttpcontrolprocess.icn,v 1.1 2003-07-07 19:50:46 jeffery Exp $
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package http

import util
import lang
import ipc

$include "gethttpincl.icn"

#
# The process used by GetHttpControlProcess to attempt a raw http get.
# It should not be used directly.
#
class GetHttpProcess : Process(parent, mq)
   #
   # Set the parent {GetHttpControlProcess} class.
   #
   method set_parent(p)
      return self.parent := p
   end

   method set_mq(mq)
      self.mq := mq
   end

   method run()
      local f, s

      if not(f := parent.url.open()) then {
         mq.send(NO_CONNECT)
         return
      }

      /parent.headers["user-agent"] :=  "gethttp.iol [en] (" || &host || ")"
      /parent.headers["host"] := parent.url.get_address()

      s := \parent.request_type | if \parent.post_data then "POST" else "GET"

      write(f, s, " ", parent.url.get_file(), " HTTP/1.0")

      if /parent.post_data then {
         parent.write_headers(f)
         write(f)
      } else {
         #
         # Add the post data, convert from table if necessary
         #
         if lang::get_type(parent.post_data) == "table" then {
            #
            # Convert from table in exactly the same way as for a GET parameter string.
            # In this case always use the standard content-type encoding.
            #
            s := URL().make_cgi_string(parent.post_data)
            parent.headers["content-type"] := "application/x-www-form-urlencoded"
         } else {
            #
            # Allow user content-type encoding if specified for this arbitrary data.
            #
            s := parent.post_data
            /parent.headers["content-type"] := "application/x-www-form-urlencoded"
         }
         parent.headers["content-length"] := *s
         parent.write_headers(f)
         write(f)
         writes(f, s)
      }

      flush(f)

      while s := reads(f, 1024) do
         mq.send(s)

      close(f)

      mq.send(DONE)
   end
end

#
# This class creates instances of {GetHttpProcess} as appropriate to
# retrieve the given URL.  It handles timeouts and retries.
#
class GetHttpControlProcess : Process(
                                      mq,
                                      url,
                                      post_data,
                                      headers,
                                      request_type,
                                      timeout,
                                      retries
                                      )

   #
   # Set the desired url
   #
   method set_url(url)
      return self.url := url
   end

   method set_mq(mq)
      self.mq := mq
   end

   #
   # Set the data to be used in a POST request.
   #
   # @param   post_data    The data to use this may either be a string, in
   # @        which case it represents raw data, or it may be
   # @        be a table in which case it represents a table of
   # @        cgi parameters, which will be converted appropriately.
   #
   method set_post_data(post_data)
      return self.post_data := post_data
   end

   #
   # Set the request type.  The default is {GET}, unless post data is set, in which
   # case the default is {POST}.
   #
   method set_request_type(request_type)
      return self.request_type := request_type
   end

   #
   # Set a header variable to the desired value.
   #
   method set_header(key, value)
      return headers[map(key)] := value
   end

   #
   # Write the headers to file f
   #
   method write_headers(f)
      every e := !sort(headers) do {
         e[1][1] := map(e[1][1], &lcase, &ucase)
         write(f, e[1], ": ", e[2])
      }
   end

   #
   # Set the timeout to use.  The default is 12s.  If a figure of zero is given,
   # then no timeout will be used.
   #
   method set_timeout(timeout)
      return self.timeout := timeout
   end

   #
   # Set the number of retries to use.  The default is two.
   #
   method set_retries(retries)
      return self.retries := retries
   end

   method run()
      local i, res
      i := retries
      repeat {
         mq.send(STARTED)
         if res := tryone() then {
            mq.send(res)
            return
         }
         if (i -:= 1) < 0 then
            break

         mq.send(RETRYING)
      }
      mq.send(FAILED)
   end

   #
   # Try once to retrieve the page.
   # 
   # @p
   method tryone()
      local string_buff, smq

      string_buff := StringBuff()
      smq := ipc::create_private_msg()
      p := GetHttpProcess()
      p.set_mq(smq)
      p.set_parent(self)
      p.start()
      repeat {
         if not(r := smq.poll(timeout)) then {
            mq.send(TIMEOUT)
            p.stop()
            smq.remove()
            fail
         }

         if r === NO_CONNECT then {
            mq.send(r)
            p.join()
            smq.remove()
            fail
         }
         if r === DONE then {
            mq.send(r)
            p.join()
            smq.remove()
            break
         }
         mq.send(WAITING)
         #write("received ",image(r))
         string_buff.add(r)
      }

      #
      # Construct the result from the data
      #
      res := HttpPage()
      res.set_url(url)
      res.parse(string_buff.get_string())

      return res
   end

   initially
      headers := table()
      timeout := 12000
      retries := 2
end

#
# Decode one of the integer communication codes returned into
# a string.
#
procedure decode_code(n)
   return case n of {
      NO_CONNECT : "Couldn't connect"   
      DONE : "Done"         
      TIMEOUT : "Timeout"      
      WAITING : "Waiting"      
      STARTED : "Started"      
      FAILED : "Failed"    
      RETRYING : "Retrying"
   }
end

