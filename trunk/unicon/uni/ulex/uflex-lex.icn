#
#  uflex-lex.icn - handwritten lex-compatible lexical analyzer for lex.
#  derived from lex.l, Author: Katie Ray, Last Updated: September 17, 2002
#

$include "flexgram_tab.icn"

global yyin, yylval, yylineno, yyfilename, outfilename, outfile, whiteflag
record yylval_rec(s)

procedure yylex()
local nextchar, foutfile

write("yylex called")

   yytext := ""
   yylval := yylval_rec()

repeat {
   
   if ="}%" then { printf("%s", "}% should read %}") }
   else if ="%%" then {
	#
	# copy out remainder, up to EOF, into output file.
	#
	if not (foutfile := open("ulex.tmp","w")) then {
	   stop("can't open ulex.tmp for writing")
	   }
	whiteflag := 1

	if /foutfile then {
	   fprintf(&errout, "couldn't write to ulex.tmp; exiting\n")
	   exit(1)
	   }
	fprintf(foutfile, "\n\n")
	fprintf(foutfile, "$line %d \"%s\"\n", yylineno, yyfilename)

	while nextchar := move(1) do {
	   fprintf(foutfile,"%c",nextchar)
	   }
	close(foutfile)
	return 0
	}

   else if yytext ||:= (="[" || (="^"|"")) then {
      while not (yytext ||:= ="]") do {
         # any thing but ] or \ is a regular cset member
         if yytext ||:= tab(any(&cset -- ']\\')) then { }
         # generalize to handle all escapes legal in flex:
         else if yytext ||:= (="\\" || tab(any('tn]\\'))) then { }
         else {
            fprintf(&errout,
		    "%s:%d: broken cset regex '%s', next  chars '%s'\n",
		    yyfilename, yylineno, yytext, move(8)|tab(0))
            return 0
            }
         }

      yylval.s := yytext
      return token(CSET)
      }
   else if yytext := ="." then { return token(DOT) }
   else if yytext := ="\"" then {
      while not (yytext ||:= ="\"") do {
         # any thing but " or \ is a regular string character
         if yytext ||:= tab(any(&cset -- '"\\')) then { }
         # generalize to handle all escapes legal in flex:
         else if yytext ||:= (="\\" || tab(any('tn'))) then { }
         else {
            fprintf(&errout, "%s:%d: lexical error, broken string %s\n",
		    yyfilename, yylineno, yytext)
            return 0
            }
         }

      yylval.s := yytext
      return token(QUOTES)
      }
   else if yytext := (="\\" || tab(any(&cset--'\n'))) then {
      yylval.s := yytext
      return token(BACKSLASH)
      }
   else if yytext := ="^" then { return token(LINEBEGIN) }
   else if yytext := ="$" then { return token(LINEEND) }
   else if yytext := ="?" then { return token(OPTIONAL) }
   else if yytext := ="*" then { return token(ZEROORMORE) }
   else if yytext := ="+" then { return token(ONEORMORE) }
   else if yytext := ="|" then { return token(OR) }
   else if yytext := ="(" then { return token(PARENTHESES) }
   else if yytext := =")" then { return token(CLOSEPARENTHESES) }
   else if yytext := ="/"  then { return token(FORWARDSLASH) }

   else if yytext := ((="{" ||
		      tab(many(&digits)) ||
		      ="," ||
		      tab(many(&digits)) || ="}") |
			(="{" || tab(any(&digits)) || ="}")) then {
      yylval.s = yytext
      return token(CURLBRACKETS)
      }
   else if yytext := ="{" then {
      grab_semantic_action()
      yylval.s := yytext
      return token(ACTION)
      }
   else if yytext := tab(any('\'a-zA-Z0-9_')) then {
      yylval.s = yytext
      return token(CHARACTER)
      }

   else if yytext := ="\n" then {
yylineno +:= 1
      while tab(many(' \t')) || ="\n" do {
yylineno +:= 1
         # { if whiteflag ~= 0 then return 1 }
	 }
      return token(NEWLINE)
      }
   # comment eats to end of line
   else if ="# " || (many(&cset -- '\n') | "") || ="\n" then { yylineno +:= 1 }
   else if tab(many(' \t')) then { }
   else if yytext := move(1) then {
      if whiteflag ~= 0 then return 1
      else fprintf(&errout, "%s:%d: lexical error on token '%s'\n",
		    yyfilename, yylineno, yytext)
      }
   }

end


procedure token(x)
#ifdef DEBUG
   printf("\ttoken: %d '%s'\n", (integer(x)|-1), image(yytext))
#endif
   return x
end

procedure grab_semantic_action()
    local numbrace := 1, quotemode := 0, slash := 0
    local nextchar
    local temp

    while numbrace ~= 0 do {
        if not (nextchar := move(1)) then {
	   fprintf(&errout,"bad/unfinished semantic action\n");
	   exit(-1);
	   }

        if nextchar == "\"" & slash = 0 then {
           quotemode := 1 - quotemode
	   }

        if nextchar == "\\" then {
	   slash := 1 - slash
	   }
	else slash := 0
        if quotemode == 0 then {
            if nextchar == "{" then {
	       numbrace +:= 1
	       }
            else if nextchar == "}" then {
	       numbrace -:= 1
	       }
        }

        # append nextchar onto end of yytext
        yytext ||:= nextchar
    }
end

procedure yywrap()
   return -1
end

procedure yyinput()
   return move(1)
end
