#
#  uflex-lex.icn - handwritten lex-compatible lexical analyzer for lex.
#  derived from lex.l, Author: Katie Ray, Last Updated: September 17, 2002
#

global yylval
global yylineno
global yyfilename, outfilename, outfile
global whiteflag

procedure yylex()
local nextchar, foutfile

   if ="}%" then { printf("%s", "}% should read %}") }
   else if ="%%" then {
	#
	# copy out remainder, up to EOF, into output file.
	#
	foutfile := open("ulex.tmp","w")
	whiteflag := 1

	if /foutfile then {
	   fprintf(&errout, "couldn't write to ulex.tmp; exiting\n")
	   exit(1)
	   }
	fprintf(foutfile, "\n\n")
	fprintf(foutfile, "$line %d \"%s\"\n", yylineno, yyfilename)

	while ((nextchar := yyinput()) > 0) do {
	   fprintf(foutfile,"%c",nextchar)
	   }

	fclose(foutfile)
	return 0;
	}

   else if yytext := (="[" || (="^"|"")) then {
      while not (yytext ||:= ="]") do {
         # any thing but ] or \ is a regular cset member
         if yytext ||:= tab(any(&cset -- ']\\')) then { }
         # generalize to handle all escapes legal in flex:
         else if yytext ||:= (="\\" || tab(any('tn'))) then { }
         else {
            fprintf(&errout, "%s:%d: lexical error, broken cset regex '%s'\n",
		    yyfilename, yylineno, yytext)
            return 0
            }
         }

      yylval.s := yytext
      return token(CSET)
      }
   else if ="." then { return token(DOT) }
   else if yytext := ="\"" then {
      while not (yytext ||:= ="\"") do {
         # any thing but " or \ is a regular string character
         if yytext ||:= tab(any(&cset -- '"\\')) then { }
         # generalize to handle all escapes legal in flex:
         else if yytext ||:= (="\\" || tab(any('tn'))) then { }
         else {
            fprintf(&errout, "%s:%d: lexical error, broken string %s\n",
		    yyfilename, yylineno, yytext)
            return 0
            }
         }

      yylval.s := yytext
      return token(QUOTES)
      }
   else if yytext := (="\\" || move(any(&cset--'\n'))) then {
      yylval.s := yytext
      return token(BACKSLASH)
      }
   else if ="^" then { return token(LINEBEGIN) }
   else if ="$" then { return token(LINEEND) }
   else if ="?" then { return token(OPTIONAL) }
   else if ="*" then { return token(ZEROORMORE) }
   else if ="+" then { return token(ONEORMORE) }
   else if ="|" then { return token(OR) }
   else if ="(" then { return token(PARENTHESES) }
   else if =")" then { return token(CLOSEPARENTHESES) }
   else if "/"  then { return token(FORWARDSLASH) }

   else if yytext := ((="{" ||
		      tab(many(&digits)) ||
		      ="," ||
		      tab(many(&digits)) || ="}") |
			(="{" || tab(any(&digits)) || ="}")) then {
      yylval.s = yytext
      return token(CURLBRACKETS)
      }
   else if ="{"	then {
      grab_semantic_action()
      yylval.s := yytext
      return token(ACTION)
      }
   else if tab(any('\'a-zA-Z0-9_')) then {
      yylval.s = yytext
      return token(CHARACTER)
      }

   else if ="\n" then {
      while tab(many(' \t')) || ="\n" do {
         # { if whiteflag ~= 0 then return 1 }
	 }
      return token(NEWLINE)
      }
   # comment eats to end of line
   else if ="# " || (many(&cset -- '\n') | "") || ="\n" then { }
   else if move(1) then {
      if whiteflag ~= 0 then return 1
      else fprintf(&errout, "%s:%d: lexical error on token '%s'\n",
		    yyfilename, yylineno, yytext)
      }
end


procedure token(x)
#ifdef DEBUG
   printf("\ttoken: %d '%s'\n", x, yytext)
#endif
   return x
end

procedure grab_semantic_action()
    local numbrace := 1, quotemode := 0, slash := 0
    local nextchar
    local temp

    while numbrace ~= 0 do {
        if not (nextchar := yyinput()) then {
	   fprintf(&errout,"bad/unfinished semantic action\n");
	   exit(-1);
	   }

        if nextchar == "\"" & slash = 0 then {
           quotemode := 1 - quotemode
	   }

        if nextchar == "\\" then {
	   slash := 1 - slash
	   }
	else slash := 0
        if quotemode == 0 then {
            if nextchar == "{" then {
	       numbrace +:= 1
	       }
            else if nextchar == "}" then {
	       numbrace -:= 1
	       }
        }

        # append nextchar onto end of yytext
        yytext ||:= nextchar
    }
end

procedure yywrap()
   return -1
end

procedure yyinput()
   return input()
end
