### This file created by IYACC 1.0
### Please send bug reports to raypereda@hotmail.com
#define YYPREFIX "yy"
#line 8 "flexgram.y"
# C version includes tree and automata
global rulenumber
#line 7 "flexgram.icn"
$define OR 257
$define BACKSLASH 258
$define SQUAREBRACKETS 259
$define DOT 260
$define CSET 261
$define QUOTES 262
$define LINEBEGIN 263
$define LINEEND 264
$define OPTIONAL 265
$define ZEROORMORE 266
$define ONEORMORE 267
$define PARENTHESES 268
$define FORWARDSLASH 269
$define CURLBRACKETS 270
$define OCCURRENCES 271
$define CLOSEPARENTHESES 272
$define PERCENTS 273
$define CHARACTER 274
$define COMMENT 275
$define ACTION 276
$define BEGINNING 277
$define ENDING 278
$define QUESTION 279
$define STAR 280
$define PLUS 281
$define OREXPR 282
$define PARENTHETIC 283
$define FORSLASH 284
$define EXPRESSION 285
$define EXPRTREE 286
$define NEWLINE 287
$define CONCATEXPR 288
$define CONCAT 289
$define YYERRCODE 256
procedure init() 
  yylhs := [                                        -1,
    0,    1,    1,    1,    1,    3,    4,    4,    2,    2,
    5,    5,    6,    6,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    7,    7,    7,    7,    7,    7,    8,
    9,   10,   11,   12,   13,   14,   15,
  ]
  yylen := [                            2,
    1,    3,    2,    2,    1,    1,    2,    1,    2,    1,
    3,    1,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    3,    2,    1,    1,    1,    2,
    2,    2,    2,    2,    3,    3,    2,
  ]
  yydefred := [                         0,
   16,   19,   17,   15,    0,    0,   18,    0,    0,    1,
    0,    0,    6,    0,   12,    0,   20,   21,   22,   23,
   24,   27,   28,   29,    0,    0,    9,    0,    4,    0,
    0,   31,   32,   33,   34,    0,   37,   13,    0,   35,
    2,   11,    0,    0,
  ]
  yydgoto := [                          9,
   10,   11,   12,   13,   14,   15,   39,   17,   18,   19,
   20,   21,   22,   23,   24,
  ]
  yysindex := [                      -241,
    0,    0,    0,    0, -157, -157,    0, -287,    0,    0,
 -157, -287,    0, -287,    0, -210,    0,    0,    0,    0,
    0,    0,    0,    0, -172, -190,    0, -287,    0, -157,
 -157,    0,    0,    0,    0, -157,    0,    0, -172,    0,
    0,    0, -172, -172,
  ]
  yyrindex := [                         0,
    0,    0,    0,    0,    0,    0,    0,   36,    0,    0,
    0,    8,    0,    9,    0,    5,    0,    0,    0,    0,
    0,    0,    0,    0,    1,    0,    0,   10,    0,    6,
    0,    0,    0,    0,    0,    0,    0,    0,    2,    0,
    0,    0,    3,    4,
  ]
  yygindex := [                         0,
    0,   16,   12,    0,    0,  -19,    7,    0,    0,    0,
    0,    0,    0,    0,    0,
  ]
$define YYTABLESIZE 310
  yytable := [                          8,
   30,   26,   25,   36,   14,    7,   16,    5,    8,    3,
   42,   25,   26,    0,    0,    0,    1,   16,    2,    3,
    4,    5,   28,   27,    0,    0,    6,   29,    0,   30,
    0,    0,    7,    0,    0,   10,   16,   43,    0,    0,
    0,    0,   44,   41,    0,    8,   31,    1,    0,    2,
    3,    4,    5,   32,   33,   34,   35,    6,   36,   37,
    0,    0,    0,    7,    0,   38,   31,    1,    0,    2,
    3,    4,    5,   32,   33,   34,   35,    6,   36,   37,
    0,   40,    0,    7,   31,    1,    0,    2,    3,    4,
    5,   32,   33,   34,   35,    6,   36,   37,    0,    0,
    1,    7,    2,    3,    4,    5,    0,    0,    0,    0,
    6,    0,    0,    0,    0,    0,    7,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   30,   26,   25,   36,   30,   26,   25,   36,
    0,    0,    0,    0,    0,    0,    0,   30,   26,   25,
   36,   14,    7,   10,    0,   10,   10,   10,   10,    0,
    0,    0,    0,   10,    0,    0,    0,    0,    0,   10,
  ]
  yycheck := [                        287,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   30,    5,    6,   -1,   -1,   -1,  258,   11,  260,  261,
  262,  263,   11,    8,   -1,   -1,  268,   12,   -1,   14,
   -1,   -1,  274,   -1,   -1,    0,   30,   31,   -1,   -1,
   -1,   -1,   36,   28,   -1,  287,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,   -1,   -1,  274,   -1,  276,  257,  258,   -1,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,  272,   -1,  274,  257,  258,   -1,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,  270,   -1,   -1,
  258,  274,  260,  261,  262,  263,   -1,   -1,   -1,   -1,
  268,   -1,   -1,   -1,   -1,   -1,  274,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  272,  272,  272,  272,  276,  276,  276,  276,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  287,  287,  287,
  287,  287,  287,  258,   -1,  260,  261,  262,  263,   -1,
   -1,   -1,   -1,  268,   -1,   -1,   -1,   -1,   -1,  274,
  ]
$define YYFINAL 9
$define YYMAXTOKEN 289
  yyname := [
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"OR","BACKSLASH","SQUAREBRACKETS",
"DOT","CSET","QUOTES","LINEBEGIN","LINEEND","OPTIONAL","ZEROORMORE","ONEORMORE",
"PARENTHESES","FORWARDSLASH","CURLBRACKETS","OCCURRENCES","CLOSEPARENTHESES",
"PERCENTS","CHARACTER","COMMENT","ACTION","BEGINNING","ENDING","QUESTION",
"STAR","PLUS","OREXPR","PARENTHETIC","FORSLASH","EXPRESSION","EXPRTREE",
"NEWLINE","CONCATEXPR","CONCAT",
  ]
  yyrule := [
"$accept : Goal",
"Goal : Start",
"Start : Newlines Percentexp Newlines",
"Start : Newlines Percentexp",
"Start : Percentexp Newlines",
"Start : Percentexp",
"Percentexp : Regexps",
"Regexps : Exprs Newlines",
"Regexps : Exprs",
"Newlines : NEWLINE Newlines",
"Newlines : NEWLINE",
"Exprs : Exprs Newlines OneExpr",
"Exprs : OneExpr",
"OneExpr : Expr ACTION",
"OneExpr : Expr",
"Expr : QUOTES",
"Expr : BACKSLASH",
"Expr : CSET",
"Expr : CHARACTER",
"Expr : DOT",
"Expr : BeginLine",
"Expr : EndLine",
"Expr : Question",
"Expr : Star",
"Expr : Plus",
"Expr : Expr OR Expr",
"Expr : Expr Expr",
"Expr : Parenthetic",
"Expr : ForSlash",
"Expr : Occurrence",
"BeginLine : LINEBEGIN Expr",
"EndLine : Expr LINEEND",
"Question : Expr OPTIONAL",
"Star : Expr ZEROORMORE",
"Plus : Expr ONEORMORE",
"Parenthetic : PARENTHESES Expr CLOSEPARENTHESES",
"ForSlash : Expr FORWARDSLASH Expr",
"Occurrence : Expr CURLBRACKETS",
  ]

end

#####################################################################
#####################################################################
invocable all    # need to look up semantic actions by name

global yytext    # user variable to return contextual strings
global yyval     # used to return semantic vals from action routines
global yylval    # the 'lval' (result) I got from yylex()
global yydebug   # (boolean) do I want debug output?
global yynerrs   # (integer) number of errors so far
global yyerrflag # (integer) was there an error?
global yychar    # (integer) the current working character
global action    # maps an integer to a semantic action procedure

global yylhs
global yylen
global yydefred
global yydgoto
global yysindex
global yyrindex
global yygindex
global yytable
global yycheck
global yyname
global yyrule

global statestk         # state stack
global valstk           # value stack
################################################################
# procedure: init_stacks : allocate and prepare stacks
################################################################
procedure init_stacks()
  local i
  statestk := []
  valstk := []
  yyval  := 0 
  yylval := 0 
  action := list(1000, action_null)  # remove hard coded 1000 later
  every i := 1 to 1000 do action[i] := proc("action_" || i)
end

#line 123 "flexgram.y"

# extern int yylineno

procedure yyerror(s)
   #
   # Eventually want to use merr for better error messaging.
   #

   fprintf(stderr, "%s on line %d\n", s, yylineno)
   return 0
end

#
# convert() takes the tree as input and converts it into an automata.
#
procedure convert(tr)
   local returnvalue, aut1, aut2
   local newnode1, newnode2
   local listptr, listptr2
   local elistptr
   local tempstring, getsinglechar
   local t1, t2, i

   #
   # Conversion is accomplished by breaking it down into separate cases and
   # exploiting recursion wherever possible.
   #

   case tr.label of {
   EXPRTREE: {
	#
	# This case is handled by converting the two subtrees and then making
	# a new start node with epsilon transitions to the start nodes of the
	# two machines for each branch.
	#

	returnvalue := alcautomata()
	returnvalue.start := alcanode(0)

	aut1 := convert(tr.children[0])
	aut2 := convert(tr.children[1])

	returnvalue.start.epsilon := alcnodelist()
	returnvalue.start.epsilon.current := aut1.start
	returnvalue.start.epsilon._next := alcnodelist()
	returnvalue.start.epsilon._next.current := aut2.start

	returnvalue.states := alcnodelist()
	returnvalue.states.current := returnvalue.start

	returnvalue.states._next := aut1.states
	listptr := aut1.states

	while \ (listptr._next) do
	  listptr := listptr._next

	listptr._next := aut2.states
	
	returnvalue.accepting := aut1.accepting
	listptr := aut1.accepting

	while \ (listptr._next) do
	  listptr := listptr._next
	
	listptr._next := aut2.accepting

	return returnvalue
      }

    EXPRESSION: {
	#
	# This case is handled by converting the expression recursively and 
	# associating the accepting states with the semantic action if there
	# is one. This case is also the one that is used to set which rule
	# number is associated with which states. This is accomplished by 
	# using a global variable that is incremented each time that we 
	# convert an expression.
	#

	returnvalue := convert(tr.children[0])

	if \ (tr.children[1]) then {
	    listptr := returnvalue.accepting
	    while \listptr do {
		listptr.current.semaction := tr.children[1].text
		listptr := listptr._next
	      }
	  }
	
	listptr := returnvalue.states
	
	while \listptr do {
	    listptr.current.rulenum := rulenumber
	    listptr := listptr._next
	  }
	
	rulenumber+:= 1
	
	return returnvalue
      }

    OREXPR: {
	#
	# This case is handled by converting the two expressions that are 
	# connected by the or and making a new start state with an epsilon
	# transition to the start state of each of the other two machines.
	#

	returnvalue := alcautomata()
	returnvalue.start := alcanode(0)
	
	aut1 := convert(tr.children[0])
	aut2 := convert(tr.children[2])

	returnvalue.start.epsilon := alcnodelist()
        returnvalue.start.epsilon.current := aut1.start
        returnvalue.start.epsilon._next := alcnodelist()
        returnvalue.start.epsilon._next.current := aut2.start

	returnvalue.states := alcnodelist()
	returnvalue.states.current := returnvalue.start

        returnvalue.states._next := aut1.states
        listptr := aut1.states

        while \ (listptr._next) do
          listptr := listptr._next

        listptr._next := aut2.states

        returnvalue.accepting := aut1.accepting
        listptr := aut1.accepting

        while \ (listptr._next) do
          listptr := listptr._next

        listptr._next := aut2.accepting

        return returnvalue
      }

    CONCATEXPR: {
	#
	# This case is handled by converting the two subexpressions and 
	# linking the accepting states of the first to the start state of the
	# second. The accepting states are those of the second machine.
	#

	aut1 := convert(tr.children[0])
	aut2 := convert(tr.children[2])

	listptr := aut1.accepting
	
	while \listptr do {
	    if /(listptr.current.epsilon) then {
		listptr.current.epsilon := alcnodelist()
		listptr.current.epsilon.current := aut2.start
	      }

	    else {
		listptr2 := listptr.current.epsilon

		while \ (listptr2._next) do
		  listptr2 := listptr2._next
		
		listptr2._next := alcnodelist()
		listptr2._next.current := aut2.start
	      }

	    listptr := listptr._next
	  }

	listptr := aut1.states

	while \ (listptr._next) do
	  listptr := listptr._next

	listptr._next := aut2.states

	aut1.accepting := aut2.accepting
	return aut1
      }

    QUOTES: {
	#
	# This case is handled by creating a chain of states with transitions
	# that correspond to each individual letter of the string in quotes.
	#

	returnvalue := alcautomata()

	newnode1 := alcanode(0)
	listptr := alcnodelist()
	listptr.current := newnode1

        returnvalue.start := newnode1
        returnvalue.states := listptr

	tempstring := tr.text[2:0]  # skip past initial doublequote

	while tempstring[1] ~== "\"" do {
	    getsinglechar := tempstring[1]
	    newnode2 := alcanode(0)
	    listptr._next := alcnodelist()
	    listptr._next.current := newnode2

	    newnode1.edges := alcedgelist()
	    newnode1.edges.current := alcedge(getsinglechar)
	    newnode1.edges.current.destinations := alcnodelist()
	    newnode1.edges.current.destinations.current := newnode2

	    newnode1 := newnode2
	    listptr := listptr._next
	    tempstring := tempstring[2:0]
	  }

	returnvalue.accepting := alcnodelist()
	returnvalue.accepting.current := newnode2
	return returnvalue
      }

    BACKSLASH: {
	#
	# This case is handled by creating a two state automata with the edge
	# labelled directly with the character that follows the backslash.
	#

	returnvalue := alcautomata()

	newnode1 := alcanode(0)
        newnode2 := alcanode(0)
	
	listptr := alcnodelist()
	listptr.current := newnode1
	listptr._next := alcnodelist()
	listptr._next.current := newnode2

	elistptr := alcedgelist()
	tr.text := tr.text[2:0] # skip over \

	if tr.text == 'n' then tr.text := "\n"
     
	else if tr.text == 't' then tr.text := "\t"

	elistptr.current := alcedge(tr.text)
	
	listptr2 := alcnodelist()
	listptr2.current := newnode2

	elistptr.current.destinations := listptr2

	newnode1.edges := elistptr

	returnvalue.start := newnode1
	returnvalue.states := listptr
	returnvalue.accepting := alcnodelist()
	returnvalue.accepting.current := newnode2
      }

    CSET: {
	#
	# This case is handled by creating an automata with a start state and
	# transitioning to a final state and the edge is labelled with the 
	# entire string representing the cset. This becomes a special case in
	# handling the simulation of the automata.
	#

	returnvalue := alcautomata()
	returnvalue.start := alcanode(0)
	returnvalue.states := alcnodelist()
	returnvalue.accepting := alcnodelist()

	returnvalue.accepting.current := alcanode(0)

	returnvalue.states.current := returnvalue.start
	returnvalue.states._next := alcnodelist()
	returnvalue.states._next.current := returnvalue.accepting.current

	returnvalue.start.edges := alcedgelist()
	returnvalue.start.edges.current := alcedge(tr.text)
	returnvalue.start.edges.current.destinations := alcnodelist()
	returnvalue.start.edges.current.destinations.current :=
	  returnvalue.accepting.current

	return returnvalue
      }

    CHARACTER: {
	#
	# The most striaghtforward case - create a two state automata that
	# transitions from the start to the final state on the specified 
	# character.
	#

	returnvalue := alcautomata()

	newnode1 := alcanode(0)
	newnode2 := alcanode(0)
	elistptr := newnode1.edges

	newnode1.edges := alcedgelist()
	newnode1.edges.current := alcedge(tr.text)
	newnode1.edges.current.destinations := alcnodelist()
	newnode1.edges.current.destinations.current := newnode2

	returnvalue.start := newnode1

	returnvalue.states := alcnodelist()
	returnvalue.states.current := newnode1
	returnvalue.states._next := alcnodelist()
	returnvalue.states._next.current := newnode2

	returnvalue.accepting := alcnodelist()
	returnvalue.accepting.current := newnode2

	return returnvalue
      }

    DOT: {
	#
	# This case uses a special feature of our automata that creates a 
	# transition that simply means consume any character. Each node has
	# an associated list of nodes called dot that it can reach on any 
	# single character.
	#

	returnvalue := alcautomata()
	returnvalue.start := alcanode(0)

	newnode1 := alcanode(0)
	listptr := alcnodelist()

	listptr.current := newnode1
	returnvalue.start.dot := listptr

	listptr := alcnodelist()
	listptr.current := returnvalue.start
	listptr._next := alcnodelist()
	listptr._next.current := newnode1
	returnvalue.states := listptr

	returnvalue.accepting := alcnodelist()
	returnvalue.accepting.current := newnode1

	return returnvalue
      }

    BEGINNING: {
	#
	# This is accomplished by converting the tree obtained from the 
	# regular expression into an automata, and then adding a transition
	# from all final states to themselves on any input.
	#

	aut1 := convert(tr.children[1])

	listptr := aut1.accepting

	while \listptr do {
	    listptr2 := listptr.current.dot

	    if /listptr2 then {
		listptr2 := alcnodelist()
		listptr2.current := listptr.current
		listptr.current.dot := listptr2
	      }

	    else {
		while \ (listptr2._next) do
		  listptr2 := listptr2._next
		
		listptr2._next := alcnodelist()
		listptr2._next.current := listptr.current
	      }

	    listptr := listptr._next
	  }

	return aut1
      }

    ENDING: {
	#
	# This case is handled by converting the regular expression and then
	# adding a new start state that transitions to itself on any input
	# and has an epsilon transition to the start state of the converted
	# machine.
	#

	aut1 := convert(tr.children[0])

	newnode1 := alcanode(0)

	newnode1.dot := alcnodelist()
	newnode1.dot.current := newnode1

	newnode1.epsilon := alcnodelist()
	newnode1.epsilon.current := aut1.start

	listptr := aut1.states
	aut1.states := alcnodelist()
	aut1.states.current := newnode1
	aut1.states._next := listptr

	aut1.start := newnode1
	return aut1
      }

    QUESTION: {
	#
	# This adds the start state to the list of accepting states for the
	# machine that is a conversion of the regular expression.
	#

	aut1 := convert(tr.children[0])

	listptr := aut1.accepting
	if /listptr then
	  return aut1

	while \ (listptr._next) do
	  listptr := listptr._next
	
	listptr._next := alcnodelist()
	listptr._next.current := aut1.start

	return aut1
      }

    STAR: {
	#
	# This case converts the regular expression and then adds an epsilon
	# transition from the final states to the start state and makes the
	# start state a final state.
	#

        aut1 := convert(tr.children[0])

        listptr := aut1.accepting

        while \ listptr do {
	    listptr2 := listptr.current.epsilon

	    if /listptr2 then {
		listptr2 := alcnodelist()
		listptr2.current := aut1.start
		listptr.current.epsilon := listptr2
	      }

	    else {
		while \ (listptr2._next) do
		  listptr2 := listptr2._next

		listptr2._next := alcnodelist()
		listptr2._next.current := aut1.start
	      }

	    listptr := listptr._next
	  }

	listptr := aut1.accepting
	aut1.accepting := alcnodelist()
        aut1.accepting.current := aut1.start
	aut1.accepting._next := listptr

        return aut1
      }

    PLUS: {
	#
	# Works similar to the case for star except that it doesn't make the
	# start state a final state.
	#

        aut1 := convert(tr.children[0])

        listptr := aut1.accepting
        if /listptr then
          return aut1

        while \listptr do {
            if / (listptr.current.epsilon) then {
                listptr.current.epsilon := alcnodelist()
                listptr.current.epsilon.current := aut1.start
              }

            else {
                listptr2 := listptr.current.epsilon

                while \ (listptr2._next) do
                  listptr2 := listptr2._next

		listptr2._next := alcnodelist()
                listptr2._next.current := aut1.start
              }

            listptr := listptr._next
          }

        return aut1
      }

    PARENTHETIC:
      return convert(tr.children[1])

    FORSLASH |

    OCCURRENCES: {
	tempstring := tr.text
	tempstring +:= 1
	t1 := *tempstring - 48                # convert from char to int
	tempstring +:= 2

	#
	# First we convert the regular expression that we are generating 
	# multiple occurrences for.
	#

	returnvalue := convert(tr.children[0])

	every i := 1 to t1-1 do {
	    #
	    # This loop will continue until the first number in the number
	    # of occurrences or theonly number as the case may be. It will 
	    # reconvert the regular expression to create a copy of the 
	    # automata and then it will link the previous final states to the
	    # start state of this machine turning off the previous final 
	    # states.
	    #

	    aut1 := convert(tr.children[0])
	    
	    listptr := returnvalue.accepting
	    while \listptr do {
		if / (listptr.current.epsilon) then {
		    listptr.current.epsilon := alcnodelist()
		    listptr.current.epsilon.current := aut1.start
		  }

		else {
		    listptr2 := listptr.current.epsilon

		    while \ (listptr2._next) do
		      listptr2 := listptr2._next

		    listptr2._next := alcnodelist()
		    listptr2._next.current := aut1.start
		  }

		listptr := listptr._next
	      }

	    returnvalue.accepting := aut1.accepting 

	    listptr := returnvalue.states
	    while \ (listptr._next) do
	      listptr := listptr._next

	    listptr._next := aut1.states
	  }

	if \tempstring then {
	    #
	    # If there were two numbers in the set of occurrences then we do 
	    # basically the same as the above up to the second number except
	    # that we do not turn off the final states of the previous machine
	    # during each iteration.
	    #

	    t2 := *tempstring - 48
	    every i := t1 to t2-1 do {
		aut1 := convert(tr.children[0])
		listptr := returnvalue.accepting

		while \listptr do {
		    if / (listptr.current.epsilon) then {
			listptr.current.epsilon := alcnodelist()
			listptr.current.epsilon.current := aut1.start
		      }

		    else {
			listptr2 := listptr.current.epsilon

			while \ (listptr2._next) do
			  listptr2 := listptr2._next

			listptr2._next := alcnodelist()
			listptr2._next.current := aut1.start
		      }

		    listptr := listptr._next
		  }

		listptr := returnvalue.accepting

		while \ (listptr._next) do
		  listptr := listptr._next

		listptr._next := aut1.accepting

		listptr := returnvalue.states
		while \ (listptr._next) do
		  listptr := listptr._next

		listptr._next := aut1.states
	      }
	  }
	return returnvalue
      }
    }
end
#line 866 "flexgram.icn"
$define YYACCEPT return 0
$define YYABORT return 1
################################################################
# procedure: yyparse : parse input and execute indicated items
################################################################
procedure yyparse()
  local yyn        # next next thing to do
  local yym        #
  local yystate    # current parsing state from state table
  local yys        # current token string
  local doaction   # set to 1 if there need to execute action
  local token      # current token

  if /yytable then init() 
  init_stacks() 
  yynerrs   := 0 
  yyerrflag := 0 
  yychar    := -1           # impossible char forces a read
  yystate   := 0            # initial state
  push(statestk, yystate)   # save it

  repeat { # until parsing is done, either correctly, or w/error
    doaction := 1 

    ##### NEXT ACTION (from reduction table)
	yyn := yydefred[yystate+1]

    while yyn = 0 do {

      if yychar < 0 then {   # we want a char?
        yychar := yylex()    # get next token
        ##### ERROR CHECK ####
        if yychar < 0 then { # it it didn't work/error
          yychar := 0        # change it to default string (no -1!)
          if \yydebug = 1 then yylexdebug(yystate, yychar) 
          }
        } # yychar < 0
	  
      yyn := yysindex[yystate+1]  # get amount to shift by (shift index)

      if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
         (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
		
        ##### NEXT STATE ####
        yystate := yytable[yyn+1] # we are in a new state
        push(statestk, yystate)   # save it
        push(valstk, yylval)      # push our lval as the input for next rule
        yychar := -1              # since we have 'eaten' a token, say we need another
        if yyerrflag > 0 then     # have we recovered an error?
           yyerrflag -:= 1        # give ourselves credit
        doaction := 0             # but don't process yet
        break                     # quit the yyn=0 loop
        }

    yyn := yyrindex[yystate+1]    # reduce

    if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
       (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
      # e reduced!
      yyn      := yytable[yyn+1] 
      doaction := 1  # get ready to execute
      break          # drop down to actions
      }
    else { #ERROR RECOVERY
      if yyerrflag == 0 then {
        (\yyerror | write)("syntax error") 
        yynerrs +:= 1 
      }
      if yyerrflag < 3 then {     # low error count?
        yyerrflag := 3 
        repeat { #do until break
          if *statestk < 1 then {  # check for under & overflow here
            (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
            return 1 
          }
          yyn := yysindex[statestk[1]] 
          if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
                    yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
            yystate := yytable[yyn+1] 
            push(statestk, yystate) 
            push(valstk, yylval) 
            doaction := 0 
            break 
          }
          else {
            if *statestk = 0 then { # check for under & overflow here
              write("Stack underflow. aborting...") # capital 'S'
              return 1 
            }
            pop(statestk) 
            pop(valstk) 
            }
          }
        }
      else  # discard this token
        {
        if yychar = 0 then return 1  # yyabort
        if \yydebug = 1 then {
          yys := &null 
          if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
          if integer(yys) & yys = 0 then yys := "illegal-symbol" 
          write("state ",  yystate, ", error recovery discards token ",
                yychar, " (", yys, ")") 
          }
        yychar := -1       # read another
        }
      } # end error recovery
      yyn := yydefred[yystate+1] 
    }# yyn = 0 loop

    if doaction = 0 then   # any reason not to proceed?
      next                 # skip action

    yym := yylen[yyn+1]    # get count of terminals on rhs
    yyval := valstk[yym]   # get current semantic value
    if arv := action[yyn]() then return arv # execute the semantic action

    ##### Now let's reduce... ####
    every 1 to yym do pop(statestk)# we just reduced yylen states
    yystate := statestk[1]        # get new state

    every 1 to yym do pop(valstk) # corresponding value drop
    yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
    if yystate = 0 & yym = 0 then {
                                  # done? 'rest' state and at first TERMINAL
      yystate := YYFINAL          # explicitly say we're done
      push(statestk, YYFINAL)     # and save it
      push(valstk, yyval)         # also save the semantic value of parsing
      if yychar < 0 then {        # we want another character?
        yychar := yylex()         # get next character
        if yychar < 0 then yychar := 0   #clean, if necessary
      }
      if yychar = 0 then break    # Good exit (if lex returns 0  -)
                                  # quit the loop--all DONE
    } # if yystate
    else {                        #else not done yet
      # get next state and push, for next yydefred[]
      yyn := yygindex[yym+1]        # find out where to go
      if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
         (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
        yystate := yytable[yyn+1]   # get new state
        }
      else {
        yystate := yydgoto[yym+1]   # else go to new defred
	     }
      push(statestk, yystate)       # going again, so push state & val...
      push(valstk, yyval)           # for next action
      }
    } # main loop

  return 0 # yyaccept!!
end

### end of procedure parse() ######################################

### start semantic actions ########################################

procedure action_null()
  #write("null action")
end

procedure action_1()
#line 48 "flexgram.y"
 labelaut(valstk[1]); createicon(valstk[1]) 
end

procedure action_2()
#line 50 "flexgram.y"
 yyval := convert(valstk[2]) 
end

procedure action_3()
#line 51 "flexgram.y"
 yyval := convert(valstk[1]) 
end

procedure action_4()
#line 52 "flexgram.y"
 yyval := convert(valstk[2]) 
end

procedure action_5()
#line 53 "flexgram.y"
 yyval := convert(valstk[1]) 
end

procedure action_7()
#line 58 "flexgram.y"
 yyval := valstk[2] 
end

procedure action_8()
#line 59 "flexgram.y"
 yyval := valstk[1] 
end

procedure action_11()
#line 65 "flexgram.y"
 yyval := alcnode(EXPRTREE, valstk[3], valstk[1]) 
end

procedure action_13()
#line 69 "flexgram.y"
 yyval := alcnode(EXPRESSION, valstk[2], alcleaf(ACTION, yylval.s))
end

procedure action_14()
#line 71 "flexgram.y"
 yyval := alcnode(EXPRESSION, valstk[1], alcleaf(ACTION, "# fail")) 
end

procedure action_15()
#line 74 "flexgram.y"
 yyval := alcleaf(QUOTES, yylval.s) 
end

procedure action_16()
#line 75 "flexgram.y"
 yyval := alcleaf(BACKSLASH, yylval.s) 
end

procedure action_17()
#line 76 "flexgram.y"
 yyval := alcleaf(CSET, yylval.s) 
end

procedure action_18()
#line 77 "flexgram.y"
 yyval := alcleaf(CHARACTER, yylval.s) 
end

procedure action_19()
#line 78 "flexgram.y"
 yyval := alcleaf(DOT) 
end

procedure action_25()
#line 84 "flexgram.y"
 yyval := alcnode(OREXPR, valstk[3], alcleaf(OR), valstk[1]) 
end

procedure action_26()
#line 85 "flexgram.y"
 yyval := alcnode(CONCATEXPR, valstk[2], alcleaf(CONCAT), valstk[1]) 
end

procedure action_30()
#line 91 "flexgram.y"
 yyval := alcnode(BEGINNING, alcleaf(LINEBEGIN), valstk[1]) 
end

procedure action_31()
#line 94 "flexgram.y"
 yyval := alcnode(ENDING, valstk[2], alcleaf(LINEEND)) 
end

procedure action_32()
#line 97 "flexgram.y"
 yyval := alcnode(QUESTION, valstk[2], alcleaf(OPTIONAL)) 
end

procedure action_33()
#line 100 "flexgram.y"
 yyval := alcnode(STAR, valstk[2], alcleaf(ZEROORMORE)) 
end

procedure action_34()
#line 103 "flexgram.y"
 yyval := alcnode(PLUS, valstk[2], alcleaf(ONEORMORE)) 
end

procedure action_35()
#line 106 "flexgram.y"

	    yyval := alcnode(PARENTHETIC, alcleaf(PARENTHESES),
			  valstk[2], alcleaf(CLOSEPARENTHESES))
	   
end

procedure action_36()
#line 112 "flexgram.y"

	   yyval := alcnode(FORSLASH, valstk[3], alcleaf(FORWARDSLASH), valstk[1])
	   
end

procedure action_37()
#line 117 "flexgram.y"

	   yyval := alcnode(OCCURRENCES, valstk[2], alcleaf(CURLBRACKETS, yylval.s))
	   
end

#line 1160 "flexgram.icn"
