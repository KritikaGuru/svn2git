$include "ytab_h.icn"

record treenode(label, children)
procedure node(label, kids[])
   return treenode(label, kids)
end
procedure leaf(label)
   return treenode(label)
end

global thePackage

procedure yyvarlists(node)
   case type(node) of {
      "treenode" : {
	 if node.label == "varlist2" then {
            yyprint("\n")
	    every yyprint(node.children[1 to 3])
	    }
	 else if node.label == "varlist4" then {
            yyvarlists(node.children[1])
            yyprint("\n")
	    every yyprint(node.children[3 to 5])
	    }
	 else if *node.children > 0 then {
            every yyvarlists(!node.children)
	    }
	 else if node.label === "error" then fail
	 else write("leaf, ", node.label)
     }
   }
end

procedure exists_statlists(node)
   case type(node) of {
      "treenode" : {
	 if node.label == ("stalist2"|"stalist4") then return
	 else if *node.children > 0 then {
            return exists_statlists(!node.children)
	    }
      }
   }
end

procedure yystalists(node)
   case type(node) of {
      "treenode" : {
	 if node.label == "stalist2" then {
            yyprint("\n")
	    every yyprint(node.children[1 to 3])
	    }
	 else if node.label == "stalist4" then {
            yystalists(node.children[1])
            yyprint("\n")
	    every yyprint(node.children[3 to 5])
	    }
	 else if *node.children > 0 then {
            every yystalists(!node.children)
	    }
	 else if node.label === "error" then fail
	 else write("leaf, ", node.label)
     }
   }
end



procedure  emit_code_for_uneval(funcname)
	L := []
	tab(many("`"))
	temp := tab(upto("(.")) 
	if \temp == "\\" then temp := "\\\\"
	put(L,\temp)
	while ( tab(upto(&letters))) do
	{
		temp := tab(many(&letters))
		put(L,temp)
	}
	writes(yyout,funcname, "(")
	writes(yyout, "[")
	every temp := !L\ (*L -1) do
	{
		writes(yyout, "\"", temp,"\",")
	}
 	writes(yyout, "\"", L[*L], "\"")
	writes(yyout, "])")
	return
end


# the unevaluated expressions in pattern matching has the following major cases
# 1. local/global variable ( indicated by absence of . and ( )
# 2. member field          ( indicated by presence of . and absence of ( )  
# 3. procedure invocation  ( indicated by presence of ( and absence of . )
# 4. method invocation     ( indicated by presence of both . ( )
# Currently we return error for cases like x.y.z or x.y.z() ( possible future work
# resolve multiple references
# will add error checking later

procedure process_uneval(node)
	case type(node.s) of 
	{ 
		"string":
		{
			write(node.s)
		 	if node.s[1:3] === "``" then 		
			{
				node.s ?
					{
						if find(".") & find ("(") then
						{
							write("\nFound method call")
							return emit_code_for_uneval("pattern_stringmethodcall")
						}
						else if find ("(") then
						{
							write("\nFound procedure call")
							return emit_code_for_uneval( "pattern_stringfunccall")
						}	
						else
							yyerror("`` must enclose function call", node)
					}	
			}
		 	else
		 	{
		 		node.s ?
					{
						if find(".") & find ("(") then
						{
							write("\nFound method call")
							return emit_code_for_uneval("pattern_boolmethodcall")
						}
						else if find ("(") then
						{
							write("\nFound procedure call")
							return emit_code_for_uneval( "pattern_boolfunccall")
						}	
						else if find(".") then 
						{
						    write("\nFound field reference")
	           				    return emit_code_for_uneval("pattern_unevalvar")
						}
						else
						{
						   write("\nFound variable reference")
						   tab(upto(&letters))
						   temp := tab(many(&letters))
						   writes(yyout,"pattern_unevalvar( ")
						   writes(yyout, "\"", temp, "\"")
						   writes(yyout, ")")
	        	   		           return
						}	
					}
			}
		}	
		default :
		write("Error string expected but got  ", type(node))
	}
end

procedure emit_assign_code(node)
	case type(node) of
	{
		"treenode":
		{
			if ( node.label ~== "field") then
				{
					yyerror("Assignement must be to field")
					return;
				}
			if ( type(node.children[1]) ~== "token") then
				{
					yyerror("Multiple references not supported")
					return;
				}
			writes(yyout,"[","\"",node.children[1].s,"\",\"",node.children[3].s,"\"]")
			return
		}
		"token":
		{
			node.s ??
				{
					rec := tab(upto("."))
					if \rec then &pos +:= 1; # jump over the .
					var := tab(0)
					write("rec =", rec, " var = ",var)
					if (\rec) then writes(yyout,"[","\"",rec,"\",\"",var,"\"]")
					else writes(yyout,"\"",var,"\"")
				}
		}
	}

end

procedure yyprint(node)
   static lasttok
   repeat			# allows us to suppress tail recursion
   case type(node) of {
      "treenode" : {
	 if node.label == "package" then {
	    # noop
	    fail
	    }
	 else if node.label == "import" then {
	    print_imports(node.children[2])
	    fail
	    }
         else if node.label == "packageref" then {
	     if *node.children = 2 then
		 yyprint(node.children[2]) # ::ident
	     else { # ident :: ident
		yyprint(node.children[1])
		writes(yyout, "__")
	        outcol +:= ((* writes(yyout, node.children[3].s)) + 2)
		}
	     fail
	 }
         else if node.label == "global" then {
	    yyprint(node.children[1])
	    node := node.children[2]
	    next
	    }
         else if node.label == "BPand" then {
            writes(yyout, " pattern_concat( ")
	    yyprint(node.children[1])
	    writes(yyout, ",")
	    yyprint(node.children[3])
	    writes(yyout, " ) ")
            fail
	    }	
         else if node.label == "BPor" then {
	    writes(yyout, " pattern_alternate( ")
	    yyprint(node.children[1])
	    writes(yyout, ",")
	    yyprint(node.children[3])
	    writes(yyout, " ) ")		
            fail
        }	
         else if node.label == "BPmatch" then {
	    writes(yyout, " pattern_match( ")
	    yyprint(node.children[1])
	    writes(yyout, ",")
	    yyprint(node.children[3])
	    writes(yyout, " ) ")		
            fail
        }	
         else if node.label == "BPiam" then {
	    writes(yyout, " pattern_assign_immediate( ")
	    yyprint(node.children[1])
	    writes(yyout, ",")
	    yyprint(node.children[3])
	    writes(yyout, ",")
	    emit_assign_code(node.children[3])
	    writes(yyout, " ) ")		
            fail
        }	
         else if node.label == "BPaom" then {
	    writes(yyout, " pattern_assign_onmatch( ")
	    yyprint(node.children[1])
	    writes(yyout, ",")
	    yyprint(node.children[3])
	    writes(yyout, ",")
	    emit_assign_code(node.children[3])
	    writes(yyout, " ) ")		
            fail
        }	
         else if node.label == "upsetcur" then {
	    writes(yyout, " pattern_setcur( ")
	    yyprint(node.children[2])
	    writes(yyout, ",")
	    emit_assign_code(node.children[2])
	    writes(yyout, " ) ")		
            fail
        }	
         else if node.label == "BPuneval" then {
		process_uneval(node.children[1])
                fail
            }	
	 else if node.label == ("varlist2"|"stalist2") then {
	    yyprint(node.children[1])
	    fail
	    }
	 else if node.label == ("varlist4"|"stalist4") then {
	    yyprint(node.children[1])
	    yyprint(node.children[2])
	    node := node.children[3]
	    next
	    }
	 else if node.label == "proc" then {
	    yyprint(node.children[1])
	    every yyprint(node.children[2 to 3])
	    if exists_statlists(node.children[3]) then {
	       ini := node.children[4]
	       yyprint("\ninitial {")
               if ini ~=== EmptyNode then { # append into existing initial
		  yyprint(ini.children[2])
		  yyprint(";\n")
	          }
	       yystalists(node.children[3])
	       yyprint("\n}\n")
	       }
	    else
	       every yyprint(node.children[4])
	    (node.children[1].fields).coercions()
            yyvarlists(node.children[3])
	    yyprint(node.children[5])
	    yyprint(node.children[6])
	    fail
	    }
	 else if *node.children > 0 then {
            every yyprint(node.children[1 to *node.children-1])
	    node := node.children[-1]
	    next
	    }
	 else if node.label === "error" then fail
	 else { write("leaf, ", node.label); fail }
	    }
      "integer": {
	 writes(yyout, node); outcol +:= *string(node)
	 fail
	 }
      "string": {
         node ? {
	    while writes(yyout, tab(find("\n")+1)) do {
	       outline+:=1; outcol:=1;
	       }
	    node := tab(0)
	    }
	 writes(yyout, node); outcol +:= *node
	 fail
         }
      "token": {
	 if outfilename ~== node.filename | outline > node.line then {
	    write(yyout,"\n#line ", node.line-1," \"", node.filename,"\"")
	    outline := node.line
	    outcol := 1
	    outfilename := node.filename
	    }

	 while outline < node.line do {
	    write(yyout); outline +:= 1; outcol := 1
	    }
	 if outcol >= node.column then {
            # force space between idents and reserved words, and other
            # deadly combinations (need to add some more)
            if ((\lasttok).tok = (IDENT|INTLIT|REALLIT) & reswords[node.s][2]~=IDENT)|
		(((\lasttok).tok = NMLT) & (node.tok = MINUS)) |
		((\lasttok).tok = node.tok = PLUS) |
		((\lasttok).tok = node.tok = MINUS) |
		((reswords[(\lasttok).s][2]~=IDENT) & (node.tok=(IDENT|INTLIT|REALLIT)))|
	        ((reswords[(\lasttok).s][2]~=IDENT) & (reswords[node.s][2]~=IDENT))
		   then
	       writes(yyout, " ")
	    }
	 else
	    while outcol < node.column do { writes(yyout, " "); outcol +:= 1 }

	 writes(yyout, node.s)
	 outcol +:= *node.s
	 lasttok := node
	 fail
	 }
      "null": { fail }
      "declaration__state": {
	 node.Write(yyout)
	 fail
	 }
      "Class__state": {
	 node.Write(yyout)
	 fail
	 }
      "argList__state": {
	 node.Write(yyout)
	 fail
	 }
      default: { write("its a ", type(node)); fail }
      }
end

procedure print_imports(node)
   if type(node)=="treenode" & node.label=="lnklist" then {
      print_imports(node.children[1])
      print_imports(node.children[3])
   } else if node.tok = (IDENT|STRINGLIT) then {
      tempp := Package(node.s)
      every fn := (\tempp.files).foreach() do {
         if map(fn)[-4:0]==".icn" then fn[-4:0] := ""
         writelink(tempp.dir, fn)
         outcol := 1
      }
   }
end

#
# This method takes a symbol (a string) and "mangles" it according to which
# imported package it belongs to, or whether it belongs to the local package.
#
procedure mangle_sym(sym)
   initial {
      if \yydbg then {
         dbg := 1
         write("imported syms:---")
         every x := !sort(imported) do {
            s := "["
            every s ||:= !x[2] || ","
            s[-1] := "]"
            write(x[1],"->",s)
         }
         write("------")
      }
   }
                               
   #
   # First check if it is in the package-level symbols defined in this file.
   # These override any imports.
   #
   if member(package_level_syms, sym) then
      return package_mangled_symbol(sym)

   if member(imported, sym) then {
      l := imported[sym]
      if *l > 1 then {
         s := sym || " is imported from several packages: ("
         every s ||:= !l || ","
         s[-1]:=") Use the :: operator to specify which package is intended."
         yyerror(s)
         return sym
      }

      return l[1] || "__" || sym
   }

   return sym
end

#
# This method is the same as above, but just operates on class symbols,
# as opposed to general symbols.
#
procedure mangle_class_sym(sym)
   initial {
      if \yydbg then {
         dbg := 1
         write("imported class syms:---")
         every x := !sort(imported_classes) do {
            s := "["
            every s ||:= !x[2] || ","
            s[-1] := "]"
            write(x[1],"->",s)
         }
         write("------")
      }
   }

   #
   # First check if it is in the classes defined in this file.  These
   # override any imports.
   #
   if member(package_level_class_syms, sym) then
      return package_mangled_symbol(sym)

   if member(imported_classes, sym) then {
      l := imported_classes[sym]
      if *l > 1 then {
         s := sym || " is imported from several packages: ("
         every s ||:= !l || ","
         s[-1]:=") Use the :: operator to specify which package is intended."
         yyerror(s)
         return sym
      }

      return l[1] || "__" || sym
   }

   return sym
end

#
# This function is called to setup the package_level_syms variable.
# This is a set of the package-level symbols defined in this file, ie
# class names, global variables, record names and procedure names.  It
# is called immediately after parsing has completed.  As it comes
# across the symbols it must add, they are mangled. 
#
procedure set_package_level_syms(node)
   local n
   case type(node) of {
      "treenode": {
         case node.label of {
            "decls" : {
               every set_package_level_syms(node.children[1 | 2])
            }

            "global" : {
               n := node.children[2]
               repeat {
                  if type(n) == "token" then {
                     ident_into_package_level_syms(n)
                     return
                  } 
                  ident_into_package_level_syms(n.children[3])
                  n := n.children[1]
               }
            }

            "proc" : {
               ident_into_package_level_syms(node.children[1].name)
            }

         }
      }
      "declaration__state": {  # record declaration
         ident_into_package_level_syms(node.name)
      }
      "Class__state": {
         insert(package_level_syms, node.unmangled_name)
         insert(package_level_class_syms, node.unmangled_name)
         #
         # Process the inner records/globals; these are just
         # treated as top-level declarations.
         #
         every set_package_level_syms(!(\node.glob))
      }
   }

end

#
# Helper function to add the symbol to the set, and mangle it.
#
procedure ident_into_package_level_syms(node)
   insert(package_level_syms, node.s)
   node.s := package_mangled_symbol(node.s)
end

#
# Mangle a symbol according to the package the current file is in (if any).
#
procedure package_mangled_symbol(symbol)
   if /thePackage then
      return symbol
   else
      return thePackage.name || "__" || symbol
end

#
# Mangle a packageref node, ie an explicit package reference in
# the form a::b or ::b
#
procedure mangle_explicit_packageref(node)
   if *node.children = 2 then
      return node.children[2].s
   else
      return node.children[1].s || "__" || node.children[3].s
end

# This function scope-checks the superclass names of the class declarations
# in this file.  Any symbols which refer to packages are mangled
# appropriately. This stage takes place after the package_level_syms set
# has been set up, but before the class definitions have had their fields
# and methods resolved.
#
# As an example a class declaration
# class A : X : Y : Z()
# might be transformed to
# class A : pack1__X : pack2__Y : pack2__Z()
#
#
procedure scopecheck_superclass_decs(node)
   every scopecheck_superclass_dec(classes.foreach_t())
end

#
# Perform the superclass declaration scope-check for the class c.
#
procedure scopecheck_superclass_dec(c)
   local tmp, x

   tmp := idTaque(":")
   x := c.supers_node
   while x ~=== EmptyNode do {
      sc := x.children[2]

      if type(sc) == "token" then
         # Simple reference, so use mangle_class_sym (it must be a class)
         tmp.Put(mangle_class_sym(sc.s))
      else
         # Explicit packageref, eg a::b
         tmp.Put(mangle_explicit_packageref(sc))

      x := x.children[3]
   }

   c.supers := tmp
end

#
# This function is called at the end of the translation process, to mangle
# any symbols in the procedure and method bodies.  For each body, it is
# necessary to construct a set of the parameters, local variables and
# static variables which should NOT be mangled.  For methods, the class
# methods and variables must also be omitted.
#
procedure scopecheck_bodies(node)
   case type(node) of {
      "treenode": {
         case node.label of {
            "decls" : {
               every scopecheck_bodies(node.children[1 | 2])
            }

            "proc" : {
               scopecheck_proc(node)
            }
         }
      }
      "Class__state": {
         scopecheck_methods(node)
      }
   }
end

#
# Scope-check a single procedure definition.
#
procedure scopecheck_proc(node)
   local local_vars, n

   # Build local_vars from the params and local var expressions.
   local_vars := set()
   extract_identifiers(node.children[1].fields, local_vars)
   extract_identifiers(node.children[3], local_vars)

   # The expression in the intially section (if any)
   if node.children[4] ~=== EmptyNode then
      scopecheck_expr(node.children[4].children[2], local_vars)

   # The procbody expressions
   scopecheck_procbody(node.children[5], local_vars)
end

#
# Scope-check the methods in class c
#
procedure scopecheck_methods(c)
   local self_vars
   self_vars := set()

   every insert(self_vars, c.foreachmethod().name)
   every insert(self_vars, c.foreachfield())
   every insert(self_vars, (!c.ifields).ident)
   every insert(self_vars, (!c.imethods).ident)

   every m := c.foreachmethod() do {
      local_vars := set()
      extract_identifiers(m.fields, local_vars)
      extract_identifiers(m.locals, local_vars)

      # The expression in the intially section (if any)
      if m.initl ~=== EmptyNode then
         scopecheck_expr(m.initl.children[2], local_vars, self_vars)
      scopecheck_procbody(m.procbody, local_vars, self_vars)
   }

end

#
# Scope-check a procbody parse node.
#
procedure scopecheck_procbody(n, local_vars, self_vars)
   while n ~=== EmptyNode do {
      scopecheck_expr(n.children[1], local_vars, self_vars)
      n := n.children[3]
   }
end

#
# Scope-check an expression.
#
procedure scopecheck_expr(node, local_vars, self_vars)
   case type(node) of {
      "treenode": {
         if node.label == ("keyword" | "packageref") then
            fail
         else if node.label == "field" then {
            scopecheck_field(node, local_vars, self_vars)
         } else if node.label == ("swap"|"assign"|"revswap"|"revasgn"|
				  "augcat"|"auglcat"|"Bdiffa"|"Buniona"|
				  "Bplusa"|"Bminusa"|"Bstara"|"Bintera"|
				  "Bslasha"|"Bmoda"|"Bcareta"|"Baugeq"|
				  "Baugeqv"|"Baugge"|"Bauggt"|"Baugle"|
				  "Bauglt"|"Baugne"|"Baugneqv"|"Baugseq"|
				  "Baugsge"|"Baugsgt"|"Baugsle"|"Baugslt"|
				  "Baugsne"|"Baugques"|"Baugamper"|"Baugact"|"BPand") then {
            every scopecheck_expr(!node.children, local_vars, self_vars)
	    ckfnasgn(node.children[1], local_vars, self_vars)
         } else
            every scopecheck_expr(!node.children, local_vars, self_vars)
      }
      "token": {
         if node.tok = IDENT then {
            if not member(\local_vars, node.s) then {
               if member(\self_vars, node.s) then
                  node.s := "self." || node.s
               else 
                  node.s := mangle_sym(node.s)
            }
         }
      }
   }
end

procedure scopecheck_field(node, local_vars, self_vars)
   while type(node) == "treenode" & node.label === "field" do {
      lhs := node.children[1]
      rhs := node.children[3]

      if type(rhs) == "token" then {
         if type(lhs) == "token" & lhs.s === "self" then {
            #
            # A special case; the rhs of a self.<tok> expression; the token
	    # should be mangled if it is not in self_vars; it could be in
	    # the form self.super.tok; 'super' must be mangled.
            #
            if not member(\self_vars, rhs.s) then
               rhs.s := mangle_class_sym(rhs.s)
         } else
            rhs.s := mangle_class_sym(rhs.s)
      }

      node := lhs
   }
   
   scopecheck_expr(node, local_vars, self_vars)
end

#
# Helper function to extract the identifiers from a treenode; used to
# conveniently get the identifiers from a list of local variables
# for example.
#
procedure extract_identifiers(node, res)
   /res := set()
   case type(node) of {
      "treenode": {
         if node.label == ("arg2" | "arg3" | "arg4") then
            extract_identifiers(node.children[1], res)
         else
            every extract_identifiers(!node.children, res)
      }
      "token": {
         if node.tok = IDENT then
            insert(res, node.s)
      }
      "argList__state" : {
         # The list node.l is either null, or a mixture of strings and nodes.
         every el := !(\node.l) do {
            if type(el) == "string" then
               insert(res, el)
            else
               extract_identifiers(el, res)
         }
      }
   }
   return res
end

#
# Useful debug function to recursively print a treenode.
#
procedure print_node(node, childindex, indent)
   /indent := 0
   /childindex := " "
   s := repl(" ", indent*3) || childindex || " "

   case type(node) of {
      "treenode" : {
         write(s, "treenode - label=", node.label)
         every i := 1 to *node.children do
            print_node(node.children[i], i, indent+1)
      }
      "integer"|
      "string": {  write(s, type(node), ": ", image(node)) }
      "token": {   write(s, "token(", node.tok, "): ", image(node.s)) }
      "null"|
      "declaration__state"|
      "argList__state": { write(s, image(node)) }
      "Class__state": { write(s, "class: ", image(node)) }
      default: write("its a ", type(node))
   }
end

#
# check whether x is the name of a function that is accidentally being
# assigned.  if it is, issue a warning unless a flag has been set.
#
procedure ckfnasgn(x, locals, selfs)
   if type(x)=="token" & proc(x.s, 0) &
       (not member(\locals,x.s)) & (not member(\selfs,x.s)) then {
      warning("Warning: assignment to built-in function "|| x.s,
              x.line, x.filename)
      }
   return x
end
